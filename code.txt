.
├── 1.sh
├── cleanup_project.py
├── code.txt
├── launcher.sh
├── LICENSE.txt
├── readme.md
├── requirements.txt
└── src
    ├── core
    │   ├── analysis
    │   │   └── tree_analyzer.py
    │   ├── application
    │   │   ├── analysis_service.py
    │   │   ├── calendar_service.py
    │   │   ├── chart_interaction_service.py
    │   │   ├── chart_service.py
    │   │   ├── chat_service.py
    │   │   ├── conversion_service.py
    │   │   ├── __init__.py
    │   │   └── tokenizer_service.py
    │   ├── conversion
    │   │   ├── context.py
    │   │   ├── domain_adapters.py
    │   │   ├── formatters
    │   │   │   ├── __init__.py
    │   │   │   ├── media
    │   │   │   │   ├── game.py
    │   │   │   │   ├── giveaway.py
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── invoice.py
    │   │   │   │   ├── paid_content.py
    │   │   │   │   ├── polls.py
    │   │   │   │   ├── simple_media.py
    │   │   │   │   └── todo.py
    │   │   │   ├── media_formatter.py
    │   │   │   ├── service
    │   │   │   │   ├── atomic.py
    │   │   │   │   ├── complex.py
    │   │   │   │   └── __init__.py
    │   │   │   └── service_formatter.py
    │   │   ├── __init__.py
    │   │   ├── main_converter.py
    │   │   ├── message_formatter.py
    │   │   └── utils.py
    │   ├── dependency_injection.py
    │   ├── domain
    │   │   ├── __init__.py
    │   │   └── models.py
    │   ├── __init__.py
    │   ├── parsing
    │   │   ├── __init__.py
    │   │   └── json_parser.py
    │   ├── settings.py
    │   └── view_models.py
    ├── __main__.py
    ├── presenters
    │   ├── action_presenter.py
    │   ├── analysis_presenter_extended.py
    │   ├── analysis_presenter.py
    │   ├── app_state.py
    │   ├── calendar_presenter.py
    │   ├── config_presenter.py
    │   ├── file_presenter.py
    │   ├── __init__.py
    │   ├── main_presenter.py
    │   ├── modern_presenter.py
    │   ├── preview_service.py
    │   ├── task_manager.py
    │   └── workers.py
    ├── resources
    │   ├── assets
    │   │   └── icons
    │   │       ├── calendar.svg
    │   │       ├── chart.svg
    │   │       ├── download.svg
    │   │       ├── folder_open.svg
    │   │       ├── help.svg
    │   │       ├── save.svg
    │   │       └── settings.svg
    │   ├── fonts
    │   │   └── SourceSans3-Regular.ttf
    │   ├── icons
    │   │   └── icon.png
    │   ├── styles
    │   │   └── base.qss
    │   └── translations.py
    ├── todo.txt
    ├── ui
    │   ├── dialogs
    │   │   ├── analysis
    │   │   │   ├── analysis_dialog.py
    │   │   │   ├── __init__.py
    │   │   │   └── services
    │   │   │       ├── chart_calculation_service.py
    │   │   │       ├── chart_interaction_service.py
    │   │   │       ├── chart_rendering_service.py
    │   │   │       └── __init__.py
    │   │   ├── calendar
    │   │   │   ├── calendar_dialog.py
    │   │   │   ├── __init__.py
    │   │   │   └── services
    │   │   │       ├── calendar_calculation_service.py
    │   │   │       ├── calendar_rendering_service.py
    │   │   │       ├── date_filter_service.py
    │   │   │       └── __init__.py
    │   │   ├── dialog_builder.py
    │   │   ├── export_dialog.py
    │   │   ├── help_dialog.py
    │   │   ├── __init__.py
    │   │   ├── installation_manager_dialog.py
    │   │   └── settings_dialog.py
    │   ├── font_manager.py
    │   ├── icon_manager.py
    │   ├── __init__.py
    │   ├── layout_manager.py
    │   ├── splash_screen.py
    │   ├── theme.py
    │   ├── tkonverter_main_window.py
    │   ├── tkonverter_main_window_ui.py
    │   └── widgets
    │       ├── atomic
    │       │   ├── adaptive_label.py
    │       │   ├── custom_button.py
    │       │   ├── custom_group_widget.py
    │       │   ├── custom_line_edit.py
    │       │   ├── drop_zone_label.py
    │       │   ├── fluent_checkbox.py
    │       │   ├── fluent_radio.py
    │       │   ├── fluent_spinbox.py
    │       │   ├── fluent_switch.py
    │       │   ├── icon_button.py
    │       │   ├── loading_spinner.py
    │       │   ├── minimalist_scrollbar.py
    │       │   └── time_line_edit.py
    │       └── helpers
    │           └── underline_painter.py
    └── utils
        ├── file_utils.py
        ├── __init__.py
        └── paths.py

28 directories, 113 files


--- СОДЕРЖИМОЕ ФАЙЛОВ ---



--- Файл: ./launcher.sh ---
#!/bin/bash

COLOR_RESET="\033[0m"
BG_RED="\033[0;41m"
BG_GREEN="\033[0;42m"
BG_PROGRESS="\033[48;5;11m"
TEXT_WHITE="\033[1;37m"
TEXT_BLACK="\033[1;30m"

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
APP_MAIN="$SCRIPT_DIR/src/__main__.py"
VENV_DIR="$SCRIPT_DIR/venv"
REQUIREMENTS="$SCRIPT_DIR/requirements.txt"

log_info() {
    printf "%s\n" "$1"
}

log_status() {
    local message="$1"
    local status_code="$2"

    if [[ "$status_code" -eq 0 ]]; then
        printf "%s ${BG_GREEN}${TEXT_WHITE}[OK]${COLOR_RESET}\n" "$message"
    else
        printf "%s ${BG_RED}${TEXT_WHITE}[ERROR]${COLOR_RESET}\n" "$message"
    fi
}

show_spinner() {
    local pid=$1
    local msg=$2
    local delay=0.1
    local spinstr='/-\|'

    tput civis
    trap 'tput cnorm' EXIT

    while ps -p "$pid" >/dev/null; do
        local temp=${spinstr#?}
        printf "\r\033[K%s %c " "$msg" "${spinstr:0:1}"
        spinstr=$temp${spinstr%"$temp"}
        sleep "$delay"
    done

    tput cnorm
}

run_with_spinner() {
    local base_msg=$1
    shift

    local terminal_cols=$(tput cols 2>/dev/null)
    if [[ -z "$terminal_cols" || "$terminal_cols" -eq 0 ]]; then
        terminal_cols=80
    fi
    local max_spinner_msg_len=$((terminal_cols - 10))
    local spinner_msg_content="$base_msg"
    if [[ ${#spinner_msg_content} -gt "$max_spinner_msg_len" ]]; then
        spinner_msg_content="${spinner_msg_content:0:$((max_spinner_msg_len - 3))}..."
    fi

    local error_log
    error_log=$(mktemp) || {
        log_status "Failed to create temporary file" 1
        exit 1
    }
    trap 'rm -f "$error_log"' RETURN

    "$@" >/dev/null 2>"$error_log" &
    local cmd_pid=$!

    show_spinner "$cmd_pid" "$spinner_msg_content"
    wait "$cmd_pid"
    local exit_code=$?

    printf "\r\033[K"

    if [[ $exit_code -ne 0 ]]; then
        printf "%s ${BG_RED}${TEXT_WHITE}[ERROR]${COLOR_RESET}\n" "$base_msg"
        sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,3})*)?[mGK]//g" "$error_log" >&2
    else
        printf "%s ${BG_GREEN}${TEXT_WHITE}[OK]${COLOR_RESET}\n" "$base_msg"
    fi

    return $exit_code
}

run_pip_with_inline_progress() {
    local base_msg=$1
    shift

    if [[ ! -f "$REQUIREMENTS" ]]; then
        log_status "'requirements.txt' not found" 1
        return 1
    fi

    local total_packages
    total_packages=$(grep -cE '^\s*[^#\s]' "$REQUIREMENTS")
    total_packages=${total_packages// /}

    if [[ "$total_packages" -eq 0 ]]; then
        log_info "$base_msg (No packages to install)."
        return 0
    fi

    local COLLECT_WEIGHT=30
    local DOWNLOAD_WEIGHT=60
    local collect_count=0
    local download_count=0
    local updated=false

    local error_log
    error_log=$(mktemp) || {
        log_status "Failed to create temporary file" 1
        exit 1
    }
    trap 'rm -f "$error_log"' RETURN

    printf "%s ${BG_PROGRESS}${TEXT_BLACK}[0%%]${COLOR_RESET}\n" "$base_msg"

    "$@" 2>"$error_log" | while IFS= read -r line; do
        local percentage=0
        updated=false

        if [[ "$line" == "Collecting "* ]]; then
            ((collect_count++))
            updated=true
        elif [[ "$line" == "Downloading "* || "$line" == "Using cached "* ]]; then
            ((download_count++))
            updated=true
        elif [[ "$line" == "Requirement already satisfied:"* ]]; then
            ((collect_count++))
            ((download_count++))
            updated=true
        elif [[ "$line" == "Installing collected packages"* ]]; then
            collect_count=$total_packages
            download_count=$total_packages
            updated=true
        fi

        if [[ "$updated" = true ]]; then
            percentage=$(((collect_count * COLLECT_WEIGHT) / total_packages + (download_count * DOWNLOAD_WEIGHT) / total_packages))
            [[ "$percentage" -gt 99 ]] && percentage=99
            printf "\033[A\r\033[K%s ${BG_PROGRESS}${TEXT_BLACK}[%d%%]${COLOR_RESET}\n" "$base_msg" "$percentage"
        fi
    done

    local exit_code=${PIPESTATUS[0]}

    printf "\033[A\r\033[K"
    if [[ $exit_code -eq 0 ]]; then
        log_status "$base_msg" 0
    else
        log_status "$base_msg" 1
        sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,3})*)?[mGK]//g" "$error_log" >&2
    fi

    return $exit_code
}

get_canonical_path() {
    if [[ -z "$1" ]]; then return 1; fi
    local resolved_path
    if [[ -d "$1" ]]; then
        resolved_path="$(cd "$1" && pwd)"
    elif [[ -f "$1" ]]; then
        resolved_path="$(cd "$(dirname "$1")" && pwd)/$(basename "$1")"
    else
        local parent_dir=$(dirname "$1")
        if [[ -d "$parent_dir" ]]; then
            resolved_path="$(cd "$parent_dir" && pwd)/$(basename "$1")"
        else
            echo "$1"
            return 0
        fi
    fi
    echo "$resolved_path"
    return 0
}

activate_venv() {
    local activate_script=""
    local canonical_venv_dir=$(get_canonical_path "$VENV_DIR")
    if [[ -f "$VENV_DIR/bin/activate" ]]; then
        activate_script="$VENV_DIR/bin/activate"
    elif [[ -f "$VENV_DIR/Scripts/activate" ]]; then activate_script="$VENV_DIR/Scripts/activate"; fi

    if [[ -n "$activate_script" ]]; then
        source "$activate_script"
        return 0
    else
        return 1
    fi
}

deactivate_venv() {
    if command -v deactivate >/dev/null 2>&1; then
        deactivate
    fi
    unset VIRTUAL_ENV
}

setup_new_venv() {
    local python_executable=""
    if command -v python3 &>/dev/null; then
        python_executable="python3"
    elif command -v python &>/dev/null; then
        python_executable="python"
    else return 1; fi

    "$python_executable" -m venv "$VENV_DIR" &&
        (source "$VENV_DIR/bin/activate" || source "$VENV_DIR/Scripts/activate") &&
        python -m pip install --upgrade pip --disable-pip-version-check --quiet
    return $?
}

ensure_venv_is_ready() {
    local retry_done=false
    while true; do
        if [[ ! -d "$VENV_DIR" ]]; then
            if ! run_with_spinner "Setting up virtual environment at '$VENV_DIR'" setup_new_venv; then
                log_status "Critical error: Failed to create venv" 1
                return 1
            fi
            if ! activate_venv; then
                log_status "Critical error: Failed to activate newly created venv" 1
                rm -rf "$VENV_DIR"
                return 1
            fi
            if ! run_pip_with_inline_progress "Installing dependencies" python -m pip install -r "$REQUIREMENTS" --disable-pip-version-check; then
                log_status "Critical error: Failed to install dependencies in new venv" 1
                rm -rf "$VENV_DIR"
                return 1
            fi
            touch "$VENV_DIR/.installed"
            return 0
        else
            if ! activate_venv; then
                log_status "Failed to activate existing venv. Considering it corrupted" 1
                if $retry_done; then
                    log_status "Error: Retry activation also failed" 1
                    return 1
                fi
                log_info "Removing potentially corrupted venv for recreation..."
                rm -rf "$VENV_DIR"
                retry_done=true
                continue
            fi

            local update_needed=false
            if [[ ! -f "$VENV_DIR/.installed" ]] || [[ "$REQUIREMENTS" -nt "$VENV_DIR/.installed" ]]; then
                update_needed=true
            fi

            if $update_needed; then
                if ! run_pip_with_inline_progress "Checking/Updating dependencies" python -m pip install -r "$REQUIREMENTS" --disable-pip-version-check; then
                    log_status "Dependency installation failed. Venv may be corrupted." 1
                    if $retry_done; then
                        log_status "Error: Dependency installation failed again" 1
                        return 1
                    fi
                    log_info "Removing venv for recreation..."
                    deactivate_venv
                    rm -rf "$VENV_DIR"
                    retry_done=true
                    continue
                else
                    touch "$VENV_DIR/.installed"
                fi
            else
                log_status "Dependencies are up to date" 0
            fi
            return 0
        fi
    done
}

enable_logging_action() {
    log_info "Attempting to enable logging..."
    if ensure_venv_is_ready; then
        python "$APP_MAIN" --enable-logging
        deactivate_venv
        log_status "Logging settings updated" 0
    else
        log_status "Failed to prepare environment. Aborting." 1
        exit 1
    fi
}

disable_logging_action() {
    log_info "Attempting to disable logging..."
    if ensure_venv_is_ready; then
        python "$APP_MAIN" --disable-logging
        deactivate_venv
        log_status "Logging settings updated" 0
    else
        log_status "Failed to prepare environment. Aborting." 1
        exit 1
    fi
}

show_help() {
    echo "Tkonverter - Telegram Chat Converter"
    echo "Usage: $0 <command> [options]"
    echo "       $0 [--debug|-d] [--theme <dark|light>]"
    echo ""
    echo "Commands:"
    echo "  run [args...]      Run the application with optional GUI arguments."
    echo "                     Additional flags for 'run' (also valid at top-level):"
    echo "                       --theme <dark|light>  Force a specific theme."
    echo "                       --debug, -d          Enable debug logging for this session only."
    echo "  install            Create the virtual environment and/or install dependencies."
    echo "  recreate           Forcibly recreate the virtual environment."
    echo "  delete             Delete the virtual environment and caches."
    echo "  --enable-logging   Permanently enable debug logging."
    echo "  --disable-logging  Permanently disable debug logging."
    echo "  help               Show this help message."
}

recreate_action() {
    log_info "Recreating virtual environment..."
    if [ -d "$VENV_DIR" ]; then
        log_info "Removing existing venv in '$VENV_DIR'..."
        deactivate_venv
        if rm -rf "$VENV_DIR"; then
            log_status "Existing venv removed" 0
        else
            log_status "Failed to remove venv. Remove manually" 1
            exit 1
        fi
    fi
    ensure_venv_is_ready
}

delete_action() {
    log_info "Starting cleanup..."
    if [ -d "$VENV_DIR" ]; then
        log_info "Removing virtual environment in '$VENV_DIR'..."
        deactivate_venv
        rm -rf "$VENV_DIR"
        log_status "Virtual environment removed" 0
    else
        log_info "Virtual environment not found, skipping."
    fi

    log_info "Removing '__pycache__' directories..."
    find "$SCRIPT_DIR" -type d -name "__pycache__" -exec rm -rf {} +
    log_status "'__pycache__' directories removed" 0
    log_info "Cleanup completed."
}

handle_interrupt() {
    printf "\n"
    log_info "Operation cancelled by user. Cleaning up..."
    tput cnorm 2>/dev/null || true
    deactivate_venv
    log_info "Cleanup completed. Exiting."
    printf "${COLOR_RESET}\n"
    exit 130
}
trap handle_interrupt INT

if [[ "$1" == "--debug" || "$1" == "-d" || "$1" == "--theme" ]]; then
    set -- run "$@"
fi

COMMAND=$1
case "$COMMAND" in

install)
    if ensure_venv_is_ready; then
        log_info "Environment is ready."
    else
        log_status "Failed to set up environment." 1
        exit 1
    fi
    deactivate_venv
    ;;

run)
    shift
    gui_args=()
    THEME_TO_SET=""
    DEBUG_MODE="false"

    while [[ $# -gt 0 ]]; do
        case "$1" in
        --theme)
            if [[ -n "$2" && ("$2" == "dark" || "$2" == "light") ]]; then
                THEME_TO_SET="$2"
                shift 2
            else
                log_info "Error: --theme requires argument (dark or light)"
                exit 1
            fi
            ;;
        --debug | -d)
            DEBUG_MODE="true"
            shift
            ;;
        *)
            log_info "Error: Unknown option '$1' for run command."
            show_help
            exit 1
            ;;
        esac
    done

    if ensure_venv_is_ready; then
        log_info "Starting Tkonverter application..."
        export DEBUG="$DEBUG_MODE"
        if [[ -n "$THEME_TO_SET" ]]; then
            APP_THEME="$THEME_TO_SET" python "$APP_MAIN"
        else
            python "$APP_MAIN"
        fi
        app_exit_code=$?
        deactivate_venv
        log_info "Application completed with exit code: $app_exit_code"
        exit $app_exit_code
    else
        deactivate_venv
        log_status "Failed to prepare environment. Aborting." 1
        exit 1
    fi
    ;;

recreate)
    recreate_action
    deactivate_venv
    ;;

delete)
    delete_action
    ;;
--enable-logging)
    enable_logging_action
    ;;

--disable-logging)
    disable_logging_action
    ;;
"" | help | --help)
    show_help
    ;;

*)
    log_info "Error: Unknown command '$COMMAND'"
    show_help
    exit 1
    ;;
esac

printf "${COLOR_RESET}"
exit 0


--- Файл: ./cleanup_project.py ---
#!/usr/bin/env python3

import argparse
import io
import os
import re
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Set
import tokenize

SAFE_EXCLUDED_DIRNAMES = {
    ".git",
    "venv",
    ".venv",
    "env",
    ".env",
    "build",
    "dist",
    "__pycache__",
    "node_modules",
}

DEFAULT_KEEP_COMMENT_KEYWORDS = {

    "noqa",
    "type: ignore",
    "fmt: off",
    "fmt: on",
    "isort: skip",
    "pylint",
    "pragma",
    "pyright:",
    "mypy:",
    "coding:",
}

DEFAULT_KEEP_SHELL_COMMENT_KEYWORDS = {
    "shellcheck",
}

ENCODING_COOKIE_RE = re.compile(r"coding[:=]\s*([-\.\w]+)")

def discover_source_files(paths: List[Path]) -> Dict[str, List[Path]]:
    """Находит .py и .sh файлы в указанных путях."""
    discovered: Dict[str, List[Path]] = {"py": [], "sh": []}
    for root_path in paths:
        if root_path.is_file():
            if root_path.suffix == ".py":
                discovered["py"].append(root_path)
            elif root_path.suffix == ".sh":
                discovered["sh"].append(root_path)
            continue
        if not root_path.exists():
            continue
        for dirpath, dirnames, filenames in os.walk(root_path):
            dirnames[:] = [
                d for d in dirnames if d not in SAFE_EXCLUDED_DIRNAMES and not d.startswith(".")
            ]
            for filename in filenames:
                if filename.endswith(".py"):
                    discovered["py"].append(Path(dirpath) / filename)
                elif filename.endswith(".sh"):
                    discovered["sh"].append(Path(dirpath) / filename)
    return discovered

def has_shebang(line: str) -> bool:
    """Проверяет, является ли строка shebang'ом."""
    return line.startswith("#!")

def has_encoding_cookie(line: str) -> bool:
    """Проверяет, содержит ли строка кодировку (PEP 263)."""
    return ENCODING_COOKIE_RE.search(line) is not None

def should_keep_py_comment(comment_text: str, keep_keywords: Set[str]) -> bool:
    """Определяет, следует ли сохранить комментарий в Python коде."""
    lower = comment_text.lower()
    return any(kw in lower for kw in keep_keywords)

def should_keep_sh_comment(comment_line: str, keep_keywords: Set[str]) -> bool:
    """Определяет, следует ли сохранить комментарий в Shell скрипте."""

    text_part = comment_line.lstrip()[1:].lstrip()
    lower = text_part.lower()
    return any(kw in lower for kw in keep_keywords)

def strip_python_comments(source: str, keep_keywords: Set[str]) -> str:
    """Удаляет ненужные комментарии из Python кода."""
    lines = source.splitlines(keepends=True)
    preserved_prefix: List[str] = []
    remaining_start_index = 0

    if lines and has_shebang(lines[0]):
        preserved_prefix.append(lines[0])
        remaining_start_index = 1

    if remaining_start_index < len(lines) and has_encoding_cookie(lines[remaining_start_index]):
        preserved_prefix.append(lines[remaining_start_index])
        remaining_start_index += 1

    remaining = "".join(lines[remaining_start_index:])
    tokens: List[tokenize.TokenInfo] = []
    try:
        tok_iter = tokenize.tokenize(io.BytesIO(remaining.encode("utf-8")).readline)
        for tok in tok_iter:
            if tok.type == tokenize.COMMENT:
                if should_keep_py_comment(tok.string, keep_keywords):
                    tokens.append(tok)
            else:
                tokens.append(tok)
    except tokenize.TokenError:
        return source

    try:
        processed = tokenize.untokenize(tokens)
        processed_text = processed.decode("utf-8") if isinstance(processed, bytes) else processed
    except Exception:
        return source

    processed_text = re.sub(r"[ \t]+$", "", processed_text, flags=re.MULTILINE)
    processed_text = re.sub(r"\n{3,}", "\n\n", processed_text)
    final_text = "".join(preserved_prefix) + processed_text
    if not final_text.endswith("\n"):
        final_text += "\n"
    return final_text

def strip_shell_comments(source: str, keep_keywords: Set[str]) -> str:
    """Удаляет ненужные комментарии из Shell скрипта."""
    lines = source.splitlines(keepends=True)
    if not lines:
        return ""

    new_lines: List[str] = []
    start_index = 0
    if has_shebang(lines[0]):
        new_lines.append(lines[0])
        start_index = 1

    for line in lines[start_index:]:
        stripped_line = line.lstrip()
        if stripped_line.startswith("#"):
            if should_keep_sh_comment(stripped_line, keep_keywords):
                new_lines.append(line)
        else:
            new_lines.append(line)

    result = "".join(new_lines)
    result = re.sub(r"\n{3,}", "\n\n", result)
    if not result.endswith("\n"):
        result += "\n"
    return result

def write_if_changed(path: Path, new_content: str, dry_run: bool) -> bool:
    """Записывает контент, если он изменился."""
    try:
        old_content = path.read_text(encoding="utf-8")
    except Exception:
        old_content = None
    if old_content == new_content:
        return False
    if dry_run:
        return True
    path.write_text(new_content, encoding="utf-8")
    return True

def run_command(cmd: List[str]) -> int:
    """Выполняет команду в подпроцессе."""
    try:
        return subprocess.run(cmd, check=False).returncode
    except FileNotFoundError:
        print(f"[ERROR] Команда '{cmd[0]}' не найдена.", file=sys.stderr)
        return 127

def ensure_tool(cli_name: str, pip_name: Optional[str], allow_install: bool) -> bool:
    """Проверяет наличие инструмента и при необходимости устанавливает его."""
    if shutil.which(cli_name):
        return True

    if not pip_name:
        print(f"[WARN] Инструмент '{cli_name}' не найден в PATH. Установите его вручную.")
        return False

    if not allow_install:
        print(f"[WARN] Инструмент '{cli_name}' не найден в PATH. Пропускаю установку.")
        return False

    print(f"[INFO] Устанавливаю '{pip_name}'...")
    code = run_command([sys.executable, "-m", "pip", "install", "-q", pip_name])
    if code != 0:
        print(f"[ERROR] Не удалось установить '{pip_name}'. Код: {code}", file=sys.stderr)
        return False
    return shutil.which(cli_name) is not None

def apply_tooling(
    py_files: List[Path],
    sh_files: List[Path],
    skip_ruff: bool,
    skip_isort: bool,
    skip_black: bool,
    skip_shellcheck: bool,
    skip_shfmt: bool,
    allow_install: bool,
    line_length: int,
) -> None:
    """Применяет линтеры и форматтеры к файлам."""

    if py_files:
        py_targets = [str(p) for p in py_files]
        if not skip_ruff and ensure_tool("ruff", "ruff", allow_install):
            print("[INFO] Запуск: ruff (удаление неиспользуемых импортов/переменных)")
            run_command([sys.executable, "-m", "ruff", "check", "--select", "F", "--fix", *py_targets])

        if not skip_isort and ensure_tool("isort", "isort", allow_install):
            print("[INFO] Запуск: isort (сортировка импортов)")
            run_command([sys.executable, "-m", "isort", "--profile", "black", f"--line-length={line_length}", *py_targets])

        if not skip_black and ensure_tool("black", "black", allow_install):
            print("[INFO] Запуск: black (форматирование кода)")
            run_command([sys.executable, "-m", "black", f"--line-length={line_length}", *py_targets])

    if sh_files:
        sh_targets = [str(p) for p in sh_files]
        if not skip_shellcheck and ensure_tool("shellcheck", None, allow_install):
            print("[INFO] Запуск: shellcheck (анализ скриптов)")
            run_command(["shellcheck", *sh_targets])

        if not skip_shfmt and ensure_tool("shfmt", None, allow_install):
            print("[INFO] Запуск: shfmt (форматирование скриптов)")
            run_command(["shfmt", "-w", "-i", "4", *sh_targets])

def main(argv: Iterable[str] = None) -> int:
    parser = argparse.ArgumentParser(
        description=(
            "Очистка Python (.py) и Shell (.sh) кода: удаление комментариев, "
            "линтеры и форматтеры. По умолчанию обрабатывает текущий каталог."
        )
    )

    parser.add_argument("paths", nargs="*", type=Path, help="Пути к файлам/папкам (по умолчанию: текущий каталог).")
    parser.add_argument("--dry-run", action="store_true", help="Показать изменения без записи на диск.")
    parser.add_argument("--only-comments", action="store_true", help="Только удалять комментарии, пропустить форматтеры.")
    parser.add_argument("--no-install", action="store_true", help="Не устанавливать автоматически отсутствующие инструменты.")
    parser.add_argument("--line-length", type=int, default=88, help="Длина строки для форматтеров (isort/black).")

    py_group = parser.add_argument_group("Python (.py) options")
    py_group.add_argument("--skip-ruff", action="store_true", help="Пропустить ruff.")
    py_group.add_argument("--skip-isort", action="store_true", help="Пропустить isort.")
    py_group.add_argument("--skip-black", action="store_true", help="Пропустить black.")
    py_group.add_argument("--keep-keywords", type=str, default=",".join(sorted(DEFAULT_KEEP_COMMENT_KEYWORDS)),
                          help="Ключевые слова для сохранения комментариев в Python (через запятую).")

    sh_group = parser.add_argument_group("Shell (.sh) options")
    sh_group.add_argument("--skip-shellcheck", action="store_true", help="Пропустить shellcheck.")
    sh_group.add_argument("--skip-shfmt", action="store_true", help="Пропустить shfmt.")
    sh_group.add_argument("--keep-sh-keywords", type=str, default=",".join(sorted(DEFAULT_KEEP_SHELL_COMMENT_KEYWORDS)),
                          help="Ключевые слова для сохранения комментариев в Shell (через запятую).")

    args = parser.parse_args(list(argv) if argv is not None else None)

    targets = [p.resolve() for p in args.paths] if args.paths else [Path.cwd()]

    source_files = discover_source_files(targets)
    py_files, sh_files = source_files["py"], source_files["sh"]

    if not py_files and not sh_files:
        print("[INFO] Не найдено Python или Shell файлов для обработки.")
        return 0

    py_keep_kw = {kw.strip().lower() for kw in args.keep_keywords.split(",") if kw.strip()}
    sh_keep_kw = {kw.strip().lower() for kw in args.keep_sh_keywords.split(",") if kw.strip()}

    changed_files: List[Path] = []

    for file_path in py_files:
        try:
            original = file_path.read_text(encoding="utf-8")
            cleaned = strip_python_comments(original, py_keep_kw)
            if write_if_changed(file_path, cleaned, args.dry_run):
                changed_files.append(file_path)
        except Exception as e:
            print(f"[ERROR] Не удалось обработать файл {file_path}: {e}", file=sys.stderr)

    for file_path in sh_files:
        try:
            original = file_path.read_text(encoding="utf-8")
            cleaned = strip_shell_comments(original, sh_keep_kw)
            if write_if_changed(file_path, cleaned, args.dry_run):
                changed_files.append(file_path)
        except Exception as e:
            print(f"[ERROR] Не удалось обработать файл {file_path}: {e}", file=sys.stderr)

    if args.dry_run:
        print(f"[DRY-RUN] Будет изменено файлов после удаления комментариев: {len(changed_files)}")
        for f in changed_files:
            print(f"  - {f.relative_to(Path.cwd())}")
    else:
        print(f"[INFO] Изменено файлов (удаление комментариев): {len(changed_files)}")

    if not args.only_comments:
        apply_tooling(
            py_files=py_files,
            sh_files=sh_files,
            skip_ruff=args.skip_ruff,
            skip_isort=args.skip_isort,
            skip_black=args.skip_black,
            skip_shellcheck=args.skip_shellcheck,
            skip_shfmt=args.skip_shfmt,
            allow_install=not args.no_install,
            line_length=args.line_length,
        )

    print("[DONE] Завершено.")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())


--- Файл: ./.gitignore ---
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[codz]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py.cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock
#poetry.toml

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#   pdm recommends including project-wide configuration in pdm.toml, but excluding .pdm-python.
#   https://pdm-project.org/en/latest/usage/project/#working-with-version-control
#pdm.lock
#pdm.toml
.pdm-python
.pdm-build/

# pixi
#   Similar to Pipfile.lock, it is generally recommended to include pixi.lock in version control.
#pixi.lock
#   Pixi creates a virtual environment in the .pixi directory, just like venv module creates one
#   in the .venv directory. It is recommended not to include this directory in version control.
.pixi

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.envrc
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# Abstra
# Abstra is an AI-powered process automation framework.
# Ignore directories containing user credentials, local state, and settings.
# Learn more at https://abstra.io/docs
.abstra/

# Visual Studio Code
#  Visual Studio Code specific template is maintained in a separate VisualStudioCode.gitignore 
#  that can be found at https://github.com/github/gitignore/blob/main/Global/VisualStudioCode.gitignore
#  and can be added to the global gitignore or merged into this file. However, if you prefer, 
#  you could uncomment the following to ignore the entire vscode folder
# .vscode/

# Ruff stuff:
.ruff_cache/

# PyPI configuration file
.pypirc

# Cursor
#  Cursor is an AI-powered code editor. `.cursorignore` specifies files/directories to
#  exclude from AI features like autocomplete and code analysis. Recommended for sensitive data
#  refer to https://docs.cursor.com/context/ignore-files
.cursorignore
.cursorindexingignore

# Marimo
marimo/_static/
marimo/_lsp/
__marimo__/


--- Файл: ./code.txt ---


--- Файл: ./1.sh ---
tree -I "venv|.venv|__pycache__|build|dist|.git|.idea|.vscode|.pytest_cache|Cache|blob_storage" --prune >code.txt

echo -e "\n\n--- СОДЕРЖИМОЕ ФАЙЛОВ ---\n" >>code.txt

find . \
    -type d \( -name "venv" -o -name ".venv" -o -name "__pycache__" -o -name "build" -o -name "dist" -o -name ".git" -o -name ".vscode" -o -name ".idea" -o -name ".pytest_cache" -o -name "Cache" -o -name "blob_storage" \) -prune \
    -o \
    -type f -not \( \
    -name "*.pyc" -o -name "*.so" -o -name "*.o" -o -name "*.a" \
    -o -name "*.png" -o -name "*.jpg" -o -name "*.jpeg" -o -name "*.gif" -o -name "*.svg" -o -name "*.webp" -o -name "*.ico" \
    -o -name "*.ttf" -o -name "*.otf" -o -name "*.woff" -o -name "*.woff2" -o -name "*.eot" \
    -o -name "*.mp4" -o -name "*.avi" -o -name "*.mkv" -o -name "*.mov" -o -name "*.flv" -o -name "*.webm" -o -name "*.3gp" -o -name "*.mpeg" -o -name "*.mpg" \
    -o -name "*.map" -o -name "*.zip" -o -name "*.gz" -o -name "*.tar" -o -name "*.rar" \
    -o -name "LICENSE" -o -name "LICENSE.txt" \
    \) -print0 | xargs -0 -I {} sh -c 'echo -e "\n\n--- Файл: {} ---"; cat "{}";' >>code.txt

echo "Файл code.txt успешно создан."


--- Файл: ./requirements.txt ---
PyQt6>=6.4.0
matplotlib>=3.5.0
numpy>=1.21.0
Pillow>=8.3.0

--- Файл: ./readme.md ---
<p align="center">
  <img src="https://raw.githubusercontent.com/Loganavter/media_archive/1.5.1/Tkonverter/icons/logo.png" alt="Logo" width="100">
</p>

<p align="center">
  <strong>An open-source desktop tool for converting and analyzing exported Telegram chats.</strong>
</p>

<p align="center">
  <a href="https://github.com/Loganavter/Tkonverter/releases/latest">
    <img src="https://img.shields.io/github/v/release/Loganavter/Tkonverter?style=flat-square&label=latest%20release">
  </a>
  <a href="LICENSE">
    <img src="https://img.shields.io/github/license/Loganavter/Tkonverter?style=flat-square">
  </a>
  <a href="https://github.com/Loganavter/Tkonverter/issues">
    <img src="https://img.shields.io/github/issues/Loganavter/Tkonverter?style=flat-square">
  </a>
</p>

---

## 📸 Screenshot

<div align="center">
  <img src="https://raw.githubusercontent.com/Loganavter/media_archive/1.5.2/Tkonverter/screenshots/screenshot_2.png" width="24%">
  <img src="https://raw.githubusercontent.com/Loganavter/media_archive/1.5.2/Tkonverter/screenshots/screenshot_1.png" width="50%">
  <img src="https://raw.githubusercontent.com/Loganavter/media_archive/1.5.2/Tkonverter/screenshots/screenshot_3.png" width="24%">
</div>

---

## 📖 Table of Contents

- [Overview](#overview)
- [Key Features](#key-features)
- [Installation](#installation)
- [Usage](#usage)
- [Roadmap](#roadmap)
- [Contributing](#contributing)
- [Development Story](#development-story)
- [License](#license)

---

## 🧩 Overview <a name="overview"></a>

Tkonverter is a free and open-source desktop application designed to convert large Telegram JSON exports into a clean `.txt` format.

The project was initially created to preprocess chat data for use with Large Language Models (LLMs) like Gemini. Its features are centered around the need to manage LLM context windows effectively—either by compressing information (e.g., shortening quotes, truncating names) to save tokens, or by enriching it (e.g., including reactions, polls, Markdown) for higher-quality analysis.

While its primary goal is LLM pre-processing, it is a versatile tool that may be useful for any chat archiving or analysis needs.

---

## 🚀 Key Features <a name="key-features"></a>

### 🔄 Advanced Conversion & Context Control
- **Flexible Profiles**: Supports group chats, personal conversations, channels, and posts. The app automatically detects the correct profile in most cases.
- **Context Saving Tools**: Reduce token count with options to automatically shorten replied-to message snippets and truncate long usernames.
- **Rich Context Options**: Choose to include detailed information like reactions, poll results, links, and full Markdown formatting for the highest quality input.
- **Fine-Grained Control**: Toggle the visibility of timestamps, service messages, and technical information.

### 📊 Analytics for LLM Pre-processing
- **Token & Character Counting**: Calculate the exact token count (using Hugging Face tokenizers) or character count to understand how formatting choices impact the final data size.
- **Interactive Chart**: Visualize message volume over time with a sunburst chart inspired by KDE Filelight.
- **Data Filtering**: Exclude irrelevant time periods from your export by clicking on chart segments, allowing you to refine the context sent to a model.

### 🤖 Optional AI Integration
- **Hugging Face Support**: For precise, model-specific token analysis.
- **Built-in Installer**: Install required Python libraries (`transformers`, `huggingface_hub`) and download models directly from the UI—no terminal needed.

### 🧑‍💻 User Experience & Tooling
- **Cross-Platform**: Built with Python and PyQt6.
- **Theming**: Supports light and dark modes, with auto-detection of your system's theme.
- **Powerful Launcher**: A `launcher.sh` script simplifies dependency management in a virtual environment, running, and debugging.

---

## 🛠️ Installation <a name="installation"></a>

Currently, the primary installation method is by running from the source code.

### 🐍 From Source (Linux/macOS)
The `launcher.sh` script will automatically create a virtual environment and install all dependencies.
```bash
git clone https://github.com/Loganavter/Tkonverter.git
cd Tkonverter
chmod +x launcher.sh
./launcher.sh run
```
Use `./launcher.sh --help` for a full list of commands (including `recreate`, `delete`, `profile`).

### 🪟 Windows, 🐧 Linux, 🍏 macOS
Installers and distribution packages are planned for the future. Contributions are welcome!

---

## 🧪 Usage <a name="usage"></a>

1.  **Launch** the application: `./launcher.sh run`.
2.  **Drag and drop** your `result.json` file (from a Telegram export) into the application window.
3.  **Configure** the formatting options on the left panel.
4.  **(Optional)** Click **"Recalculate"** to analyze tokens and open the chart for visualization.
5.  **Click** **"Save to file..."** to export the result as a `.txt` file.

---

## 🗺️ Roadmap <a name="roadmap"></a>

The core application is complete and stable. The primary focus now is on making it easily accessible to users. Creation of installers for **Windows** and packages for **Linux (AUR, Flatpak)** is the next major milestone.

---

## 🤝 Contributing <a name="contributing"></a>

This project is in its early stages, so all contributions are highly welcome! Feel free to create [Issues](https://github.com/Loganavter/Tkonverter/issues) with bug reports or feature suggestions, and submit [Pull Requests](https://github.com/Loganavter/Tkonverter/pulls).

---

## 📄 License <a name="license"></a>

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

---

## 🧠 Development Story <a name="development-story"></a>
<details>
<summary>Show Development Story</summary>
This project was born out of a personal need: to convert Telegram chats into a text format for analysis with AI models. What started as a simple script was transformed into a full-featured GUI application in just one week.

Mid-late August 2025:
The initial development was conducted entirely with Google's Gemini. We started with the intention of building the application on a Model-View-Presenter (MVP) architecture. However, as development progressed rapidly, I failed to strictly enforce the pattern. We quickly turned the "Model-View-Presenter" into a "Minimum-Viable-Product" with spaghetti code. I realized this about 80% of the way through (on day 4 or 5) when I started fighting race conditions that made adding the final features impossible.

A full-scale refactoring was necessary. Gemini analyzed the entire project context and proposed a solid, high-level plan for rebuilding it. The plan was then executed using CursorAI with the Sonnet 4 Thinking model. In a single night, about 80% of the application was refactored into a clean, dependency-injected MVP architecture.

For the final 20%—plus a few features adapted from my previous project, Improve-ImgSLI—I returned to Gemini. While Sonnet 4 is brilliant for executing large, well-defined tasks almost autonomously, it's less cost-effective for the meticulous process of debugging subtle issues. The final 2-3 days were an exhausting but necessary process of chasing down very elusive, often single-line bugs hidden within the new, clean architecture. It was a tedious process of analyzing loggers to find the root cause.

Ultimately, the application was ready after about a week. This process also resulted in the creation of a reusable Fluent Design UI toolkit, which will significantly speed up future projects. Furthermore, it was a valuable experience in integrating AI components into desktop software. Now, only distribution remains.

About name: Tkonverter - Telegram + (Kool)converter. KDE vibes.
</details>

---

## ⭐ Star History

![Star History Chart](https://api.star-history.com/svg?repos=Loganavter/Tkonverter&type=Timeline)


--- Файл: ./src/core/__init__.py ---



--- Файл: ./src/core/analysis/tree_analyzer.py ---
import logging
from datetime import datetime

from core.conversion.context import ConversionContext
from resources.translations import tr

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

AGGREGATION_THRESHOLD_PERCENT = 7.5
BASE_MAX_CHILDREN = 35
MIN_VISIBLE_CHILDREN = 5
ROOT_MAX_CHILDREN = 5

class TreeNode:

    def __init__(self, name, value=0.0, parent=None, date_level=None):
        self.name = name
        self.value = float(value)
        self.parent = parent
        self.children = []
        self.aggregated_children = []

        self.date_level = date_level

    def add_child(self, node):
        self.children.append(node)
        node.parent = self

def aggregate_children_for_view(
    node: TreeNode, force_full_detail: bool = False
) -> list[TreeNode]:

    if node.date_level == "others":
        logger.debug(f"Узел '{node.name}' является 'прочее', возвращаем его содержимое: {len(node.aggregated_children)} узлов")
        return sorted(node.aggregated_children, key=lambda n: n.value, reverse=True)

    logger.debug(f"Агрегация для узла '{node.name}' (значение: {node.value:.2f}, уровень: {getattr(node, 'date_level', 'unknown')})")

    if not node.children or node.value == 0:
        logger.debug(f"Узел '{node.name}' не имеет детей или нулевое значение.")
        return node.children

    if force_full_detail:
        logger.debug(f"Принудительная полная детализация для узла '{node.name}'.")
        return sorted(node.children, key=lambda n: n.value, reverse=True)

    if not node.parent:

        dynamic_max_children = ROOT_MAX_CHILDREN
    else:

        share = node.value / node.parent.value if node.parent.value > 0 else 0
        dynamic_max_children = int(
            MIN_VISIBLE_CHILDREN + (BASE_MAX_CHILDREN - MIN_VISIBLE_CHILDREN) * share
        )

    children_sorted = sorted(node.children, key=lambda n: n.value, reverse=True)

    logger.debug(f"Параметры агрегации для '{node.name}': max_children={dynamic_max_children}, всего детей={len(children_sorted)}")

    if len(children_sorted) <= dynamic_max_children:
        logger.debug(f"Количество детей ({len(children_sorted)}) не превышает лимит ({dynamic_max_children}), показываем всех.")
        return children_sorted

    if len(children_sorted) == dynamic_max_children + 1:
        logger.debug(f"Количество детей ({len(children_sorted)}) лишь немного превышает лимит ({dynamic_max_children}), показываем всех, чтобы избежать '(1 прочее)'.")
        return children_sorted

    num_to_show = dynamic_max_children - 1
    visible_nodes = children_sorted[:num_to_show]
    nodes_to_aggregate = children_sorted[num_to_show:]

    aggregated_value = sum(n.value for n in nodes_to_aggregate)

    if aggregated_value > 0:
        others_name = tr('{count} others').format(count=len(nodes_to_aggregate))
        others_node = TreeNode(others_name, aggregated_value, parent=node, date_level="others")
        others_node.aggregated_children = nodes_to_aggregate

        logger.info(f"СОЗДАН УЗЕЛ 'ПРОЧЕЕ' для '{node.name}': '{others_name}' (содержит {len(nodes_to_aggregate)} узлов)")

        return visible_nodes + [others_node]
    else:

        logger.warning(f"УЗЕЛ 'ПРОЧЕЕ' НЕ СОЗДАН для '{node.name}': агрегируемые узлы имеют нулевое значение.")
        return visible_nodes

class TokenAnalyzer:
    def __init__(self, date_hierarchy: dict, config: dict, unit: str):
        self.date_hierarchy = date_hierarchy
        self.context = ConversionContext(config=config)
        self.unit = unit

    def build_analysis_tree(self, total_count: int) -> TreeNode:
        import time

        start_time = time.time()
        date_hierarchy = self.date_hierarchy

        years_count = len(date_hierarchy)
        months_count = sum(len(months) for months in date_hierarchy.values())
        days_count = sum(
            len(days) for months in date_hierarchy.values() for days in months.values()
        )

        for year, months in date_hierarchy.items():
            year_value = sum(sum(d.values()) for d in months.values())
            year_tokens = int(year_value)
            year_percent = (year_value / total_count) * 100 if total_count > 0 else 0

            for month, days in months.items():
                month_value = sum(days.values())
                month_tokens = int(month_value)
                month_percent = (
                    (month_value / year_value) * 100 if year_value > 0 else 0
                )

                for day, value in days.items():
                    day_tokens = int(value)
                    day_percent = (value / month_value) * 100 if month_value > 0 else 0

        root = TreeNode("Total", float(total_count), date_level="root")

        for year, months in date_hierarchy.items():
            year_value = sum(sum(d.values()) for d in months.values())
            year_node = TreeNode(str(year), float(year_value), parent=root, date_level="year")
            root.add_child(year_node)

            for month, days in months.items():
                month_value = sum(days.values())

                month_name = f"{int(month):02d}"
                month_node = TreeNode(month_name, float(month_value), parent=year_node, date_level="month")
                year_node.add_child(month_node)

                for day, value in days.items():
                    day_node = TreeNode(str(day), float(value), parent=month_node, date_level="day")
                    month_node.add_child(day_node)

        execution_time = time.time() - start_time
        return root


--- Файл: ./src/core/settings.py ---
import logging
import os
from pathlib import Path

from PyQt6.QtCore import QLocale, QSettings

def setup_logging():
    """Setup logging for the application."""

    root_logger = logging.getLogger()
    root_logger.setLevel(logging.WARNING)

    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)

    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.WARNING)
    console_handler.setFormatter(formatter)

    root_logger.addHandler(console_handler)

settings_logger = logging.getLogger("Settings")
settings_logger.setLevel(logging.WARNING)

class SettingsManager:
    def __init__(self, organization_name: str, application_name: str):
        self.settings = QSettings(organization_name, application_name)

    def load_theme(self) -> str:
        theme = self.settings.value("theme", "auto", type=str)
        return theme

    def save_theme(self, theme: str):
        self.settings.setValue("theme", theme)
        self.settings.sync()

    def load_language(self) -> str:
        """
        Loads the saved language. If not set, autodetects the system language.
        """

        saved_lang = self.settings.value("language", None, type=str)
        if saved_lang in ["en", "ru"]:
            return saved_lang

        try:
            system_locale = QLocale.system().name()
            lang_code = system_locale.split('_')[0].lower()

            if lang_code in ["en", "ru"]:
                return lang_code
        except Exception as e:
            settings_logger.warning(f"Could not autodetect system language: {e}")

        return "ru"

    def save_language(self, lang_code: str):
        self.settings.setValue("language", lang_code)
        self.settings.sync()

    def load_debug_mode(self) -> bool:
        """Loads permanent debug mode setting."""
        return self.settings.value("debug/enabled", False, type=bool)

    def save_debug_mode(self, enabled: bool):
        """Saves permanent debug mode setting."""
        self.settings.setValue("debug/enabled", enabled)
        self.settings.sync()

    def load_export_settings(self) -> dict:
        return {
            "use_default_dir": self.settings.value(
                "export_use_default_dir", True, type=bool
            ),
            "default_dir": self.settings.value("export_default_dir", "", type=str),
            "favorite_dir": self.settings.value("export_favorite_dir", "", type=str),
        }

    def load_ui_settings(self) -> dict:
        settings = {
            "profile": self.settings.value("ui/profile", "group", type=str),
            "auto_detect_profile": self.settings.value("ui/auto_detect_profile", True, type=bool),
            "auto_recalc": self.settings.value("ui/auto_recalc", False, type=bool),
            "show_time": self.settings.value("ui/show_time", True, type=bool),
            "show_reactions": self.settings.value("ui/show_reactions", True, type=bool),
            "show_reaction_authors": self.settings.value(
                "ui/show_reaction_authors", False, type=bool
            ),
            "my_name": self.settings.value("ui/my_name", "", type=str),
            "partner_name": self.settings.value("ui/partner_name", "", type=str),
            "show_optimization": self.settings.value(
                "ui/show_optimization", False, type=bool
            ),
            "streak_break_time": self.settings.value(
                "ui/streak_break_time", "20:00", type=str
            ),
            "show_markdown": self.settings.value("ui/show_markdown", True, type=bool),
            "show_links": self.settings.value("ui/show_links", True, type=bool),
            "show_tech_info": self.settings.value("ui/show_tech_info", True, type=bool),
            "show_service_notifications": self.settings.value(
                "ui/show_service_notifications", True, type=bool
            ),
            "truncate_name_length": self.settings.value(
                "ui/truncate_name_length", 20, type=int
            ),
            "truncate_quote_length": self.settings.value(
                "ui/truncate_quote_length", 50, type=int
            ),
        }
        return settings

    def save_ui_settings(self, config: dict):
        self.settings.setValue("ui/profile", config.get("profile", "group"))
        self.settings.setValue("ui/auto_detect_profile", config.get("auto_detect_profile", True))
        self.settings.setValue("ui/auto_recalc", config.get("auto_recalc", False))
        self.settings.setValue("ui/show_time", config.get("show_time", True))
        self.settings.setValue("ui/show_reactions", config.get("show_reactions", True))
        self.settings.setValue(
            "ui/show_reaction_authors", config.get("show_reaction_authors", False)
        )
        self.settings.setValue("ui/my_name", config.get("my_name", ""))
        self.settings.setValue("ui/partner_name", config.get("partner_name", ""))
        self.settings.setValue(
            "ui/show_optimization", config.get("show_optimization", False)
        )
        self.settings.setValue(
            "ui/streak_break_time", config.get("streak_break_time", "20:00")
        )
        self.settings.setValue("ui/show_markdown", config.get("show_markdown", True))
        self.settings.setValue("ui/show_links", config.get("show_links", True))
        self.settings.setValue("ui/show_tech_info", config.get("show_tech_info", True))
        self.settings.setValue(
            "ui/show_service_notifications",
            config.get("show_service_notifications", True),
        )
        self.settings.setValue(
            "ui/truncate_name_length", config.get("truncate_name_length", 20)
        )
        self.settings.setValue(
            "ui/truncate_quote_length", config.get("truncate_quote_length", 50)
        )
        self.settings.sync()

    def load_ai_settings(self) -> dict:
        return {
            "load_on_startup": self.settings.value(
                "ai/load_on_startup", False, type=bool
            ),
            "tokenizer_model": self.settings.value(
                "ai/tokenizer_model", "google/gemma-2b", type=str
            ),
        }

    def save_ai_settings(self, config: dict):
        self.settings.setValue(
            "ai/load_on_startup", config.get("load_on_startup", False)
        )
        self.settings.setValue(
            "ai/tokenizer_model", config.get("tokenizer_model", "google/gemma-2b")
        )
        self.settings.sync()

    def get_default_tokenizer_model(self) -> str:
        return "google/gemma-2b"

    def load_ui_font_mode(self) -> str:
        """Load UI font mode."""
        return self.settings.value("ui/font_mode", "builtin", type=str)

    def save_ui_font_mode(self, mode: str):
        """Save UI font mode."""
        self.settings.setValue("ui/font_mode", mode)
        self.settings.sync()

    def load_ui_font_family(self) -> str:
        """Load UI font family."""
        return self.settings.value("ui/font_family", "", type=str)

    def save_ui_font_family(self, family: str):
        """Save UI font family."""
        self.settings.setValue("ui/font_family", family)
        self.settings.sync()

    def save_ui_font_settings(self, mode: str, family: str = ""):
        """Save UI font settings."""
        self.save_ui_font_mode(mode)
        self.save_ui_font_family(family)


--- Файл: ./src/core/view_models.py ---
"""
ViewModels for charts and calendar.

These classes contain only data for display in UI,
without any business logic.
"""

import math
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set

from PyQt6.QtCore import QDate

from core.analysis.tree_analyzer import TreeNode

@dataclass
class CalendarDayInfo:
    """Information about a day in calendar."""
    date: QDate
    message_count: str
    is_available: bool
    is_disabled: bool
    is_selected: bool
    is_in_current_month: bool

@dataclass
class CalendarMonthInfo:
    """Information about a month or year in calendar."""
    year: int
    month: int
    name: str
    message_count: str
    days: List[CalendarDayInfo]
    is_current: bool

    is_available: bool
    is_disabled: bool

@dataclass
class CalendarViewModel:
    """ViewModel for calendar dialog."""
    current_year: int
    current_month: int
    current_day: int

    view_mode: str = "days"

    days_in_current_month: List[CalendarDayInfo] = field(default_factory=list)
    months_in_current_year: List[CalendarMonthInfo] = field(default_factory=list)

    available_years: List[CalendarMonthInfo] = field(default_factory=list)

    can_go_previous: bool = True
    can_go_next: bool = True
    navigation_title: str = ""

    total_available_dates: int = 0
    total_disabled_dates: int = 0
    selected_dates_count: int = 0

    disabled_dates: Set[QDate] = field(default_factory=set)

    def get_current_date(self) -> QDate:
        return QDate(self.current_year, self.current_month, self.current_day)

    def is_date_disabled(self, date: QDate) -> bool:
        return date in self.disabled_dates

@dataclass
class SunburstSegment:
    """Segment of circular chart (sunburst)."""

    inner_radius: float
    outer_radius: float
    start_angle: float
    end_angle: float
    color: str
    node: TreeNode
    text: str
    text_position: Optional[tuple[float, float]] = None
    is_hovered: bool = False
    is_selected: bool = False
    is_disabled: bool = False

@dataclass
class ChartInteractionInfo:
    """Information about chart interaction."""

    hovered_segment: Optional[SunburstSegment] = None
    selected_segments: Set[SunburstSegment] = field(default_factory=set)
    tooltip_text: str = ""
    tooltip_position: Optional[tuple[float, float]] = None

    cursor_type: str = "default"

@dataclass
class ChartViewModel:
    """ViewModel for analysis chart."""

    segments: List[SunburstSegment] = field(default_factory=list)
    center_text: str = ""
    center_value: float = 0.0
    unit: str = "chars"
    chart_width: int = 400
    chart_height: int = 400
    center_x: float = 200.0
    center_y: float = 200.0
    color_scheme: str = "default"
    disabled_nodes: Set[TreeNode] = field(default_factory=set)
    filtered_value: float = 0.0
    total_value: float = 0.0
    geometry: Optional[Any] = None
    interaction_info: ChartInteractionInfo = field(default_factory=ChartInteractionInfo)

    def get_segment_at_position(self, x: float, y: float) -> Optional[SunburstSegment]:
        """Returns the segment at the specified position."""
        for segment in self.segments:
            if self._is_point_in_segment(segment, x, y):
                return segment
        return None

    def _is_point_in_segment(self, segment: SunburstSegment, x: float, y: float) -> bool:
        """Checks if a point is within a segment."""

        distance = (x ** 2 + y ** 2) ** 0.5
        if not (segment.inner_radius <= distance <= segment.outer_radius):
            return False

        angle = math.atan2(y, x)
        if angle < 0:
            angle += 2 * math.pi

        return segment.start_angle <= angle <= segment.end_angle

    def get_hovered_segment(self) -> Optional[SunburstSegment]:
        """Returns the current hovered segment."""
        return self.interaction_info.hovered_segment

    def set_hovered_segment(self, segment: Optional[SunburstSegment]):
        """Sets the hovered segment."""
        if self.interaction_info.hovered_segment != segment:
            self.interaction_info.hovered_segment = segment
            if segment:
                self.interaction_info.tooltip_text = f"{segment.text}: {segment.node.value:,.0f}"
            else:
                self.interaction_info.tooltip_text = ""

    def get_tooltip_text(self) -> str:
        """Returns text for tooltip."""
        return self.interaction_info.tooltip_text

    def get_cursor_type(self) -> str:
        """Returns cursor type."""
        return self.interaction_info.cursor_type

    def set_cursor_type(self, cursor_type: str):
        """Sets cursor type."""
        self.interaction_info.cursor_type = cursor_type

    def get_disabled_nodes(self) -> Set[TreeNode]:
        """Returns disabled nodes."""
        return {segment.node for segment in self.segments if segment.is_disabled}

    def set_disabled_nodes(self, disabled_nodes: Set[TreeNode]):
        """Sets disabled nodes."""
        for segment in self.segments:
            segment.is_disabled = segment.node in disabled_nodes

    def get_filtered_value(self) -> float:
        """Returns filtered value."""
        return sum(segment.node.value for segment in self.segments if not segment.is_disabled)

    def update_segment_colors(self, color_scheme: str = "default"):
        """Updates segment colors."""

        pass

    def get_segment_by_node(self, node: TreeNode) -> Optional[SunburstSegment]:
        """Returns segment by node."""
        for segment in self.segments:
            if segment.node == node:
                return segment
        return None

    def add_segment(self, segment: SunburstSegment):
        """Adds a segment."""
        self.segments.append(segment)

    def clear_segments(self):
        """Clears all segments."""
        self.segments.clear()

    def get_segments_count(self) -> int:
        """Returns the number of segments."""
        return len(self.segments)

    def is_empty(self) -> bool:
        """Checks if the chart is empty."""
        return len(self.segments) == 0

    def get_bounds(self) -> tuple[float, float, float, float]:
        """Returns the bounds of the chart."""
        if not self.segments:
            return (0, 0, 0, 0)

        min_x = min(segment.inner_radius for segment in self.segments)
        max_x = max(segment.outer_radius for segment in self.segments)
        min_y = min(segment.inner_radius for segment in self.segments)
        max_y = max(segment.outer_radius for segment in self.segments)

        return (min_x, min_y, max_x, max_y)


--- Файл: ./src/core/domain/__init__.py ---



--- Файл: ./src/core/domain/models.py ---
"""
Domain models for TKonverter.

These models represent core business entities and do not depend on PyQt or other frameworks.
They contain only data and simple validation logic.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional, Union

@dataclass
class TodoListItem:
    """An item in a to-do list."""
    text: Union[str, List[Dict[str, Any]]]
    id: int

@dataclass
class TodoList:
    """A to-do list in a message."""
    title: Union[str, List[Dict[str, Any]]]
    items: List[TodoListItem] = field(default_factory=list)

@dataclass
class PaidMedia:
    """Information about paid media."""
    paid_stars_amount: int

@dataclass
class GiveawayInfo:
    """Giveaway start information."""
    quantity: int
    months: int
    until_date: datetime
    channels: List[int] = field(default_factory=list)
    countries: List[str] = field(default_factory=list)
    additional_prize: Optional[str] = None

@dataclass
class GiveawayResultsInfo:
    """Giveaway results information."""
    winners_count: int
    unclaimed_count: int
    months: int
    launch_message_id: int

@dataclass
class User:
    """Chat user."""

    id: str
    name: str

    def __post_init__(self):
        if not self.id:
            raise ValueError("User ID cannot be empty")
        if not self.name:
            raise ValueError("User name cannot be empty")

@dataclass
class Reaction:
    """Message reaction."""

    emoji: str
    count: int
    authors: List[User] = field(default_factory=list)

    def __post_init__(self):
        if self.count < 0:
            raise ValueError("Reaction count cannot be negative")

@dataclass
class MediaInfo:
    """Media content information."""

    media_type: Optional[str] = None
    file_name: Optional[str] = None
    file_size: Optional[int] = None
    duration_seconds: Optional[int] = None
    sticker_emoji: Optional[str] = None
    width: Optional[int] = None
    height: Optional[int] = None

@dataclass
class Message:
    """Chat message."""

    id: int
    author: User
    date: datetime
    text: Union[str, List[Dict[str, Any]]]
    reactions: List[Reaction] = field(default_factory=list)
    reply_to_id: Optional[int] = None
    edited: Optional[datetime] = None
    media: Optional[MediaInfo] = None
    forwarded_from: Optional[str] = None
    raw_media: Optional[Dict[str, Any]] = field(default_factory=dict)
    media_spoiler: bool = False
    giveaway_info: Optional[GiveawayInfo] = None
    giveaway_results_info: Optional[GiveawayResultsInfo] = None
    showForwardedAsOriginal: bool = False
    todo_list: Optional[TodoList] = None
    paid_media: Optional[PaidMedia] = None
    raw_inline_buttons: Optional[List[Any]] = field(default_factory=list)

    def __post_init__(self):
        pass

    @property
    def is_edited(self) -> bool:
        """Checks if message was edited."""
        return self.edited is not None

    @property
    def has_media(self) -> bool:
        """Checks if message contains media."""
        return self.media is not None

    @property
    def has_reactions(self) -> bool:
        """Checks if message has reactions."""
        return len(self.reactions) > 0

@dataclass
class ServiceMessage:
    """Service message (chat action)."""

    id: int
    date: datetime
    action: str
    actor: Optional[str] = None
    title: Optional[str] = None
    members: List[str] = field(default_factory=list)
    period_seconds: Optional[int] = None
    media: Optional[MediaInfo] = None

    def __post_init__(self):

        if not self.action:
            raise ValueError("Service message action cannot be empty")

@dataclass
class Chat:
    """Chat (group, personal correspondence, channel)."""

    name: str
    type: str
    messages: List[Union[Message, ServiceMessage]]

    def __post_init__(self):
        if not self.name:
            raise ValueError("Chat name cannot be empty")
        if self.type not in ["group", "personal", "posts", "channel"]:
            raise ValueError(f"Unknown chat type: {self.type}")

    @property
    def message_count(self) -> int:
        """Returns count of regular messages (without service ones)."""
        return sum(1 for msg in self.messages if isinstance(msg, Message))

    @property
    def service_message_count(self) -> int:
        """Returns count of service messages."""
        return sum(1 for msg in self.messages if isinstance(msg, ServiceMessage))

    @property
    def total_message_count(self) -> int:
        """Returns total message count."""
        return len(self.messages)

    def get_users(self) -> List[User]:
        """Returns list of all users who participated in chat."""
        users = {}
        for msg in self.messages:
            if isinstance(msg, Message):
                users[msg.author.id] = msg.author
        return list(users.values())

    def get_messages_by_user(self, user_id: str) -> List[Message]:
        """Returns all messages from specific user."""
        return [
            msg
            for msg in self.messages
            if isinstance(msg, Message) and msg.author.id == user_id
        ]

    def get_date_range(self) -> tuple[datetime, datetime]:
        """Returns chat time range (first and last message)."""
        if not self.messages:
            raise ValueError("Chat contains no messages")

        dates = [msg.date for msg in self.messages]
        return min(dates), max(dates)

@dataclass
class AnalysisResult:
    """Chat analysis result."""

    total_count: int
    unit: str
    date_hierarchy: Dict[str, Dict[str, Dict[str, float]]]
    total_characters: Optional[int] = None
    average_message_length: Optional[float] = None
    most_active_user: Optional[User] = None
    created_at: datetime = field(default_factory=datetime.now)

    def __post_init__(self):
        if self.total_count < 0:
            raise ValueError("Total count cannot be negative")
        if self.unit not in ["chars", "Characters", "tokens"]:
            raise ValueError(f"Unknown unit: {self.unit}")


--- Файл: ./src/core/parsing/__init__.py ---



--- Файл: ./src/core/parsing/json_parser.py ---
"""
JSON parser for converting Telegram data to domain models.

This module is responsible for parsing Telegram export JSON files
and creating type-safe domain objects.
"""

import logging
from datetime import datetime
from typing import Any, Dict, List, Optional, Union

from core.domain.models import (
    Chat,
    GiveawayInfo,
    GiveawayResultsInfo,
    MediaInfo,
    Message,
    PaidMedia,
    Reaction,
    ServiceMessage,
    TodoList,
    TodoListItem,
    User,
)

logger = logging.getLogger(__name__)

def parse_user_from_dict(user_data: Dict[str, Any]) -> User:
    """Creates User object from dictionary."""
    return User(
        id=str(user_data.get("from_id", "")), name=str(user_data.get("from", ""))
    )

def parse_reaction_from_dict(reaction_data: Dict[str, Any]) -> Reaction:
    """Creates Reaction object from dictionary."""
    authors = []
    for author_data in reaction_data.get("recent", []):
        try:
            author = User(
                id=str(author_data.get("from_id", "")),
                name=str(author_data.get("from", "")),
            )
            authors.append(author)
        except ValueError as e:
            logger.warning(f"Error parsing reaction author: {e}")
            continue

    emoji_text = ""

    if reaction_data.get("type") == "custom_emoji":

        from resources.translations import tr
        emoji_text = f"{tr('Custom')} {tr('Emoji')}"
    else:

        emoji_text = reaction_data.get("emoji", "")

    return Reaction(
        emoji=emoji_text,
        count=reaction_data.get("count", 0),
        authors=authors,
    )

def parse_media_from_dict(msg_data: Dict[str, Any]) -> Optional[MediaInfo]:
    """Creates MediaInfo object from message data."""

    if "photo" in msg_data:
        return MediaInfo(
            media_type="photo",
            file_name=msg_data.get("photo"),
            file_size=msg_data.get("photo_file_size"),
            width=msg_data.get("width"),
            height=msg_data.get("height"),
        )

    media_type = msg_data.get("media_type")
    if not media_type and not msg_data.get("file") and not msg_data.get("photo"):
        return None

    return MediaInfo(
        media_type=media_type,
        file_name=msg_data.get("file_name") or msg_data.get("file"),
        file_size=msg_data.get("file_size"),
        duration_seconds=msg_data.get("duration_seconds"),
        sticker_emoji=msg_data.get("sticker_emoji"),
        width=msg_data.get("width"),
        height=msg_data.get("height"),
    )

def parse_date_string(date_str: str) -> datetime:
    """Parses date string to datetime object."""
    try:
        return datetime.fromisoformat(date_str)
    except ValueError:

        try:
            return datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%S")
        except ValueError:
            logger.warning(f"Failed to parse date: {date_str}")
            return datetime.now()

def parse_todo_list_from_dict(todo_data: Dict[str, Any]) -> TodoList:
    """Creates TodoList object from dictionary."""
    items = []
    for item_data in todo_data.get("items", []):
        items.append(
            TodoListItem(
                id=item_data.get("id", 0),
                text=item_data.get("text", "")
            )
        )
    return TodoList(
        title=todo_data.get("title", ""),
        items=items
    )

def parse_paid_media_from_dict(msg_data: Dict[str, Any]) -> PaidMedia:
    """Creates PaidMedia object from dictionary."""
    return PaidMedia(
        paid_stars_amount=msg_data.get("paid_stars_amount", 0)
    )

def parse_message_from_dict(msg_data: Dict[str, Any]) -> Message:
    """Creates Message object from dictionary."""

    author = User(
        id=str(msg_data.get("from_id", "")), name=str(msg_data.get("from", ""))
    )

    date = parse_date_string(msg_data.get("date", ""))

    edited = None
    if "edited" in msg_data:
        edited = parse_date_string(msg_data["edited"])

    reactions = []
    for reaction_data in msg_data.get("reactions", []):
        try:
            reaction = parse_reaction_from_dict(reaction_data)
            reactions.append(reaction)
        except (ValueError, KeyError) as e:
            logger.warning(f"Error parsing reaction: {e}")
            continue

    media = parse_media_from_dict(msg_data)

    raw_media_fields = {}
    for key in [
        "poll",
        "contact_information",
        "location_information",
        "venue",
        "dice",
        "game_information",
        "invoice_information",
        "place_name",
        "address",
    ]:
        if key in msg_data:
            raw_media_fields[key] = msg_data[key]

    giveaway_info = None
    if gi_data := msg_data.get("giveaway_information"):
        giveaway_info = GiveawayInfo(
            quantity=gi_data.get("quantity", 0),
            months=gi_data.get("months", 0),
            until_date=parse_date_string(gi_data.get("until_date", "")),
            channels=gi_data.get("channels", []),
            countries=gi_data.get("countries", []),
            additional_prize=gi_data.get("additional_prize"),
        )

    giveaway_results_info = None
    if gr_data := msg_data.get("giveaway_results"):
        giveaway_results_info = GiveawayResultsInfo(
            winners_count=gr_data.get("winners_count", 0),
            unclaimed_count=gr_data.get("unclaimed_count", 0),
            months=gr_data.get("months", 0),
            launch_message_id=gr_data.get("launch_message_id", 0),
        )

    todo_list = None
    if todo_data := msg_data.get("todo_list"):
        todo_list = parse_todo_list_from_dict(todo_data)

    paid_media = None
    if "paid_stars_amount" in msg_data:
        paid_media = parse_paid_media_from_dict(msg_data)

    return Message(
        id=msg_data.get("id", 0),
        author=author,
        date=date,
        text=msg_data.get("text", ""),
        reactions=reactions,
        reply_to_id=msg_data.get("reply_to_message_id"),
        edited=edited,
        media=media,
        forwarded_from=msg_data.get("forwarded_from"),
        raw_media=raw_media_fields,
        media_spoiler=msg_data.get("media_spoiler", False),
        giveaway_info=giveaway_info,
        giveaway_results_info=giveaway_results_info,
        showForwardedAsOriginal=msg_data.get("showForwardedAsOriginal", False),
        todo_list=todo_list,
        paid_media=paid_media,
        raw_inline_buttons=msg_data.get("inline_bot_buttons"),
    )

def parse_service_message_from_dict(msg_data: Dict[str, Any]) -> ServiceMessage:
    """Creates ServiceMessage object from dictionary."""
    media = None

    if msg_data.get("action") == "suggest_profile_photo" and "photo" in msg_data:
        media = parse_media_from_dict(msg_data)

    return ServiceMessage(
        id=msg_data.get("id", 0),
        date=parse_date_string(msg_data.get("date", "")),
        action=msg_data.get("action", ""),
        actor=msg_data.get("actor"),
        title=msg_data.get("title"),
        members=msg_data.get("members", []),
        period_seconds=msg_data.get("period_seconds"),
        media=media,
    )

def parse_chat_from_dict(data: Dict[str, Any]) -> Chat:
    """
    Main parsing function - converts JSON dictionary to Chat object.

    Args:
        data: Dictionary with chat data from Telegram JSON file

    Returns:
        Chat: Domain chat object

    Raises:
        ValueError: If data is incorrect
        KeyError: If required fields are missing
    """
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")

    if "messages" not in data:
        raise KeyError("Missing 'messages' field")

    messages: List[Union[Message, ServiceMessage]] = []

    for i, msg_data in enumerate(data["messages"]):
        try:
            if not isinstance(msg_data, dict):
                logger.warning(f"Message {i} is not a dictionary, skipping")
                continue

            msg_type = msg_data.get("type", "message")

            if msg_type == "message":
                message = parse_message_from_dict(msg_data)
                messages.append(message)
            elif msg_type == "service":
                service_message = parse_service_message_from_dict(msg_data)
                messages.append(service_message)
            else:
                logger.warning(f"Unknown message type: {msg_type}")
                continue

        except (ValueError, KeyError) as e:
            logger.warning(f"Error parsing message {i}: {e}")
            continue

    chat_type = _detect_chat_type(data, messages)

    return Chat(
        name=data.get("name", "Unnamed Chat"), type=chat_type, messages=messages
    )

def _detect_chat_type(
    data: Dict[str, Any], messages: List[Union[Message, ServiceMessage]]
) -> str:
    """
    Automatically detects chat type based on message analysis.

    Args:
        data: Original chat data
        messages: List of parsed messages

    Returns:
        str: Chat type ('group', 'personal', 'posts', 'channel')
    """
    if not messages:
        return "group"

    author_ids = set()
    first_message = None

    for msg in messages:
        if isinstance(msg, Message):
            if first_message is None:
                first_message = msg
            author_ids.add(msg.author.id)

    num_authors = len(author_ids)

    if num_authors == 2:
        return "personal"
    elif num_authors > 2:
        return "group"
    elif num_authors == 1 and first_message and first_message.forwarded_from:
        return "posts"
    elif num_authors == 1:
        return "channel"
    else:
        return "group"

def validate_chat_data(data: Dict[str, Any]) -> List[str]:
    """
    Validates chat data and returns list of found issues.

    Args:
        data: Chat data for validation

    Returns:
        List[str]: List of found issue descriptions
    """
    issues = []

    if not isinstance(data, dict):
        issues.append("Data is not a dictionary")
        return issues

    if "messages" not in data:
        issues.append("Missing 'messages' field")
    elif not isinstance(data["messages"], list):
        issues.append("'messages' field is not a list")

    if "name" not in data:
        issues.append("Missing chat name")

    return issues

def get_parsing_statistics(data: Dict[str, Any]) -> Dict[str, int]:
    """
    Returns parsing statistics without actually creating objects.

    Args:
        data: Chat data

    Returns:
        Dict[str, int]: Statistics (message count, service messages, etc.)
    """
    stats = {
        "total_messages": 0,
        "regular_messages": 0,
        "service_messages": 0,
        "messages_with_media": 0,
        "messages_with_reactions": 0,
        "unique_authors": 0,
    }

    if not isinstance(data, dict) or "messages" not in data:
        return stats

    authors = set()

    for msg_data in data.get("messages", []):
        if not isinstance(msg_data, dict):
            continue

        stats["total_messages"] += 1

        msg_type = msg_data.get("type", "message")
        if msg_type == "message":
            stats["regular_messages"] += 1

            if msg_data.get("from_id"):
                authors.add(msg_data["from_id"])

            if msg_data.get("media_type"):
                stats["messages_with_media"] += 1

            if msg_data.get("reactions"):
                stats["messages_with_reactions"] += 1

        elif msg_type == "service":
            stats["service_messages"] += 1

    stats["unique_authors"] = len(authors)
    return stats


--- Файл: ./src/core/conversion/domain_adapters.py ---
"""
Adapters for converting domain objects to format understandable by existing formatters.

This module provides backward compatibility between new domain models
and existing formatters that expect dictionaries.
"""

from typing import Any, Dict
from dataclasses import asdict
from core.domain.models import Chat, MediaInfo, Message, Reaction, ServiceMessage, User

def user_to_dict(user: User) -> Dict[str, str]:
    """Converts User to dictionary."""
    return {"from_id": user.id, "from": user.name}

def reaction_to_dict(reaction: Reaction) -> Dict[str, Any]:
    """Converts Reaction to dictionary."""
    return {
        "emoji": reaction.emoji,
        "count": reaction.count,
        "recent": [user_to_dict(author) for author in reaction.authors],
    }

def media_to_dict_fields(media: MediaInfo) -> Dict[str, Any]:
    """Converts MediaInfo to message dictionary fields."""
    fields = {}

    if media.media_type:
        fields["media_type"] = media.media_type
    if media.file_name:
        fields["file"] = media.file_name
        fields["file_name"] = media.file_name
    if media.file_size is not None:
        fields["file_size"] = media.file_size
    if media.duration_seconds is not None:
        fields["duration_seconds"] = media.duration_seconds
    if media.sticker_emoji:
        fields["sticker_emoji"] = media.sticker_emoji
    if media.width is not None:
        fields["width"] = media.width
    if media.height is not None:
        fields["height"] = media.height

    return fields

def message_to_dict(message: Message) -> Dict[str, Any]:
    """Converts Message to dictionary format for formatters."""
    msg_dict = {
        "id": message.id,
        "type": "message",
        "from_id": message.author.id,
        "from": message.author.name,
        "date": message.date.isoformat(),
        "text": message.text,
    }

    if message.reply_to_id is not None:
        msg_dict["reply_to_message_id"] = message.reply_to_id

    if message.edited:
        msg_dict["edited"] = message.edited.isoformat()

    if message.showForwardedAsOriginal:
        msg_dict["showForwardedAsOriginal"] = True

    if message.forwarded_from:
        msg_dict["forwarded_from"] = message.forwarded_from

    if message.reactions:
        msg_dict["reactions"] = [reaction_to_dict(r) for r in message.reactions]

    if message.media:
        msg_dict.update(media_to_dict_fields(message.media))

    if message.media_spoiler:
        msg_dict["media_spoiler"] = True

    if message.giveaway_info:
        from dataclasses import asdict
        msg_dict["giveaway_information"] = asdict(message.giveaway_info)
    if message.giveaway_results_info:
        from dataclasses import asdict
        msg_dict["giveaway_results_information"] = asdict(message.giveaway_results_info)

    if message.raw_inline_buttons:
        msg_dict["inline_bot_buttons"] = message.raw_inline_buttons

    if message.raw_media:
        msg_dict.update(message.raw_media)

    return msg_dict

def service_message_to_dict(service_msg: ServiceMessage) -> Dict[str, Any]:
    """Converts ServiceMessage to dictionary format for formatters."""
    msg_dict = {
        "id": service_msg.id,
        "type": "service",
        "date": service_msg.date.isoformat(),
        "action": service_msg.action,
    }

    full_dict = asdict(service_msg)
    for key, value in full_dict.items():
        if key not in msg_dict and value is not None:
            if isinstance(value, list) and not value:
                continue
            msg_dict[key] = value

    if service_msg.media:
        msg_dict.update(media_to_dict_fields(service_msg.media))

    return msg_dict

def chat_to_dict(chat: Chat) -> Dict[str, Any]:
    """Converts Chat to dictionary format for existing components."""

    messages_dicts = []
    for msg in chat.messages:
        if isinstance(msg, Message):
            messages_dicts.append(message_to_dict(msg))
        elif isinstance(msg, ServiceMessage):
            messages_dicts.append(service_message_to_dict(msg))

    return {"name": chat.name, "type": chat.type, "messages": messages_dicts}

def create_message_map(chat: Chat) -> Dict[int, Dict[str, Any]]:
    """
    Creates message map for fast lookup by ID.

    Returns dictionary where keys are message IDs, values are message dictionaries.
    This is needed for reply functionality.
    """
    message_map = {}

    for msg in chat.messages:
        if isinstance(msg, Message):
            message_map[msg.id] = message_to_dict(msg)
        elif isinstance(msg, ServiceMessage):
            message_map[msg.id] = service_message_to_dict(msg)

    return message_map

def get_main_post_id(chat: Chat) -> int | None:
    """
    Finds main post ID in 'posts' type chat.

    In 'posts' type chats, usually the first message is the main post,
    and the rest are comments to it.
    """
    if chat.type != "posts":
        return None

    for msg in chat.messages:
        if isinstance(msg, Message):
            return msg.id

    return None

def detect_user_ids_for_personal_chat(chat: Chat) -> tuple[str | None, str | None]:
    """
    Determines user IDs in personal chat.

    Returns tuple (my_id, partner_id), where my_id and partner_id
    can be None if impossible to determine.
    """
    if chat.type != "personal":
        return None, None

    user_ids = []
    for msg in chat.messages:
        if isinstance(msg, Message):
            if msg.author.id not in user_ids:
                user_ids.append(msg.author.id)
                if len(user_ids) >= 2:
                    break

    if len(user_ids) == 2:

        return user_ids[0], user_ids[1]

    return None, None

def get_author_name_from_message_dict(
    msg_dict: Dict[str, Any], config: Dict[str, Any]
) -> str:
    """
    Extracts author name from message with consideration of configuration settings.

    This function replicates logic from ConversionContext.get_author_name()
    for working with domain objects.
    """
    profile = config.get("profile", "group")
    author_name = msg_dict.get("from", "")
    author_id = msg_dict.get("from_id", "")

    if profile == "personal":
        my_name = config.get("my_name", "Me")
        partner_name = config.get("partner_name", "Partner")

        if "me" in author_name.lower() or "i" in author_name.lower():
            return my_name
        else:
            return partner_name

    max_len = config.get("truncate_name_length", 20)
    if author_name and len(author_name) > max_len:
        return author_name[:max_len-3] + "..."
    return author_name if author_name else f"User_{author_id}"


--- Файл: ./src/core/conversion/__init__.py ---



--- Файл: ./src/core/conversion/main_converter.py ---
from collections import Counter
from datetime import datetime
import logging

from core.conversion.context import ConversionContext
from core.conversion.formatters.service_formatter import format_service_message
from core.conversion.message_formatter import format_message
from core.conversion.utils import format_date_separator
from resources.translations import tr

logger = logging.getLogger(__name__)

def _filter_messages_by_disabled_nodes(
    messages: list, disabled_nodes: set | None = None
) -> list:
    if not disabled_nodes:
        return messages

    real_years = set()
    for msg in messages:
        try:
            msg_date_str = msg["date"][:4]
            if msg_date_str.isdigit():
                real_years.add(int(msg_date_str))
        except (KeyError, IndexError, TypeError):
            continue

    real_years = sorted(real_years) if real_years else [2024]

    disabled_date_strings = set()

    def _get_descendant_day_nodes(node) -> list:
        """Recursively gets all descendant day nodes (tree leaves)."""

        children_to_scan = []
        if hasattr(node, "children") and node.children:
            children_to_scan.extend(node.children)
        if hasattr(node, "aggregated_children") and node.aggregated_children:
            children_to_scan.extend(node.aggregated_children)

        if not children_to_scan:

            if hasattr(node, "name") and node.name.isdigit() and hasattr(node, "date_level") and node.date_level == "day":
                return [node]
            return []

        day_nodes = []
        for child in children_to_scan:
            day_nodes.extend(_get_descendant_day_nodes(child))
        return day_nodes

    def _get_date_path(node) -> tuple:
        """Gets the full path to the root for date construction."""
        path_parts = []
        current = node
        depth = 0

        while current and hasattr(current, "parent") and current.parent and depth < 10:
            if hasattr(current, "date_level") and current.date_level in ("day", "month", "year"):
                path_parts.insert(0, (current.name, current.date_level))
            current = current.parent
            depth += 1
        return path_parts

    def _generate_date_patterns_for_node(node, available_years) -> set:
        """Generates date patterns for a node of any level."""
        node_name = getattr(node, 'name', 'UNKNOWN')
        node_level = getattr(node, "date_level", None)

        date_patterns = set()
        path_info = _get_date_path(node)

        if not path_info:
            return date_patterns

        year_val = month_val = day_val = None
        for name, level in path_info:
            if level == "year" and name.isdigit():
                year_val = int(name)
            elif level == "month" and name.isdigit():
                month_val = int(name)
            elif level == "day" and name.isdigit():
                day_val = int(name)

        def generate_patterns_for_incomplete_hierarchy():
            import calendar

            real_months = set()
            real_days = set()
            for msg in messages:
                try:
                    date_parts = msg["date"][:10].split('-')
                    if len(date_parts) == 3:
                        real_months.add(int(date_parts[1]))
                        real_days.add(int(date_parts[2]))
                except (KeyError, IndexError, ValueError):
                    continue

            real_months = sorted(real_months) if real_months else list(range(1, 13))
            real_days = sorted(real_days) if real_days else list(range(1, 32))

            patterns = set()

            if node_level == "day":
                if year_val and month_val and day_val:

                    return set()
                elif month_val and day_val:

                    for year in available_years:
                        patterns.add(f"{year}-{month_val:02d}-{day_val:02d}")
                elif year_val and day_val:

                    for month in real_months:
                        patterns.add(f"{year_val}-{month:02d}-{day_val:02d}")
                elif day_val:

                    for year in available_years:
                        for month in real_months:
                            patterns.add(f"{year}-{month:02d}-{day_val:02d}")

            elif node_level == "month":
                if year_val and month_val:

                    return set()
                elif month_val:

                    for year in available_years:
                        try:
                            days_in_month = calendar.monthrange(year, month_val)[1]
                            for day in range(1, days_in_month + 1):
                                patterns.add(f"{year}-{month_val:02d}-{day:02d}")
                        except (ValueError, calendar.IllegalMonthError):
                            for day in range(1, 32):
                                patterns.add(f"{year}-{month_val:02d}-{day:02d}")
                elif year_val:

                    for month in real_months:
                        try:
                            days_in_month = calendar.monthrange(year_val, month)[1]
                            for day in range(1, days_in_month + 1):
                                patterns.add(f"{year_val}-{month:02d}-{day:02d}")
                        except (ValueError, calendar.IllegalMonthError):
                            for day in range(1, 32):
                                patterns.add(f"{year_val}-{month:02d}-{day:02d}")

            elif node_level == "year":
                if year_val:

                    return set()
                else:

                    for year in available_years:
                        for month in real_months:
                            try:
                                days_in_month = calendar.monthrange(year, month)[1]
                                for day in range(1, days_in_month + 1):
                                    patterns.add(f"{year}-{month:02d}-{day:02d}")
                            except (ValueError, calendar.IllegalMonthError):
                                for day in range(1, 32):
                                    patterns.add(f"{year}-{month:02d}-{day:02d}")

            return patterns

        is_incomplete_hierarchy = (
            (not year_val and (month_val is not None or day_val is not None)) or
            (not month_val and (year_val is not None or day_val is not None)) or
            (not day_val and node_level == "day")
        )

        if is_incomplete_hierarchy:
            incomplete_patterns = generate_patterns_for_incomplete_hierarchy()
            if incomplete_patterns:
                date_patterns.update(incomplete_patterns)

        elif node_level == "day" and year_val and month_val and day_val:

            pattern = f"{year_val}-{month_val:02d}-{day_val:02d}"
            date_patterns.add(pattern)

        elif node_level == "month" and year_val and month_val:

            import calendar
            try:
                days_in_month = calendar.monthrange(year_val, month_val)[1]
                for day in range(1, days_in_month + 1):
                    pattern = f"{year_val}-{month_val:02d}-{day:02d}"
                    date_patterns.add(pattern)
            except (ValueError, calendar.IllegalMonthError):

                for day in range(1, 32):
                    pattern = f"{year_val}-{month_val:02d}-{day:02d}"
                    date_patterns.add(pattern)

        elif node_level == "year" and year_val:

            import calendar
            pattern_count = 0
            for month in range(1, 13):
                try:
                    days_in_month = calendar.monthrange(year_val, month)[1]
                    for day in range(1, days_in_month + 1):
                        pattern = f"{year_val}-{month:02d}-{day:02d}"
                        date_patterns.add(pattern)
                        pattern_count += 1
                except (ValueError, calendar.IllegalMonthError):

                    for day in range(1, 32):
                        pattern = f"{year_val}-{month:02d}-{day:02d}"
                        date_patterns.add(pattern)
                        pattern_count += 1

        return date_patterns

    for i, node in enumerate(disabled_nodes):
        node_level = getattr(node, "date_level", None)
        node_name = getattr(node, 'name', 'UNKNOWN')

        if node_level == "day":

            patterns = _generate_date_patterns_for_node(node, real_years)
            disabled_date_strings.update(patterns)
        else:

            day_nodes = _get_descendant_day_nodes(node)

            for day_node in day_nodes:
                day_patterns = _generate_date_patterns_for_node(day_node, real_years)
                disabled_date_strings.update(day_patterns)

            patterns = _generate_date_patterns_for_node(node, real_years)
            disabled_date_strings.update(patterns)

    if not disabled_date_strings:
        return messages

    original_count = len(messages)
    filtered_messages = []

    for msg in messages:
        try:
            msg_date_str = msg["date"][:10]
            if msg_date_str not in disabled_date_strings:
                filtered_messages.append(msg)
        except (KeyError, IndexError, TypeError):

            filtered_messages.append(msg)

    return filtered_messages

def _initialize_context(data: dict, config: dict) -> ConversionContext:
    chat_name = data.get("name", tr("Unknown Chat"))
    message_map = {msg["id"]: msg for msg in data.get("messages", []) if "id" in msg}

    context = ConversionContext(
        config=config, message_map=message_map, chat_name=chat_name
    )

    if config.get("profile") == "personal":
        authors = {}
        for msg in data.get("messages", []):
            if msg.get("type") == "message" and msg.get("from") and msg.get("from_id"):
                author_id = msg["from_id"]
                if author_id not in authors:
                    authors[author_id] = msg["from"]

        partner_full_name = data.get("name", "")
        detected_partner_id = None
        for author_id, author_name in authors.items():
            if author_name == partner_full_name:
                detected_partner_id = author_id
                break

        if detected_partner_id and len(authors) == 2:
            context.partner_id = detected_partner_id
            context.partner_full_name = partner_full_name

            my_id_list = [aid for aid in authors if aid != detected_partner_id]
            if my_id_list:
                context.my_id = my_id_list[0]
                context.my_full_name = authors.get(context.my_id)
        else:

            author_counts = Counter(
                msg["from_id"]
                for msg in data.get("messages", [])
                if msg.get("type") == "message" and msg.get("from_id")
            )
            top_two = author_counts.most_common(2)
            if len(top_two) >= 1:
                context.my_id = top_two[0][0]
                context.my_full_name = authors.get(context.my_id)
            if len(top_two) >= 2:
                context.partner_id = top_two[1][0]
                context.partner_full_name = authors.get(context.partner_id)

    elif config.get("profile") == "posts":
        first_message = next(
            (msg for msg in data.get("messages", []) if msg.get("type") == "message"),
            None,
        )
        if first_message:
            channel_name = first_message.get("forwarded_from") or first_message.get(
                "from"
            )
            if channel_name:
                context.chat_name = channel_name
            context.main_post_id = first_message.get("id")

    return context

def generate_plain_text(
    data: dict, config: dict, html_mode: bool = False, disabled_nodes: set | None = None
) -> str:

    all_messages = data.get("messages", [])
    messages = _filter_messages_by_disabled_nodes(all_messages, disabled_nodes)

    filtered_data = data.copy()
    filtered_data["messages"] = messages

    context = _initialize_context(filtered_data, config)

    output_parts = []

    profile = context.config.get("profile", "group")

    if profile == "personal":
        title_text = tr("Personal correspondence")
    elif profile == "posts":
        title_text = tr("Channel")
    elif profile == "channel":
        title_text = tr("Channel")
    else:
        title_text = tr("Group chat")

    output_parts.append(f"{title_text}: {context.chat_name}\n")
    output_parts.append("========================================\n\n")

    if context.config["profile"] == "personal" and context.my_id and context.partner_id:
        my_name_cfg = context.config["my_name"]
        my_full_name = context.my_full_name or tr("Unknown")
        partner_name_cfg = context.config["partner_name"]
        partner_full_name = context.partner_full_name or tr("Unknown")

        output_parts.append(f"{tr('Participants')}:\n")
        output_parts.append(f"- {my_full_name}: {my_name_cfg}\n")
        output_parts.append(f"- {partner_full_name}: {partner_name_cfg}\n\n")

        output_parts.append(f"{tr('Reaction notation')}:\n")
        if html_mode:
            output_parts.append(f"- &gt;&gt; {tr('from')} '{my_name_cfg}'\n")
            output_parts.append(f"- &lt;&lt; {tr('from')} '{partner_name_cfg}'\n")
        else:
            output_parts.append(f"- >> {tr('from')} '{my_name_cfg}'\n")
            output_parts.append(f"- << {tr('from')} '{partner_name_cfg}'\n")
        output_parts.append("========================================\n\n")

    previous_message = None

    if messages:
        try:
            first_msg_dt = datetime.fromisoformat(messages[0]["date"])
            separator = format_date_separator(first_msg_dt)
            output_parts.append(f"{separator}\n")
        except (KeyError, ValueError) as e:
            pass

    processed_count = 0

    for i, msg in enumerate(messages):
        if previous_message:
            try:
                current_dt = datetime.fromisoformat(msg["date"])
                prev_dt = datetime.fromisoformat(previous_message["date"])

                if current_dt.date() > prev_dt.date():
                    separator = format_date_separator(current_dt)
                    output_parts.append(f"\n{separator}\n")
            except (KeyError, ValueError) as e:
                pass

        msg_type = msg.get("type")
        formatted_text = None

        if msg_type == "service":
            formatted_text = format_service_message(msg, context)

        elif msg_type == "message":
            formatted_text = format_message(msg, previous_message, context, html_mode)

        if formatted_text:
            output_parts.append(formatted_text)
            processed_count += 1

        previous_message = msg

    result = "".join(output_parts).strip() + "\n"

    return result


--- Файл: ./src/core/conversion/context.py ---
from dataclasses import dataclass, field

from core.conversion.utils import sanitize_forward_name, truncate_name
from resources.translations import tr

@dataclass
class ConversionContext:
    config: dict
    message_map: dict[int, dict] = field(default_factory=dict)
    my_id: str | None = None
    main_post_id: int | None = None
    partner_id: str | None = None
    chat_name: str = tr("Unknown Chat")
    my_full_name: str | None = None
    partner_full_name: str | None = None

    def get_author_name(self, msg: dict) -> str:
        author_id = msg.get("from_id")
        profile = self.config.get("profile", "group")

        if profile == "personal":
            if author_id == self.my_id:
                result = self.config["my_name"]
                return result
            if author_id == self.partner_id:
                result = self.config["partner_name"]
                return result

            result = truncate_name(msg.get("from", tr("User")), context=self)
            return result

        elif profile == "posts":
            raw_name = msg.get("forwarded_from", msg.get("from", tr("User")))
            result = truncate_name(sanitize_forward_name(raw_name), context=self)
            return result

        result = truncate_name(msg.get("from", tr("User")), context=self)
        return result


--- Файл: ./src/core/conversion/utils.py ---
import logging
import re
from datetime import datetime
from html import escape
from typing import TYPE_CHECKING, Optional

from resources.translations import tr

logger = logging.getLogger(__name__)

INVALID_FORWARD_SOURCES = {"/dev/null", "null"}

if TYPE_CHECKING:
    from core.conversion.context import ConversionContext

def pluralize_ru(number: int, key_form1: str, key_form2: str, key_form5: str) -> str:
    """
    Selects the correct Russian plural form based on the number.
    """
    num = abs(number)
    if 11 <= num % 100 <= 19:
        return tr(key_form5)
    last_digit = num % 10
    if last_digit == 1:
        return tr(key_form1)
    if 2 <= last_digit <= 4:
        return tr(key_form2)
    return tr(key_form5)

def truncate_name(name: str | None, context: Optional["ConversionContext"] = None) -> str:
    max_len = 20
    if context and "truncate_name_length" in context.config:
        max_len = context.config["truncate_name_length"]

    if not name:
        return ""
    if len(name) > max_len:
        return name[:max_len-3] + "..."
    return name

def format_member_list(members: list[str], max_shown: int = 10, context: Optional["ConversionContext"] = None) -> str:
    total = len(members)
    if not total:
        return ""

    if total > max_shown:
        members_to_list = members[:max_shown]
        remaining_count = total - max_shown
        members_str = ", ".join([truncate_name(m, context) for m in members_to_list])
        members_str += f" and {remaining_count} more"
    else:
        members_str = ", ".join([truncate_name(m, context) for m in members])
    return members_str

def format_ttl_period(seconds: int | None) -> str:
    if not seconds:
        return tr("disabled")
    if seconds == 86400:
        return tr("24 hours")
    if seconds == 604800:
        return tr("7 days")
    if seconds == 2592000:
        return tr("1 month")

    days = seconds // 86400
    if days > 0:
        return tr("{days} d.").format(days=days)

    hours = seconds // 3600
    if hours > 0:
        return tr("{hours} h.").format(hours=hours)

    minutes = seconds // 60
    if minutes > 0:
        return tr("{minutes} min.").format(minutes=minutes)

    return tr("{seconds} sec.").format(seconds=seconds)

def sanitize_forward_name(name: str | None) -> str:
    if not name or name.strip() in INVALID_FORWARD_SOURCES:
        return tr("unknown source")
    return name

def format_date_separator(dt: datetime) -> str:

    month_key = f"month_gen_{dt.month}"
    month_name = tr(month_key)
    if month_name == month_key:
        month_name = dt.strftime("%B")
    return f"--- {dt.day} {month_name} {dt.year} ---"

def format_duration(seconds: int | float | None) -> str:
    if not isinstance(seconds, (int, float)) or seconds < 0:
        return "00:00"
    try:
        s = int(seconds)
        m, s = divmod(s, 60)
        h, m = divmod(m, 60)
        if h > 0:
            result = f"{h:02d}:{m:02d}:{s:02d}"
            return result
        result = f"{m:02d}:{s:02d}"
        return result
    except (TypeError, ValueError) as e:
        return "00:00"

def process_text_to_plain(text_data, context: "ConversionContext") -> str:
    config = context.config
    show_markdown = config.get("show_markdown", True)
    show_links = config.get("show_links", True)

    if isinstance(text_data, str):
        return text_data
    if isinstance(text_data, list):
        parts = []
        for item in text_data:
            if isinstance(item, str):
                parts.append(item)
            elif isinstance(item, dict) and "text" in item:
                text = item["text"]
                item_type = item.get("type")
                if item_type == "spoiler" and text == "\n":
                    text = ""

                if item_type == "bold" and show_markdown:
                    parts.append(f"**{text}**")
                elif item_type == "italic" and show_markdown:
                    parts.append(f"*{text}*")
                elif item_type == "strikethrough" and show_markdown:
                    parts.append(f"~~{text}~~")
                elif item_type == "underline" and show_markdown:
                    parts.append(f"_{text}_")
                elif item_type == "spoiler" and show_markdown:
                    parts.append(f"||{text}||")
                elif item_type == "code" and show_markdown:
                    parts.append(f"`{text}`")
                elif item_type == "bot_command":
                    parts.append(text)
                elif item_type == "custom_emoji":
                    parts.append(text)
                elif item_type == "pre" and show_markdown:
                    lang = item.get("language", "")
                    parts.append(f"\n```{lang}\n{text}\n```\n")
                elif item_type == "text_link":
                    if show_links:
                        href = item.get("href", "")
                        parts.append(f"[{text}]({href})")
                    else:
                        parts.append(text)

                elif item_type == "link":
                    if show_links:
                        parts.append(text)

                elif item_type == "blockquote" and show_markdown:
                    lines = text.split("\n")
                    formatted_lines = [f"> {line}" for line in lines]
                    parts.append("\n".join(formatted_lines))
                else:
                    parts.append(text)
        return "".join(parts)
    return ""

def markdown_to_html_for_preview(text: str) -> str:
    """Converts simple markdown-like text to basic HTML for preview."""

    text = re.sub(r'```(.*?)```', r'<code>\1</code>', text, flags=re.DOTALL)

    text = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', text)

    text = re.sub(r'__(.*?)__', r'<u>\1</u>', text)

    text = re.sub(r'\*(.*?)\*', r'<i>\1</i>', text)

    text = re.sub(r'~~(.*?)~~', r'<s>\1</s>', text)

    text = re.sub(r'\|\|(.*?)\|\|', r'<span class="spoiler">\1</span>', text)

    text = re.sub(r'`(.*?)`', r'<code>\1</code>', text)

    text = re.sub(r'\[(.*?)\]\((.*?)\)',
                  lambda m: f'<a href="{m.group(2).replace("&amp;", "&")}">{m.group(1)}</a>',
                  text)

    lines = text.split('\n')

    processed_lines = []
    for i, line in enumerate(lines):
        leading_spaces = len(line) - len(line.lstrip(' '))
        processed_line = '&nbsp;' * leading_spaces + line.lstrip(' ')
        processed_lines.append(processed_line)

    text = '<br>'.join(processed_lines)

    return text


--- Файл: ./src/core/conversion/formatters/__init__.py ---



--- Файл: ./src/core/conversion/formatters/service/complex.py ---
from core.conversion.context import ConversionContext
from core.conversion.formatters.media_formatter import format_media
from core.conversion.utils import (
    format_duration,
    format_member_list,
    pluralize_ru,
    process_text_to_plain,
    truncate_name,
)
from resources.translations import tr

def format_pin_message(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    pinned_message_id = msg.get("message_id")
    if pinned_message_id and (pinned_msg := context.message_map.get(pinned_message_id)):
        original_text = (
            process_text_to_plain(pinned_msg.get("text", ""), context)
            or format_media(pinned_msg, context)
            or tr("[Media]")
        )
        snippet = original_text.split("\n")[0].strip()
        max_len = context.config.get("truncate_quote_length", 50)
        if len(snippet) > max_len:
            snippet = snippet[:max_len] + "..."
        return f"{actor} {tr('pinned message')}: \"{snippet}\""
    return f"{actor} {tr('pinned message')}"

def format_phone_call(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    duration_sec = msg.get("duration_seconds")
    discard_reason = msg.get("discard_reason")

    is_group_call = msg.get("action") in ("group_call", "conference_call")

    if is_group_call:
        if duration_sec:
            duration_str = format_duration(duration_sec)
            return f"{tr('Video chat ended, duration')}: {duration_str}"
        else:
            return f"{actor} {tr('started video chat')}"

    call_type = (
        tr("Outgoing call")
        if actor == context.config.get("my_name")
        else tr("Incoming call")
    )

    if duration_sec:
        duration_str = format_duration(duration_sec)
        return f"{call_type}, {tr('duration')}: {duration_str}"

    reason_text = ""
    if discard_reason == "missed":
        reason_text = f" ({tr('missed')})"
    elif discard_reason == "busy":
        reason_text = f" ({tr('busy')})"
    elif discard_reason in ("hangup", "disconnect"):
        reason_text = f" ({tr('declined')})"

    return f"{call_type}{reason_text}"

def format_create_group(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    title = msg.get("title", "")
    members = msg.get("members", [])
    invited_members = [member for member in members if member != actor]
    text = f"{actor} {tr('created group')} «{title}»"
    if invited_members:
        invited_list_str = format_member_list(invited_members, context=context)
        text += f" {tr('and invited')} {invited_list_str}"
    return text

def format_add_user(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    members = msg.get("members", [])
    invited_members = [member for member in members if member and member != actor]
    if not invited_members:
        return f"{actor} {tr('joined group')}"
    members_str = format_member_list(invited_members, context=context)
    return f"{actor} {tr('invited')} {members_str}"

def format_join_by_link(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    inviter = truncate_name(msg.get("inviter"), context=context)
    if inviter:
        return f"{actor} {tr('joined group by link from')} {inviter}"
    return f"{actor} {tr('joined group by link')}"

def format_gift_premium(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    months = msg.get("months", 0)
    cost = msg.get("cost", "")
    text = f"{actor} {tr('gifted Telegram Premium')}"
    if months:
        text += f" {tr('for')} {months} {tr('months')}"
    if cost:
        text += f" ({cost})"
    return text

def format_boost(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    boosts = msg.get("boosts", 1)
    if boosts % 10 == 1 and boosts % 100 != 11:
        times_str = tr("time")
    elif 2 <= boosts % 10 <= 4 and (boosts % 100 < 10 or boosts % 100 >= 20):
        times_str = tr("times")
    else:
        times_str = tr("times")
    return f"{actor} {tr('boosted group')} {boosts} {times_str}"

def format_game_score(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    score = msg.get("score", 0)
    game_message_id = msg.get("game_message_id")

    game_title = "..."
    if game_message_id and (game_msg := context.message_map.get(game_message_id)):
        if game_info := game_msg.get("game_information"):
            game_title = game_info.get("game_title", "...")

    return f"{actor} {tr('scored')} {score} {tr('points in game')} «{game_title}»"

def format_payment_sent(msg: dict, context: ConversionContext) -> str:
    amount = msg.get("amount", 0)
    currency = msg.get("currency", "")

    formatted_amount = f"{amount / 100.0:.2f}"
    return f"{tr('Payment for')} {formatted_amount} {currency} {tr('sent')}"

def format_boost_apply(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    boosts = msg.get("boosts", 1)
    times_text = pluralize_ru(boosts, "time_form1", "time_form2", "time_form5")
    return f"{actor} {tr('boosted group')} {boosts} {times_text}"

def format_suggest_photo(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    return f"{actor} {tr('suggested a new profile photo')}"

def format_bot_allowed(msg: dict, context: ConversionContext) -> str:
    if domain := msg.get("domain"):
        return tr("allowed bot to send messages by logging in on") + f' {domain}'
    return tr("allowed bot to send messages")

def format_secure_values(msg: dict, context: ConversionContext) -> str:

    return tr("sent Telegram Passport data")

def format_geo_proximity(msg: dict, context: ConversionContext) -> str:
    from_id = msg.get("from_id")
    to_id = msg.get("to_id")
    distance = msg.get("distance", 0)
    distance_str = f"{distance}m"

    from_name = context.get_author_name({"from_id": from_id}) if from_id else "Someone"
    to_name = context.get_author_name({"from_id": to_id}) if to_id else "someone"

    if from_id == context.my_id:
        return tr("you are now within {distance} of {user}").format(distance=distance_str, user=to_name)
    elif to_id == context.my_id:
        return f"{from_name} " + tr("is now within {distance} of you").format(distance=distance_str)
    else:
        return f"{from_name} " + tr("is now within {distance} of {user}").format(distance=distance_str, user=to_name)

def format_payment_refunded(msg: dict, context: ConversionContext) -> str:
    currency = msg.get("currency", "")
    amount = msg.get("amount", 0) / 100.0
    return tr("payment of {amount} {currency} was refunded").format(amount=f"{amount:.2f}", currency=currency)


--- Файл: ./src/core/conversion/formatters/service/__init__.py ---



--- Файл: ./src/core/conversion/formatters/service/atomic.py ---
from datetime import datetime

from core.conversion.context import ConversionContext
from core.conversion.utils import format_ttl_period, pluralize_ru, truncate_name
from resources.translations import tr

def format_channel_create(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    title = msg.get("title", "...")
    return f"{actor} {tr('created channel')} «{title}»"

def format_edit_title(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    title = msg.get("title", "...")
    return f"{actor} {tr('changed group name to')} «{title}»"

def format_edit_photo(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    return f"{actor} {tr('changed group photo')}"

def format_delete_photo(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    return f"{actor} {tr('deleted group photo')}"

def format_history_clear(msg: dict, context: ConversionContext) -> str:
    return tr("History cleared")

def format_migrate_to_supergroup(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    return f"{actor} {tr('converted this group to supergroup')}"

def format_migrate_from_group(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    title = msg.get("title", "...")
    return f"{actor} {tr('converted group')} «{title}» {tr('to this supergroup')}"

def format_set_chat_theme(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    emoji = msg.get("emoticon", "")
    if emoji:
        return f"{actor} {tr('changed chat theme to')} {emoji}"
    return f"{actor} {tr('disabled chat theme')}"

def format_topic_create(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    title = msg.get("title", "...")
    return f"{actor} {tr('created topic')} «{title}»"

def format_topic_edit(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    new_title = msg.get("new_title")
    if new_title:
        return f"{actor} {tr('changed topic name to')} «{new_title}»"
    return f"{actor} {tr('edited topic')}"

def format_delete_user(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    member_kicked = truncate_name(msg.get("members", ["..."])[0], context=context)
    if actor == member_kicked:
        return f"{actor} {tr('left group')}"
    return f"{actor} {tr('removed')} {member_kicked}"

def format_screenshot_taken(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    return f"{actor} {tr('took screenshot')}"

def format_contact_signup(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    return f"{actor} {tr('joined Telegram')}"

def format_set_ttl(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    period = msg.get("period_seconds")
    period_str = format_ttl_period(period)
    if period:
        return f"{actor} {tr('set message auto-delete timer to')} {period_str}"
    else:
        return f"{actor} {tr('disabled message auto-delete timer')}"

def format_group_call_scheduled(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    schedule_date = msg.get("schedule_date")
    if schedule_date:
        dt_obj = datetime.fromisoformat(schedule_date)

        month_key = f"month_gen_{dt_obj.month}"
        month_name = tr(month_key)
        if month_name == month_key:
            month_name = dt_obj.strftime("%B")
        date_str = f"{dt_obj.strftime('%d')} {month_name} {dt_obj.strftime('%Y')}, {dt_obj.strftime('%H:%M')}"
        return f"{actor} {tr('scheduled video chat for')} {date_str}"
    return f"{actor} {tr('scheduled video chat')}"

def format_join_by_request(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    return f"{actor} {tr('joined group by request')}"

def format_webview_data(msg: dict, context: ConversionContext) -> str:
    button_text = msg.get("text", "...")
    return tr("sent data from button") + f' "{button_text}"'

def format_gift_code(msg: dict, context: ConversionContext) -> str:
    months = msg.get("months", 1)
    months_text = pluralize_ru(months, "month_form1", "month_form2", "month_form5")
    return tr("won premium for {months} {months_text}").format(months=months, months_text=months_text)

def format_custom_action(msg: dict, context: ConversionContext) -> str:
    return msg.get("text", tr("Service message"))

def format_star_gift(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    stars = msg.get("stars", 0)
    stars_text = pluralize_ru(stars, "star_form1", "star_form2", "star_form5")
    return f"{actor} {tr('gifted')} {stars} ★ {stars_text}"

def format_set_wallpaper(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    return f"{actor} {tr('changed chat wallpaper')}"


--- Файл: ./src/core/conversion/formatters/media_formatter.py ---


import logging
from core.conversion.context import ConversionContext
from core.conversion.formatters.media.game import format_game
from core.conversion.formatters.media.giveaway import (
    format_giveaway_start,
    format_giveaway_results,
)
from core.conversion.formatters.media.invoice import format_invoice
from core.conversion.formatters.media.polls import format_poll
from core.conversion.formatters.media.paid_content import format_paid_media
from core.conversion.formatters.media.todo import format_todo_list
from core.conversion.formatters.media.simple_media import (
    format_contact,
    format_dice,
    format_file,
    format_location,
    format_photo,
    format_place,
    format_venue,
)
from resources.translations import tr

logger = logging.getLogger(__name__)

def _is_file_included(msg: dict) -> bool:
    """Checks if the media file was actually exported."""

    not_included_str = "(File not included. Change data exporting settings to download.)"

    if msg.get("photo") == not_included_str:
        return False
    if msg.get("file") == not_included_str:
        return False

    return True

def format_media(msg: dict, context: ConversionContext) -> str:
    file_included = _is_file_included(msg)

    if poll_data := msg.get("poll"):
        return format_poll(poll_data, context)

    if msg.get("action") == "suggest_profile_photo" and msg.get("photo"):
        return format_photo(msg, context)

    if todo_data := msg.get("todo_list"):
        return format_todo_list(todo_data, context)

    if "paid_stars_amount" in msg:
        return format_paid_media(msg, context)

    if contact_info := msg.get("contact_information"):
        return format_contact(contact_info, context)

    if msg.get("place_name") and msg.get("address") and msg.get("location_information"):
        return format_place(msg, context)
    if venue_info := msg.get("venue"):
        return format_venue(venue_info, context)
    if location_info := msg.get("location_information"):
        return format_location(location_info, context)

    if dice_data := msg.get("dice"):
        return format_dice(dice_data, context)

    if msg.get("media_type") == "photo" or msg.get("photo"):
        return format_photo(msg, context)

    if msg.get("file"):
        return format_file(msg, context)

    if game_data := msg.get("game_information"):
        return format_game(game_data, context)

    if invoice_data := msg.get("invoice_information"):
        return format_invoice(invoice_data, context)

    if giveaway_info := msg.get("giveaway_information"):
        return format_giveaway_start(giveaway_info, context)

    if giveaway_results := msg.get("giveaway_results_information"):
        return format_giveaway_results(giveaway_results, context)

    if "via_bot_id" in msg and not msg.get("text") and not msg.get("file") and not msg.get("photo"):
        return tr("[Mini-game]")

    return ""


--- Файл: ./src/core/conversion/formatters/media/__init__.py ---



--- Файл: ./src/core/conversion/formatters/media/game.py ---
from core.conversion.context import ConversionContext
from resources.translations import tr

def format_game(game_data: dict, context: ConversionContext) -> str:
    title = game_data.get("game_title")
    description = game_data.get("game_description", "")

    if not title:
        return tr("[Mini-game]")

    parts = [tr("[Game]"), f"{tr('Title')}: {title}"]
    if description:
        parts.append(f"{tr('Description')}: {description}")

    return "\n".join(parts)


--- Файл: ./src/core/conversion/formatters/media/todo.py ---
from core.conversion.context import ConversionContext
from core.conversion.utils import process_text_to_plain
from resources.translations import tr

def format_todo_list(todo_data: dict, context: ConversionContext) -> str:
    """Formats a to-do list."""
    lines = [f"**{tr('To-Do List')}**"]

    title = process_text_to_plain(todo_data.get('title', ''), context)
    if title:
        lines.append(f"{tr('Title')}: {title}")

    for item in todo_data.get("items", []):
        text = process_text_to_plain(item.get('text', ''), context)
        lines.append(f"- [ ] {text}")

    return "\n".join(lines)


--- Файл: ./src/core/conversion/formatters/media/simple_media.py ---
import logging
from core.conversion.context import ConversionContext
from core.conversion.utils import format_duration
from resources.translations import tr

logger = logging.getLogger(__name__)

BAD_FILENAME = "(File not included. Change data exporting settings to download.)"

def format_photo(msg: dict, context: ConversionContext) -> str:
    base_label = tr("[Photo]")
    spoiler_prefix = f"{tr('[SPOILER]')} " if msg.get("media_spoiler") else ""

    if not context.config.get("show_tech_info", True):
        return f"{spoiler_prefix}{base_label}"

    extras = []
    width = msg.get("width")
    height = msg.get("height")

    if width and height:
        dimension_str = f"{width}x{height}"
        extras.append(dimension_str)

    if extras:
        details_str = ", ".join(extras)
        result = f"{spoiler_prefix}{tr('[Photo ({details})]').format(details=details_str)}"
        return result

    return f"{spoiler_prefix}{base_label}"

def format_file(msg: dict, context: ConversionContext) -> str:
    spoiler_prefix = f"{tr('[SPOILER]')} " if msg.get("media_spoiler") else ""
    show_tech_info = context.config.get("show_tech_info", True)

    filename = msg.get("file_name", tr("file"))
    media_type = msg.get("media_type")
    duration_sec = msg.get("duration_seconds")

    if media_type == "audio_file":
        if not show_tech_info:
            return f"{spoiler_prefix}{tr('[Audio]')}"
        performer = msg.get("performer", tr("Unknown performer"))
        title = msg.get("title", filename)
        duration = format_duration(duration_sec)
        return f"{spoiler_prefix}{tr('[Audio: {performer} - {title} ({duration})]').format(performer=performer, title=title, duration=duration)}"

    if media_type == "video_file":
        base_label = tr("[Video]")
        if not show_tech_info:
            return f"{spoiler_prefix}{base_label}"

        extras = []

        if filename and filename != BAD_FILENAME and filename != tr("file"):
            extras.append(filename)

        width = msg.get("width")
        height = msg.get("height")

        if width and height:
            dimension_str = f"{width}x{height}"
            extras.append(dimension_str)

        if duration_sec is not None:
            duration_str = format_duration(duration_sec)
            extras.append(duration_str)

        if extras:
            result = f"{spoiler_prefix}{tr('[Video ({details})]').format(details=', '.join(extras))}"
            return result
        return f"{spoiler_prefix}{base_label}"

    if media_type == "animation":
        base_label = tr("[Animation]")
        if not show_tech_info:
            return f"{spoiler_prefix}{base_label}"

        extras = []

        if filename and filename != BAD_FILENAME and filename != tr("file"):
            extras.append(filename)

        width = msg.get("width")
        height = msg.get("height")

        if width and height:
            dimension_str = f"{width}x{height}"
            extras.append(dimension_str)

        if duration_sec is not None:
            duration_str = format_duration(duration_sec)
            extras.append(duration_str)

        if extras:
            result = f"{spoiler_prefix}{tr('[Animation ({details})]').format(details=', '.join(extras))}"
            return result
        return f"{spoiler_prefix}{base_label}"

    if media_type == "voice_message":
        if not show_tech_info:
            return f"{spoiler_prefix}{tr('[Voice message]')}"
        return f"{spoiler_prefix}{tr('[Voice message ({duration})]').format(duration=format_duration(duration_sec))}"
    if media_type == "video_message":
        if not show_tech_info:
            return f"{spoiler_prefix}{tr('[Video message]')}"
        return f"{spoiler_prefix}{tr('[Video message ({duration})]').format(duration=format_duration(duration_sec))}"
    if media_type == "sticker":
        if not show_tech_info:
            return f"{spoiler_prefix}{tr('[Sticker]')}"
        emoji = msg.get("sticker_emoji", "")
        return f"{spoiler_prefix}{tr('[Sticker {emoji}]').format(emoji=emoji)}"

    if not show_tech_info:
        return f"{spoiler_prefix}{tr('[File]')}"
    return f"{spoiler_prefix}{tr('[File: {filename}]').format(filename=filename)}"

def format_contact(contact_info: dict, context: ConversionContext) -> str:
    name = f"{contact_info.get('first_name', '')} {contact_info.get('last_name', '')}".strip()
    phone = (
        contact_info.get("phone_number", tr("phone not specified"))
        if context.config.get("show_tech_info", True)
        else ""
    )
    return f"{tr('[Contact: {name}, {phone}]').format(name=name, phone=phone)}"

def format_location(location_info: dict, context: ConversionContext) -> str:
    lat = location_info.get("latitude")
    lon = location_info.get("longitude")

    if not context.config.get("show_tech_info", True):
        return f"{tr('[Geoposition]')}"

    return f"{tr('[Geoposition: {lat:.6f}, {lon:.6f}]').format(lat=lat, lon=lon)}"

def format_place(msg: dict, context: ConversionContext) -> str:
    place_name = msg.get("place_name", tr("No title"))
    address = msg.get("address", "")
    show_tech_info = context.config.get("show_tech_info", True)
    location_info = msg.get("location_information")

    if show_tech_info and location_info:
        lat = location_info.get("latitude")
        lon = location_info.get("longitude")
        if lat is not None and lon is not None:
            return f"{tr('[Place: {place}, {address} (Coordinates: {lat:.6f}, {lon:.6f})]').format(place=place_name, address=address, lat=lat, lon=lon)}"

    return f"{tr('[Place: {place}, {address}]').format(place=place_name, address=address)}"

def format_venue(venue_info: dict, context: ConversionContext) -> str:
    title = venue_info.get("title", tr("No title"))
    address = venue_info.get("address", "")
    return f"{tr('[Place: {title}, {address}]').format(title=title, address=address)}"

def format_dice(dice_data: dict, context: ConversionContext) -> str:
    emoji = dice_data.get("emoji", "🎲")
    value = dice_data.get("value", "?")
    return f"{tr('[Dice roll: {emoji} (Result: {value})]').format(emoji=emoji, value=value)}"


--- Файл: ./src/core/conversion/formatters/media/invoice.py ---
from core.conversion.context import ConversionContext
from resources.translations import tr

def format_invoice(invoice_data: dict, context: ConversionContext) -> str:
    title = invoice_data.get("title", tr("No title"))
    description = invoice_data.get("description", "")
    amount = invoice_data.get("amount", 0)
    currency = invoice_data.get("currency", "")

    formatted_amount = f"{amount / 100.0:.2f}"

    parts = [tr("[Payment invoice]"), f"{tr('Title')}: {title}"]
    if description:
        parts.append(f"{tr('Description')}: {description}")
    parts.append(f"{tr('Amount')}: {formatted_amount} {currency}")

    return "\n".join(parts)


--- Файл: ./src/core/conversion/formatters/media/paid_content.py ---
from core.conversion.context import ConversionContext
from resources.translations import tr

def format_paid_media(msg: dict, context: ConversionContext) -> str:
    """Formats paid media message."""
    stars = msg.get("paid_stars_amount", 0)

    return f"[{tr('Paid Content')}: {stars} ★]"


--- Файл: ./src/core/conversion/formatters/media/giveaway.py ---
from datetime import datetime

from core.conversion.context import ConversionContext
from core.conversion.utils import pluralize_ru
from resources.translations import tr

def format_giveaway_start(giveaway_data: dict, context: ConversionContext) -> str:
    """Formats giveaway start message."""
    parts = [f"**{tr('Giveaway')}**"]
    quantity = giveaway_data.get("quantity", 1)
    months = giveaway_data.get("months", 0)
    prize_months_text = pluralize_ru(months, "month_form1", "month_form2", "month_form5")
    prize_text = tr("{quantity} Premium subscriptions for {months} {months_text}").format(
        quantity=quantity, months=months, months_text=prize_months_text
    )
    parts.append(f"{tr('Prize:')} {prize_text}")

    if additional_prize := giveaway_data.get("additional_prize"):
        parts.append(f"{tr('Additionally:')} {additional_prize}")

    until_date_str = giveaway_data.get("until_date", "")
    if isinstance(until_date_str, datetime):
        until_date = until_date_str
    else:
        until_date = datetime.fromisoformat(until_date_str) if until_date_str else None
    if until_date:
        parts.append(f"{tr('Until:')} {until_date.strftime('%d %B %Y, %H:%M')}")

    return "\n".join(parts)

def format_giveaway_results(results_data: dict, context: ConversionContext) -> str:
    """Formats giveaway results message."""
    parts = [f"**{tr('Giveaway Results')}**"]
    winners_count = results_data.get("winners_count", 0)
    unclaimed_count = results_data.get("unclaimed_count", 0)
    winners_text = pluralize_ru(winners_count, "winner_form1", "winner_form2", "winner_form5")
    parts.append(f"{tr('Winners:')} {winners_count} {winners_text}")
    if unclaimed_count > 0:
        unclaimed_text = pluralize_ru(unclaimed_count, "unclaimed_form1", "unclaimed_form2", "unclaimed_form5")
        parts.append(f"({unclaimed_count} {unclaimed_text})")

    return "\n".join(parts)


--- Файл: ./src/core/conversion/formatters/media/polls.py ---
from core.conversion.context import ConversionContext
from resources.translations import tr
from core.conversion.utils import pluralize_ru

def format_poll(poll_data: dict, context: ConversionContext) -> str:
    lines = [tr("[Poll]")]
    lines.append(f"{tr('Question')}: {poll_data.get('question', tr('No question'))}")
    total_voters = poll_data.get("total_voters", 0)
    for answer in poll_data.get("answers", []):
        text = answer.get("text", tr("No text"))
        voters = answer.get("voters", 0)
        percentage = (voters / total_voters * 100) if total_voters > 0 else 0
        chosen_marker = f" ({tr('Your choice')})" if answer.get("chosen") else ""
        voters_text = pluralize_ru(voters, "people_form1", "people_form2", "people_form5")
        lines.append(
            f'- {text}: {voters} {voters_text} ({percentage:.0f}%){chosen_marker}'
        )
    total_voters_text = pluralize_ru(total_voters, "people_form1", "people_form2", "people_form5")
    lines.append(f"{tr('Total voted')}: {total_voters} {total_voters_text}")
    if poll_data.get("closed", False):
        lines.append(f"({tr('Poll closed')})")
    return "\n".join(lines)


--- Файл: ./src/core/conversion/formatters/service_formatter.py ---
import logging
from core.conversion.context import ConversionContext
from core.conversion.formatters.service.atomic import (
    format_channel_create,
    format_contact_signup,
    format_delete_photo,
    format_delete_user,
    format_edit_photo,
    format_edit_title,
    format_group_call_scheduled,
    format_history_clear,
    format_migrate_from_group,
    format_migrate_to_supergroup,
    format_screenshot_taken,
    format_set_chat_theme,
    format_set_ttl,
    format_topic_create,
    format_topic_edit,
    format_star_gift,
    format_set_wallpaper,
)
from core.conversion.formatters.service.complex import (
    format_add_user,
    format_boost,
    format_boost_apply,
    format_create_group,
    format_game_score,
    format_gift_premium,
    format_join_by_link,
    format_payment_sent,
    format_phone_call,
    format_pin_message,
)
from core.conversion.utils import (
    format_duration,
    format_member_list,
    pluralize_ru,
    process_text_to_plain,
    truncate_name,
)
from resources.translations import tr

logger = logging.getLogger(__name__)

SKIPPED_SERVICE_ACTIONS = set()

def format_service_message(msg: dict, context: ConversionContext) -> str | None:
    if not context.config.get("show_service_notifications", True):
        return None

    if context.config.get("profile") == "posts":
        return None

    action = msg.get("action", "unknown_action")

    if action in SKIPPED_SERVICE_ACTIONS:
        return None

    handlers = {
        "pin_message": format_pin_message,
        "phone_call": format_phone_call,
        "group_call": format_phone_call,
        "conference_call": format_phone_call,
        "create_group": format_create_group,
        "invite_members": format_add_user,
        "join_group_by_link": format_join_by_link,
        "gift_premium": format_gift_premium,
        "boost_apply": format_boost_apply,
        "game_score": format_game_score,
        "payment_sent": format_payment_sent,
        "channel_create": format_channel_create,
        "edit_group_title": format_edit_title,
        "edit_group_photo": format_edit_photo,
        "delete_group_photo": format_delete_photo,
        "history_clear": format_history_clear,
        "migrate_to_supergroup": format_migrate_to_supergroup,
        "migrate_from_group": format_migrate_from_group,
        "set_chat_theme": format_set_chat_theme,
        "topic_created": format_topic_create,
        "topic_edit": format_topic_edit,
        "remove_members": format_delete_user,
        "screenshot_taken": format_screenshot_taken,
        "contact_signup": format_contact_signup,
        "set_messages_ttl": format_set_ttl,
        "group_call_scheduled": format_group_call_scheduled,
        "send_star_gift": format_star_gift,
        "set_chat_wallpaper": format_set_wallpaper,
        "set_same_chat_wallpaper": format_set_wallpaper,

        "stars_prize": format_prize_stars,
        "todo_completions": format_todo_completions,
        "todo_append_tasks": format_todo_append_tasks,

    }

    if handler := handlers.get(action):
        service_text = handler(msg, context)
        result = f"\n--- [{service_text}] ---\n"
        return result

    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    title = msg.get("title", "")
    fallback_result = f"\n--- [{tr('Service message from')} '{actor}': {action} '{title}'] ---\n"
    return fallback_result

def format_prize_stars(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("boost_peer_name", tr("Channel")), context=context)
    stars = msg.get("stars", 0)
    stars_text = pluralize_ru(stars, "star_form1", "star_form2", "star_form5")
    return tr("won_prize_from").format(actor=actor, count=stars, stars_text=stars_text)

def format_todo_completions(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)

    return f"{actor} {tr('updated_tasks_in_list')}"

def format_todo_append_tasks(msg: dict, context: ConversionContext) -> str:
    actor = truncate_name(msg.get("actor", tr("System")), context=context)
    items = msg.get("items", [])
    if not items:
        return f"{actor} {tr('updated_tasks_in_list')}"

    tasks_texts = [
        process_text_to_plain(item.get("text", ""), context)
        for item in items
    ]
    tasks_str = ", ".join(f'"{text}"' for text in tasks_texts if text)
    return f"{actor} {tr('added_tasks')}: {tasks_str}"


--- Файл: ./src/core/conversion/message_formatter.py ---
import re
from datetime import datetime

from core.conversion.context import ConversionContext
from core.conversion.formatters.media_formatter import format_media
from core.conversion.utils import (
    process_text_to_plain,
    sanitize_forward_name,
    truncate_name,
)
from resources.translations import tr

def _parse_time_to_seconds(time_str: str) -> int:
    if not re.match(r"^\d{1,2}:\d{2}$", time_str):
        return 0

    try:
        hours, minutes = map(int, time_str.split(":"))

        if (0 <= hours < 24 and 0 <= minutes < 60) or (hours == 24 and minutes == 0):
            return hours * 3600 + minutes * 60
    except ValueError:
        pass

    return 0

def _should_print_header(
    msg: dict, prev_msg: dict | None, context: ConversionContext
) -> bool:
    if not prev_msg:
        return True

    try:
        current_dt = datetime.fromisoformat(msg["date"])
        prev_dt = datetime.fromisoformat(prev_msg["date"])
        if current_dt.date() != prev_dt.date():
            return True
    except (ValueError, KeyError):
        return True

    show_optimization = context.config.get("show_optimization", False)
    current_author = context.get_author_name(msg)
    prev_author = context.get_author_name(prev_msg)
    profile = context.config.get("profile", "group")

    if current_author != prev_author:
        return True

    show_service = context.config.get("show_service_notifications", True)
    if show_service and prev_msg.get("type") != "message":
        return True

    if show_optimization:
        if profile == "channel":

            streak_break_str = context.config.get("streak_break_time", "20:00")
            break_seconds = _parse_time_to_seconds(streak_break_str)

            if break_seconds > 0:
                time_diff = (current_dt - prev_dt).total_seconds()
                if time_diff >= break_seconds:
                    return True

            if "reactions" in prev_msg:
                return True
            if "inline_bot_buttons" in prev_msg or "reply_markup" in prev_msg:
                return True
            if msg.get("reply_to_message_id") != prev_msg.get("reply_to_message_id"):
                return True
            if msg.get("forwarded_from") != prev_msg.get("forwarded_from"):
                return True

            return False
        else:

            if "reactions" in prev_msg:
                return True

            return False

    if profile != "channel":
        return True

    return True

def _format_header(msg: dict, context: ConversionContext) -> str:
    author = context.get_author_name(msg)
    time_str = ""
    if context.config.get("show_time", True):
        try:
            is_edited = "edited" in msg
            date_key = "edited" if is_edited else "date"
            dt = datetime.fromisoformat(msg[date_key])
            time_part = dt.strftime("%H:%M")
            edited_part = tr(" (edited)") if is_edited else ""
            time_str = f" ({time_part}{edited_part})"
        except (ValueError, KeyError):
            pass
    return f"{author}{time_str}:\n"

def _format_reply(msg: dict, context: ConversionContext) -> str:

    if (
        context.config.get("profile") == "posts"
        and msg.get("reply_to_message_id") == context.main_post_id
    ):
        return ""

    if reply_id := msg.get("reply_to_message_id"):
        if original_msg := context.message_map.get(reply_id):
            original_author = context.get_author_name(original_msg)
            original_text = (
                process_text_to_plain(original_msg.get("text", ""), context)
                or format_media(original_msg, context)
                or tr("[Media]")
            )
            snippet = original_text.split("\n")[0].strip()
            max_len = context.config.get("truncate_quote_length", 50)
            if len(snippet) > max_len:
                snippet = snippet[:max_len] + "..."
            return f'  > {original_author}: "{snippet}"\n'
    return ""

def _format_reactions(
    msg: dict, context: ConversionContext, html_mode: bool = False
) -> str:
    if not context.config.get("show_reactions", True):
        return ""

    lines = []
    if reactions := msg.get("reactions"):
        for r in reactions:
            count = r.get("count", 1)
            emoji = r.get("emoji", "👍")
            reaction_text = f"{emoji}" if count == 1 else f"{emoji} {count}"

            if context.config.get("show_reaction_authors", False) and (
                recent := r.get("recent")
            ):
                authors = ", ".join([context.get_author_name(p) for p in recent])
                reaction_text += f" ({tr('from')}: {authors})"

            reaction_marker = ">"
            if (
                context.config["profile"] == "personal"
                and (reactors := r.get("recent"))
                and reactors
            ):
                first_reactor_id = reactors[0].get("from_id")
                if first_reactor_id == context.my_id:
                    reaction_marker = "&gt;&gt;" if html_mode else ">>"
                elif first_reactor_id == context.partner_id:
                    reaction_marker = "&lt;&lt;" if html_mode else "<<"

            lines.append(f"{reaction_marker} {reaction_text}")
    return "\n".join(lines) + "\n" if lines else ""

def _format_reply_markup(msg: dict, context: ConversionContext) -> str:
    rows = msg.get("inline_bot_buttons")

    if not isinstance(rows, list) and (reply_markup := msg.get("reply_markup")):
        rows = reply_markup.get("rows", [])

    if not rows or not isinstance(rows, list):
        return ""

    lines = [tr("[Buttons under message]")]
    for i, row in enumerate(rows):
        if not isinstance(row, list):
            continue

        button_texts = []
        for btn in row:
            if isinstance(btn, dict) and (text := btn.get("text")):
                safe_text = text.replace('"', '\\"')
                button_texts.append(f'"{safe_text}"')

        if button_texts:
            lines.append(f"- [{tr('Row')} {i+1}]: {' | '.join(button_texts)}")

    return "\n".join(lines) + "\n" if len(lines) > 1 else ""

def format_message(
    msg: dict,
    prev_msg: dict | None,
    context: ConversionContext,
    html_mode: bool = False,
) -> str:
    lines = []
    print_header = _should_print_header(msg, prev_msg, context)

    if print_header and prev_msg:
        lines.append("\n")

    if print_header:
        lines.append(_format_header(msg, context))

        if via_bot_id := msg.get("via_bot_id"):
            lines.append(f"  ({tr('via bot')} {via_bot_id})\n")

        forwarded_from_raw = msg.get("forwarded_from")
        if forwarded_from_raw and not msg.get("showForwardedAsOriginal"):
            if context.config["profile"] != "posts":
                clean_name = truncate_name(sanitize_forward_name(forwarded_from_raw), context=context)
                lines.append(f"  [{tr('forwarded from')} {clean_name}]\n")

        lines.append(_format_reply(msg, context))

    content = process_text_to_plain(msg.get("text", ""), context)
    media_info = format_media(msg, context)

    body_parts = []
    if content:
        body_parts.extend(content.split("\n"))
    if media_info:
        body_parts.extend(media_info.split("\n"))

    if not body_parts and not msg.get("reactions"):

        if print_header:
            body_parts.append(tr("[Mini-game]"))
        else:

            body_parts.append(tr("[Empty message]"))

    lines.extend([f"  {line}\n" for line in body_parts])

    if signature := msg.get("signature"):
        lines.append(f"  {tr('Signature')}: {signature}\n")

    lines.append(_format_reactions(msg, context, html_mode))
    lines.append(_format_reply_markup(msg, context))

    return "".join(lines)


--- Файл: ./src/core/application/chart_interaction_service.py ---
"""
Service for handling chart interactions.

- Mouse event handling (clicks, hover)
- Selection state management
- Tooltip and cursor logic
- Filter change coordination
"""

import logging
from typing import Callable, Optional, Set

from core.analysis.tree_analyzer import TreeNode
from core.application.chart_service import ChartService
from core.view_models import ChartInteractionInfo, ChartViewModel, SunburstSegment

logger = logging.getLogger(__name__)

class ChartInteractionService:
    """Service for handling chart interactions."""

    def __init__(self, chart_service: ChartService):
        self._chart_service = chart_service
        self._current_view_model: Optional[ChartViewModel] = None
        self._hover_callbacks = []
        self._click_callbacks = []

    def set_current_view_model(self, view_model: ChartViewModel):
        """Sets current ViewModel for interactions."""
        self._current_view_model = view_model

    def add_hover_callback(self, callback: Callable[[Optional[SunburstSegment]], None]):
        """Adds callback for hover events."""
        self._hover_callbacks.append(callback)

    def add_click_callback(self, callback: Callable[[SunburstSegment], None]):
        """Adds callback for click events."""
        self._click_callbacks.append(callback)

    def handle_mouse_move(self, x: float, y: float) -> Optional[str]:
        """
        Handles mouse movement over chart.

        Args:
            x: Mouse X coordinate
            y: Mouse Y coordinate

        Returns:
            Optional[str]: Tooltip text or None
        """
        if not self._current_view_model:
            return None

        segment = self._chart_service.find_segment_at_position(
            x, y, self._current_view_model
        )

        self._update_hover_state(segment)

        for callback in self._hover_callbacks:
            try:
                callback(segment)
            except Exception as e:
                logger.error(f"Error in hover callback: {e}")

        if segment:
            return self._chart_service.get_segment_tooltip(
                segment, self._current_view_model.unit
            )
        else:
            return None

    def handle_mouse_click(self, x: float, y: float) -> bool:
        """
        Handles mouse click on chart.

        Args:
            x: Click X coordinate
            y: Click Y coordinate

        Returns:
            bool: True if click was processed, False otherwise
        """
        if not self._current_view_model:
            return False

        segment = self._chart_service.find_segment_at_position(
            x, y, self._current_view_model
        )

        if not segment:
            return False

        new_disabled_nodes = self._chart_service.toggle_node_selection(
            segment.node, self._current_view_model.disabled_nodes
        )

        self._current_view_model.disabled_nodes = new_disabled_nodes

        if (
            hasattr(self._current_view_model, "segments")
            and self._current_view_model.segments
        ):

            root_node = self._find_root_node()
            if root_node:
                self._current_view_model.filtered_value = (
                    self._chart_service.calculate_filtered_value(
                        root_node, new_disabled_nodes
                    )
                )

        self._update_segment_states()

        for callback in self._click_callbacks:
            try:
                callback(segment)
            except Exception as e:
                logger.error(f"Error in click callback: {e}")

        return True

    def handle_mouse_leave(self):
        """Handles mouse leaving chart area."""
        if self._current_view_model:
            self._update_hover_state(None)

        for callback in self._hover_callbacks:
            try:
                callback(None)
            except Exception as e:
                logger.error(f"Error in hover callback on exit: {e}")

    def get_cursor_type(self, x: float, y: float) -> str:
        """
        Determines cursor type for position.

        Args:
            x: X coordinate
            y: Y coordinate

        Returns:
            str: Cursor type ("default", "pointer", "hand")
        """
        if not self._current_view_model:
            return "default"

        segment = self._chart_service.find_segment_at_position(
            x, y, self._current_view_model
        )

        return "pointer" if segment else "default"

    def get_interaction_info(self) -> Optional[ChartInteractionInfo]:
        """Returns current interaction information."""
        if not self._current_view_model:
            return None

        return self._current_view_model.interaction

    def select_all_segments(self) -> Set[TreeNode]:
        """
        Selects all segments (disables all nodes).

        Returns:
            Set[TreeNode]: New set of disabled nodes
        """
        if not self._current_view_model:
            return set()

        all_nodes = set()
        for segment in self._current_view_model.segments:
            all_nodes.add(segment.node)

        self._current_view_model.disabled_nodes = all_nodes
        self._update_segment_states()

        root_node = self._find_root_node()
        if root_node:
            self._current_view_model.filtered_value = (
                self._chart_service.calculate_filtered_value(root_node, all_nodes)
            )

        return all_nodes

    def clear_all_selections(self) -> Set[TreeNode]:
        """
        Clears all selections (enables all nodes).

        Returns:
            Set[TreeNode]: New set of disabled nodes (empty)
        """
        if not self._current_view_model:
            return set()

        self._current_view_model.disabled_nodes = set()
        self._update_segment_states()

        root_node = self._find_root_node()
        if root_node:
            self._current_view_model.filtered_value = (
                self._chart_service.calculate_filtered_value(root_node, set())
            )

        return set()

    def update_disabled_nodes(self, disabled_nodes: Set[TreeNode]):
        """
        Updates disabled nodes from external source.

        Args:
            disabled_nodes: New set of disabled nodes
        """
        if not self._current_view_model:
            return

        self._current_view_model.disabled_nodes = disabled_nodes.copy()
        self._update_segment_states()

        root_node = self._find_root_node()
        if root_node:
            self._current_view_model.filtered_value = (
                self._chart_service.calculate_filtered_value(root_node, disabled_nodes)
            )

    def get_disabled_nodes(self) -> Set[TreeNode]:
        """Returns current set of disabled nodes."""
        if not self._current_view_model:
            return set()

        return self._current_view_model.disabled_nodes.copy()

    def get_statistics(self) -> dict:
        """Returns interaction statistics."""
        if not self._current_view_model:
            return {}

        return self._chart_service.get_chart_statistics(self._current_view_model)

    def _update_hover_state(self, hovered_segment: Optional[SunburstSegment]):
        """Updates hover state in ViewModel."""
        if not self._current_view_model:
            return

        if self._current_view_model.interaction.hovered_segment:
            self._current_view_model.interaction.hovered_segment.is_hovered = False

        if hovered_segment:
            hovered_segment.is_hovered = True
            self._current_view_model.interaction.hovered_segment = hovered_segment

            tooltip_text = self._chart_service.get_segment_tooltip(
                hovered_segment, self._current_view_model.unit
            )
            self._current_view_model.interaction.tooltip_text = tooltip_text
            self._current_view_model.interaction.cursor_type = "pointer"
        else:
            self._current_view_model.interaction.hovered_segment = None
            self._current_view_model.interaction.tooltip_text = ""
            self._current_view_model.interaction.cursor_type = "default"

    def _update_segment_states(self):
        """Updates states of all segments based on disabled nodes."""
        if not self._current_view_model:
            return

        disabled_nodes = self._current_view_model.disabled_nodes

        for segment in self._current_view_model.segments:

            is_disabled = self._chart_service.is_effectively_disabled(
                segment.node, disabled_nodes
            )

            segment.is_disabled = is_disabled

            if is_disabled and not segment.color.startswith("#"):

                segment.color = self._chart_service.darken_color(segment.color)
            elif not is_disabled and segment.color.startswith("#"):

                pass

    def _find_root_node(self) -> Optional[TreeNode]:
        """Finds root node from segments."""
        if not self._current_view_model or not self._current_view_model.segments:
            return None

        min_depth = float("inf")
        root_candidate = None

        for segment in self._current_view_model.segments:
            depth = self._chart_service.get_node_absolute_depth(segment.node)
            if depth < min_depth:
                min_depth = depth
                root_candidate = segment.node

        if root_candidate:
            while root_candidate.parent:
                root_candidate = root_candidate.parent

        return root_candidate

    def debug_interaction_state(self) -> dict:
        """Returns debug information about interaction state."""
        if not self._current_view_model:
            return {"error": "No view model"}

        interaction = self._current_view_model.interaction

        return {
            "segments_count": len(self._current_view_model.segments),
            "disabled_nodes_count": len(self._current_view_model.disabled_nodes),
            "hovered_segment": (
                interaction.hovered_segment.node.name
                if interaction.hovered_segment
                else None
            ),
            "selected_segments_count": len(interaction.selected_segments),
            "tooltip_text": interaction.tooltip_text,
            "cursor_type": interaction.cursor_type,
            "callbacks_registered": {
                "hover": len(self._hover_callbacks),
                "click": len(self._click_callbacks),
            },
        }


--- Файл: ./src/core/application/chart_service.py ---
"""
Service for working with charts.

- Mathematical calculations for sunburst charts
- Color schemes and algorithms
- Tree traversal and depth calculations
- Node filtering logic
- Element positioning
"""

import logging
import math
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Set, Tuple

from core.analysis.tree_analyzer import TreeNode, aggregate_children_for_view
from core.view_models import ChartViewModel, SunburstSegment

logger = logging.getLogger(__name__)

YEAR_SATURATION = 0.85
MONTH_SATURATION = 0.70
DAY_SATURATION = 0.60

YEAR_BRIGHTNESS = 0.95
MONTH_BRIGHTNESS = 0.85
DAY_BRIGHTNESS = 0.75

DARKEN_FACTOR = 0.7

DEFAULT_INNER_RADIUS = 30
RING_WIDTH = 70
MIN_ANGLE_FOR_TEXT = 0.1

@dataclass
class ChartGeometry:
    """Geometric parameters of the chart."""

    center_x: float
    center_y: float
    inner_radius: float
    ring_width: float
    total_radius: float

    def get_ring_bounds(self, level: int) -> Tuple[float, float]:
        """Returns inner and outer radius for the level."""
        inner = self.inner_radius + level * self.ring_width
        outer = inner + self.ring_width
        return inner, outer

class ChartService:
    """Service for working with charts."""

    def __init__(self):
        self._current_geometry: Optional[ChartGeometry] = None

    def calculate_sunburst_data(
        self,
        root_node: TreeNode,
        disabled_nodes: Set[TreeNode],
        chart_width: int = 400,
        chart_height: int = 400,
        color_scheme: str = "default",
    ) -> ChartViewModel:
        """
        Calculates chart data in abstract coordinates.
        Returns normalized chart geometry for rendering.
        """

        CENTER_HOLE_RADIUS, RING_WIDTH, MAX_DEPTH = 0.35, 0.25, 3

        segments = []
        start_absolute_depth = self.get_node_absolute_depth(root_node)

        self._build_segments_recursive_normalized(
            node=root_node,
            start_angle=0,
            end_angle=360,
            start_absolute_depth=start_absolute_depth,
            segments=segments,
            disabled_nodes=disabled_nodes,
        )

        unit = self._detect_unit_from_node(root_node)

        geometry = {
            "center_hole_radius": CENTER_HOLE_RADIUS,
            "ring_width": RING_WIDTH,
            "total_radius": CENTER_HOLE_RADIUS + (MAX_DEPTH * RING_WIDTH) + 0.05,
        }

        view_model = ChartViewModel(
            segments=segments,
            unit=unit,
            chart_width=chart_width,
            chart_height=chart_height,
            disabled_nodes=disabled_nodes,
            geometry=geometry
        )
        return view_model

    def _build_segments_recursive(
        self,
        node: TreeNode,
        disabled_nodes: Set[TreeNode],
        start_angle: float,
        end_angle: float,
        level: int,
        geometry: ChartGeometry,
        color_scheme: str,
        segments: List[SunburstSegment],
    ):
        """Recursively builds chart segments."""
        if not node.children and not (
            hasattr(node, "aggregated_children") and node.aggregated_children
        ):
            return

        children = node.children[:]
        if hasattr(node, "aggregated_children") and node.aggregated_children:
            children.extend(node.aggregated_children)

        if not children:
            return

        total_value = sum(child.value for child in children)
        if total_value <= 0:
            return

        inner_radius, outer_radius = geometry.get_ring_bounds(level)

        if outer_radius > geometry.total_radius:
            return

        current_angle = start_angle
        angle_range = end_angle - start_angle

        for i, child in enumerate(children):
            if child.value <= 0:
                continue

            angle_size = (child.value / total_value) * angle_range
            child_end_angle = current_angle + angle_size

            show_text = angle_size >= MIN_ANGLE_FOR_TEXT

            angle_deg = math.degrees((current_angle + child_end_angle) / 2)
            color = self.get_color_for_segment(angle_deg, level, color_scheme)

            is_disabled = self.is_effectively_disabled(child, disabled_nodes)
            if is_disabled:
                color = self.darken_color(color)

            text_position = None
            if show_text:
                text_position = self._calculate_text_position(
                    current_angle, child_end_angle, inner_radius, outer_radius
                )

            segment = SunburstSegment(
                inner_radius=inner_radius,
                outer_radius=outer_radius,
                start_angle=current_angle,
                end_angle=child_end_angle,
                color=color,
                node=child,
                text=child.name if show_text else "",
                text_position=text_position,
                is_disabled=is_disabled,
            )

            segments.append(segment)

            self._build_segments_recursive(
                child,
                disabled_nodes,
                current_angle,
                child_end_angle,
                level + 1,
                geometry,
                color_scheme,
                segments,
            )

            current_angle = child_end_angle

    def _build_segments_recursive_normalized(
        self, node, start_angle, end_angle, start_absolute_depth, segments, disabled_nodes
    ):
        CENTER_HOLE_RADIUS, RING_WIDTH, MAX_DEPTH = 0.35, 0.25, 3
        total_value = node.value
        if total_value <= 0: return

        current_angle = start_angle

        children_to_display = aggregate_children_for_view(node, force_full_detail=(self.get_node_absolute_depth(node) > start_absolute_depth))

        for child in children_to_display:
            child_absolute_depth = self.get_node_absolute_depth(child)
            relative_depth = child_absolute_depth - start_absolute_depth

            if relative_depth <= 0 or relative_depth > MAX_DEPTH: continue

            outer_radius = CENTER_HOLE_RADIUS + relative_depth * RING_WIDTH
            sweep_angle = (child.value / total_value) * (end_angle - start_angle)
            mid_angle_deg = current_angle + sweep_angle / 2.0

            color = self.get_color_for_segment(mid_angle_deg, child_absolute_depth - 1, "default")
            is_disabled = self.is_effectively_disabled(child, disabled_nodes)

            segment = SunburstSegment(
                inner_radius=outer_radius - RING_WIDTH,
                outer_radius=outer_radius,
                start_angle=math.radians(current_angle),
                end_angle=math.radians(current_angle + sweep_angle),
                color=self.darken_color(color) if is_disabled else color,
                node=child,
                text=child.name,
                is_disabled=is_disabled,
            )
            segments.append(segment)

            if (
                (child.children or (hasattr(child, "aggregated_children") and child.aggregated_children))
                and getattr(child, 'date_level', None) != 'others'
            ):
                self._build_segments_recursive_normalized(
                    child, current_angle, current_angle + sweep_angle, start_absolute_depth, segments, disabled_nodes
                )

            current_angle += sweep_angle

    def _calculate_text_position(
        self,
        start_angle: float,
        end_angle: float,
        inner_radius: float,
        outer_radius: float,
    ) -> Tuple[float, float]:
        """Calculates text position in segment."""

        center_angle = (start_angle + end_angle) / 2

        center_radius = (inner_radius + outer_radius) / 2

        if self._current_geometry:
            x = self._current_geometry.center_x + center_radius * math.cos(center_angle)
            y = self._current_geometry.center_y + center_radius * math.sin(center_angle)
            return (x, y)

        return (0, 0)

    def get_color_for_segment(
        self, angle_deg: float, level: int, color_scheme: str = "default"
    ) -> str:
        """
        Calculates segment color based on angle and level.

        Args:
            angle_deg: Angle in degrees
            level: Level in tree (0 = root)
            color_scheme: Color scheme

        Returns:
            str: Color in hex format
        """
        if color_scheme == "default":
            return self._get_filelight_color(angle_deg, level)
        else:

            return self._get_filelight_color(angle_deg, level)

    def _get_filelight_color(self, angle_deg: float, level: int) -> str:
        """KDE Filelight style color algorithm."""
        from matplotlib.colors import hsv_to_rgb

        hue = (angle_deg % 360) / 360.0

        sats = [YEAR_SATURATION, MONTH_SATURATION, DAY_SATURATION]
        vals = [YEAR_BRIGHTNESS, MONTH_BRIGHTNESS, DAY_BRIGHTNESS]

        saturation = sats[min(level, len(sats) - 1)]
        value = vals[min(level, len(vals) - 1)]

        rgb = hsv_to_rgb((hue, saturation, value))

        return "#{:02x}{:02x}{:02x}".format(
            int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255)
        )

    def darken_color(self, color: str) -> str:
        """Darkens the color."""
        from matplotlib.colors import to_rgb

        try:
            rgb = to_rgb(color)
            darkened = tuple(c * DARKEN_FACTOR for c in rgb)
            return "#{:02x}{:02x}{:02x}".format(
                int(darkened[0] * 255), int(darkened[1] * 255), int(darkened[2] * 255)
            )
        except:
            return color

    def get_node_absolute_depth(self, node: TreeNode) -> int:
        """Calculates absolute depth of node in tree."""
        depth = 0
        current = node
        while current and current.parent:
            depth += 1
            current = current.parent
        return depth

    def get_max_relative_depth(self, node: TreeNode, current_depth: int = 0) -> int:
        """Calculates maximum relative depth of subtree."""
        children_to_scan = node.children[:]
        if hasattr(node, "aggregated_children") and node.aggregated_children:
            children_to_scan.extend(node.aggregated_children)

        if not children_to_scan:
            return current_depth

        return max(
            self.get_max_relative_depth(child, current_depth + 1)
            for child in children_to_scan
        )

    def get_descendant_day_nodes(self, node: TreeNode) -> List[TreeNode]:
        """Gets all child day nodes (leaves with numeric names)."""
        day_nodes = []

        def collect_day_nodes(current_node):

            children_to_check = current_node.children[:]
            if (
                hasattr(current_node, "aggregated_children")
                and current_node.aggregated_children
            ):
                children_to_check.extend(current_node.aggregated_children)

            if not children_to_check:

                if current_node.name.isdigit():
                    day_nodes.append(current_node)
            else:

                for child in children_to_check:
                    collect_day_nodes(child)

        collect_day_nodes(node)
        return day_nodes

    def is_effectively_disabled(
        self, node: TreeNode, disabled_nodes: Set[TreeNode]
    ) -> bool:
        """
        Checks if node is effectively disabled.

        A node is considered effectively disabled if:
        1. It itself is in disabled_nodes, OR
        2. All its child day nodes are disabled
        """
        if node in disabled_nodes:
            return True

        day_nodes = self.get_descendant_day_nodes(node)
        if not day_nodes:

            is_leaf_node = not node.children and not (
                hasattr(node, "aggregated_children") and node.aggregated_children
            )
            if is_leaf_node and node.name.isdigit():
                return node in disabled_nodes
            return False

        return all(day_node in disabled_nodes for day_node in day_nodes)

    def calculate_filtered_value(
        self, root_node: TreeNode, disabled_nodes: Set[TreeNode]
    ) -> float:
        """Calculates filtered value (sum of enabled nodes)."""
        day_nodes = self.get_descendant_day_nodes(root_node)

        if not day_nodes:

            return (
                0.0
                if self.is_effectively_disabled(root_node, disabled_nodes)
                else root_node.value
            )

        filtered_sum = sum(
            day_node.value for day_node in day_nodes if day_node not in disabled_nodes
        )

        return filtered_sum

    def _detect_unit_from_node(self, node: TreeNode) -> str:
        """Attempts to determine unit of measurement from tree."""

        if "token" in node.name.lower():
            return "tokens"
        else:
            return "chars"

    def find_segment_at_position(
        self, x: float, y: float, view_model: ChartViewModel
    ) -> Optional[SunburstSegment]:
        """
        Finds segment at specified position.

        Args:
            x: X coordinate
            y: Y coordinate
            view_model: ViewModel with segments

        Returns:
            Optional[SunburstSegment]: Found segment or None
        """

        dx = x - view_model.center_x
        dy = y - view_model.center_y
        radius = math.sqrt(dx * dx + dy * dy)

        if radius == 0:
            return None

        angle = math.atan2(dy, dx)

        if angle < 0:
            angle += 2 * math.pi

        for segment in view_model.segments:
            if (
                segment.inner_radius <= radius <= segment.outer_radius
                and segment.start_angle <= angle <= segment.end_angle
            ):
                return segment

        return None

    def get_segment_tooltip(self, segment: SunburstSegment, unit: str) -> str:
        """Creates tooltip text for segment."""
        value_text = f"{int(segment.node.value):,} {unit}"

        if segment.is_disabled:
            return f"{segment.node.name}: {value_text} (disabled)"
        else:
            return f"{segment.node.name}: {value_text}"

    def toggle_node_selection(
        self, node: TreeNode, disabled_nodes: Set[TreeNode]
    ) -> Set[TreeNode]:
        """
        Toggles node selection and returns new set of disabled nodes.

        Args:
            node: Node to toggle
            disabled_nodes: Current set of disabled nodes

        Returns:
            Set[TreeNode]: New set of disabled nodes
        """
        new_disabled = disabled_nodes.copy()

        if node in new_disabled:
            new_disabled.remove(node)
        else:
            new_disabled.add(node)

        return new_disabled

    def get_chart_statistics(self, view_model: ChartViewModel) -> Dict[str, Any]:
        """Returns chart statistics."""
        total_segments = len(view_model.segments)
        disabled_segments = sum(1 for s in view_model.segments if s.is_disabled)

        return {
            "total_segments": total_segments,
            "enabled_segments": total_segments - disabled_segments,
            "disabled_segments": disabled_segments,
            "total_value": view_model.center_value,
            "filtered_value": view_model.filtered_value,
            "filter_percentage": (
                (1 - view_model.filtered_value / view_model.center_value) * 100
                if view_model.center_value > 0
                else 0
            ),
        }


--- Файл: ./src/core/application/__init__.py ---



--- Файл: ./src/core/application/calendar_service.py ---
"""
Service for working with calendar and date filtering.
"""

import logging
from bisect import bisect_left
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional, Set, Tuple

from PyQt6.QtCore import QDate

from core.analysis.tree_analyzer import TreeNode

logger = logging.getLogger(__name__)

@dataclass
class DateHierarchy:
    """Date hierarchy for calendar."""
    messages_by_date: Dict[QDate, List[Dict[str, Any]]] = field(default_factory=lambda: defaultdict(list))
    months_with_messages: Set[Tuple[int, int]] = field(default_factory=set)
    years_with_messages: Set[int] = field(default_factory=set)
    sorted_months: List[Tuple[int, int]] = field(default_factory=list)
    sorted_years: List[int] = field(default_factory=list)
    date_to_node_map: Dict[QDate, TreeNode] = field(default_factory=dict)
    month_to_node_map: Dict[Tuple[int, int], TreeNode] = field(default_factory=dict)
    year_to_node_map: Dict[int, TreeNode] = field(default_factory=dict)

    def get_date_range(self) -> Tuple[Optional[QDate], Optional[QDate]]:
        if not self.messages_by_date: return None, None
        dates = list(self.messages_by_date.keys())
        return min(dates), max(dates)

class CalendarService:
    """Service for working with calendar."""
    def __init__(self):
        self._current_hierarchy: Optional[DateHierarchy] = None

    def build_date_hierarchy_from_raw_messages(
        self,
        raw_messages: List[Dict[str, Any]],
        analysis_tree: Optional[TreeNode] = None,
    ) -> DateHierarchy:
        """Builds date hierarchy based on raw messages."""
        hierarchy = DateHierarchy()
        self._process_raw_messages(raw_messages, hierarchy)
        if analysis_tree:
            self._build_node_lookup_maps(analysis_tree, hierarchy)
        self._current_hierarchy = hierarchy
        return hierarchy

    def _process_raw_messages(
        self, raw_messages: List[Dict[str, Any]], hierarchy: DateHierarchy
    ):
        """Processes raw messages and populates date hierarchy."""
        for msg in raw_messages:
            if msg.get("type") in ("message", "service") and "date" in msg:
                try:
                    dt = datetime.fromisoformat(msg["date"])
                    qdate = QDate(dt.year, dt.month, dt.day)
                    hierarchy.messages_by_date[qdate].append(msg)
                    hierarchy.months_with_messages.add((dt.year, dt.month))
                    hierarchy.years_with_messages.add(dt.year)
                except (ValueError, KeyError):
                    continue
        hierarchy.sorted_months = sorted(list(hierarchy.months_with_messages))
        hierarchy.sorted_years = sorted(list(hierarchy.years_with_messages))

    def _build_node_lookup_maps(self, root_node: TreeNode, hierarchy: DateHierarchy):
        """
        Builds maps for fast node lookup by dates.
        Expects numeric month names for proper mapping.
        """
        if not root_node: return

        for year_node in root_node.children:
            if len(year_node.name) == 4 and year_node.name.isdigit():
                year_val = int(year_node.name)
                hierarchy.year_to_node_map[year_val] = year_node
                for month_node in year_node.children:

                    if month_node.name.isdigit():
                        month_val = int(month_node.name)
                        month_key = (year_val, month_val)
                        hierarchy.month_to_node_map[month_key] = month_node
                        for day_node in month_node.children:
                            if day_node.name.isdigit():
                                day_val = int(day_node.name)
                                date_key = QDate(year_val, month_val, day_val)
                                hierarchy.date_to_node_map[date_key] = day_node

    def get_message_count_for_date(self, date: QDate, hierarchy: DateHierarchy) -> int:
        """Returns message count for specified date."""
        return len(hierarchy.messages_by_date.get(date, []))

    def has_messages_in_month(self, year: int, month: int, hierarchy: DateHierarchy) -> bool:
        """Checks if there are messages in specified month."""
        return (year, month) in hierarchy.months_with_messages

    def is_date_disabled_for_export(self, date: QDate, disabled_nodes: Set[TreeNode], hierarchy: DateHierarchy) -> bool:
        """Checks if date is disabled for export."""
        node = hierarchy.date_to_node_map.get(date)
        return node is not None and node in disabled_nodes

    def get_dates_in_month(self, year: int, month: int, hierarchy: DateHierarchy) -> List[QDate]:
        """Returns all dates with messages in specified month."""
        return [d for d in hierarchy.messages_by_date if d.year() == year and d.month() == month]

    def get_filtered_dates(self, disabled_nodes: Set[TreeNode], hierarchy: DateHierarchy) -> Set[QDate]:
        """Returns set of dates that are disabled."""
        return {d for d, node in hierarchy.date_to_node_map.items() if node in disabled_nodes}

    def find_adjacent_month(
        self,
        current_date: QDate,
        direction: int,
        hierarchy: DateHierarchy,
    ) -> Optional[QDate]:
        """Finds adjacent month with messages."""
        if not hierarchy.sorted_months: return None

        current_month_tuple = (current_date.year(), current_date.month())
        try:
            current_index = hierarchy.sorted_months.index(current_month_tuple)
        except ValueError:
            current_index = bisect_left(hierarchy.sorted_months, current_month_tuple)
            if direction < 0: current_index -= 1

        new_index = current_index + direction
        if 0 <= new_index < len(hierarchy.sorted_months):
            year, month = hierarchy.sorted_months[new_index]
            return QDate(year, month, 1)
        return None

    def find_adjacent_year(self, current_date: QDate, direction: int, hierarchy: DateHierarchy) -> Optional[QDate]:
        """Finds adjacent year with messages."""
        if not hierarchy.sorted_years: return None

        current_year = current_date.year()
        try:
            current_index = hierarchy.sorted_years.index(current_year)
        except ValueError:
            current_index = bisect_left(hierarchy.sorted_years, current_year)
            if direction < 0: current_index -= 1

        new_index = current_index + direction
        if 0 <= new_index < len(hierarchy.sorted_years):
            year = hierarchy.sorted_years[new_index]
            return QDate(year, 1, 1)
        return None


--- Файл: ./src/core/application/chat_service.py ---
"""
Service for working with chats.

Responsible for loading, parsing and validating chat data.
Does not depend on PyQt or other UI frameworks.
"""

import json
import logging
import os
from typing import Any, Dict, Optional

from core.domain.models import Chat
from core.parsing.json_parser import (
    get_parsing_statistics,
    parse_chat_from_dict,
    validate_chat_data,
)

logger = logging.getLogger(__name__)

class ChatLoadError(Exception):
    """Exception when chat loading error occurs."""

    pass

class ChatService:
    """Service for working with chats."""

    def __init__(self):
        self._current_chat: Optional[Chat] = None
        self._chat_file_path: Optional[str] = None

    def load_chat_from_file(self, file_path: str) -> Chat:
        """
        Loads chat from JSON file.

        Args:
            file_path: Path to JSON file

        Returns:
            Chat: Loaded and parsed chat

        Raises:
            ChatLoadError: On loading or parsing error
        """
        if not os.path.exists(file_path):
            raise ChatLoadError(f"File not found: {file_path}")

        if os.path.getsize(file_path) == 0:
            raise ChatLoadError(f"File is empty: {file_path}")

        try:
            with open(file_path, "r", encoding="utf-8") as f:
                raw_data = json.load(f)
        except json.JSONDecodeError as e:
            raise ChatLoadError(f"JSON parsing error: {e}")
        except (IOError, OSError) as e:
            raise ChatLoadError(f"File reading error: {e}")

        validation_issues = validate_chat_data(raw_data)
        if validation_issues:
            issues_str = "; ".join(validation_issues)
            raise ChatLoadError(f"Invalid chat data: {issues_str}")

        try:
            chat = parse_chat_from_dict(raw_data)
            self._current_chat = chat
            self._chat_file_path = file_path

            return chat

        except (ValueError, KeyError) as e:
            raise ChatLoadError(f"Chat parsing error: {e}")

    def get_current_chat(self) -> Optional[Chat]:
        """Returns currently loaded chat."""
        return self._current_chat

    def get_current_file_path(self) -> Optional[str]:
        """Returns path to current chat file."""
        return self._chat_file_path

    def has_chat_loaded(self) -> bool:
        """Checks if chat is loaded."""
        return self._current_chat is not None

    def clear_current_chat(self):
        """Clears current chat."""
        self._current_chat = None
        self._chat_file_path = None

    def get_chat_statistics(self, chat: Optional[Chat] = None) -> Dict[str, Any]:
        """
        Returns chat statistics.

        Args:
            chat: Chat to analyze. If None, current chat is used.

        Returns:
            Dict[str, Any]: Dictionary with statistics
        """
        target_chat = chat or self._current_chat
        if not target_chat:
            return {}

        users = target_chat.get_users()

        user_message_counts = {}
        for user in users:
            user_messages = target_chat.get_messages_by_user(user.id)
            user_message_counts[user.name] = len(user_messages)

        most_active_user = None
        if user_message_counts:
            most_active_user_name = max(
                user_message_counts, key=user_message_counts.get
            )
            most_active_user = next(
                (u for u in users if u.name == most_active_user_name), None
            )

        try:
            start_date, end_date = target_chat.get_date_range()
        except ValueError:
            start_date = end_date = None

        return {
            "chat_name": target_chat.name,
            "chat_type": target_chat.type,
            "total_messages": target_chat.total_message_count,
            "regular_messages": target_chat.message_count,
            "service_messages": target_chat.service_message_count,
            "unique_users": len(users),
            "user_message_counts": user_message_counts,
            "most_active_user": most_active_user.name if most_active_user else None,
            "date_range": {
                "start": start_date.isoformat() if start_date else None,
                "end": end_date.isoformat() if end_date else None,
            },
        }

    def validate_file_before_load(self, file_path: str) -> Dict[str, Any]:
        """
        Validates chat file without full loading.

        Args:
            file_path: Path to file for validation

        Returns:
            Dict[str, Any]: Validation result with file information
        """
        result = {
            "is_valid": False,
            "file_exists": False,
            "file_size": 0,
            "is_json": False,
            "parsing_stats": {},
            "issues": [],
        }

        if not os.path.exists(file_path):
            result["issues"].append("File not found")
            return result

        result["file_exists"] = True
        result["file_size"] = os.path.getsize(file_path)

        if result["file_size"] == 0:
            result["issues"].append("File is empty")
            return result

        try:
            with open(file_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            result["is_json"] = True
        except json.JSONDecodeError as e:
            result["issues"].append(f"Invalid JSON: {e}")
            return result
        except (IOError, OSError) as e:
            result["issues"].append(f"File reading error: {e}")
            return result

        validation_issues = validate_chat_data(data)
        if validation_issues:
            result["issues"].extend(validation_issues)
            return result

        try:
            result["parsing_stats"] = get_parsing_statistics(data)
            result["is_valid"] = True
        except Exception as e:
            result["issues"].append(f"Data analysis error: {e}")

    def detect_chat_type(self, chat: Optional[Chat] = None) -> str:
        """
        Detects chat type.

        Args:
            chat: Chat to analyze. If None, current chat is used.

        Returns:
            str: Chat type ('group', 'personal', 'posts', 'channel')
        """
        import logging
        logger = logging.getLogger("ChatService")

        target_chat = chat or self._current_chat
        if not target_chat:
            return "group"

        detected_type = target_chat.type
        return detected_type


--- Файл: ./src/core/application/analysis_service.py ---
"""
Service for chat analysis.

Responsible for counting tokens/characters, building analysis tree
and other chat analytics.
"""

import logging
from collections import defaultdict
from typing import Any, Dict, Optional

from core.analysis.tree_analyzer import TokenAnalyzer, TreeNode
from core.conversion.context import ConversionContext
from core.conversion.domain_adapters import chat_to_dict
from core.conversion.utils import process_text_to_plain
from core.domain.models import AnalysisResult, Chat, Message

logger = logging.getLogger(__name__)

class AnalysisService:
    """Service for chat analysis."""

    def __init__(self):
        pass

    def calculate_character_stats(
        self, chat: Chat, config: Dict[str, Any]
    ) -> AnalysisResult:
        """
        Calculates character statistics in chat.

        Args:
            chat: Chat to analyze
            config: Analysis configuration

        Returns:
            AnalysisResult: Analysis result with date hierarchy
        """
        if not chat.messages:
            return AnalysisResult(total_count=0, unit="Characters", date_hierarchy={})

        context = ConversionContext(config=config)
        date_hierarchy = defaultdict(lambda: defaultdict(lambda: defaultdict(float)))
        total_char_count = 0
        message_char_lengths = []

        for msg in chat.messages:
            if not isinstance(msg, Message):
                continue

            try:

                plain_text_msg = process_text_to_plain(msg.text, context)
                char_len = len(plain_text_msg)

                if char_len > 0:
                    year = str(msg.date.year)
                    month = f"{msg.date.month:02d}"
                    day = f"{msg.date.day:02d}"

                    date_hierarchy[year][month][day] += char_len
                    total_char_count += char_len
                    message_char_lengths.append(char_len)

            except (ValueError, AttributeError) as e:
                logger.warning(f"Error processing message {msg.id}: {e}")
                continue

        avg_message_length = (
            sum(message_char_lengths) / len(message_char_lengths)
            if message_char_lengths
            else 0
        )

        most_active_user = self._find_most_active_user(chat)

        return AnalysisResult(
            total_count=total_char_count,
            unit="Characters",
            date_hierarchy=dict(date_hierarchy),
            total_characters=total_char_count,
            average_message_length=avg_message_length,
            most_active_user=most_active_user,
        )

    def calculate_token_stats(
        self, chat: Chat, config: Dict[str, Any], tokenizer: Any
    ) -> AnalysisResult:
        """
        Calculates token statistics in chat.

        Args:
            chat: Chat to analyze
            config: Analysis configuration
            tokenizer: Tokenizer (e.g., from transformers)

        Returns:
            AnalysisResult: Analysis result with date hierarchy
        """
        if not chat.messages or not tokenizer:
            return AnalysisResult(total_count=0, unit="tokens", date_hierarchy={})

        chat_dict = chat_to_dict(chat)
        from core.conversion.main_converter import generate_plain_text

        plain_text = generate_plain_text(chat_dict, config, html_mode=False)

        try:
            total_tokens = len(tokenizer.encode(plain_text))
        except Exception as e:
            logger.error(f"Error tokenizing: {e}")
            return AnalysisResult(total_count=0, unit="tokens", date_hierarchy={})

        if total_tokens <= 0:
            return AnalysisResult(total_count=0, unit="tokens", date_hierarchy={})

        context = ConversionContext(config=config)
        message_char_lengths = []
        total_char_count = 0

        for msg in chat.messages:
            if not isinstance(msg, Message):
                continue

            try:
                plain_text_msg = process_text_to_plain(msg.text, context)
                char_len = len(plain_text_msg)
                if char_len > 0:
                    message_char_lengths.append({"date": msg.date, "length": char_len})
                    total_char_count += char_len
            except Exception as e:
                logger.warning(f"Error processing message {msg.id}: {e}")
                continue

        if total_char_count == 0:
            return AnalysisResult(
                total_count=total_tokens, unit="tokens", date_hierarchy={}
            )

        tokens_per_char = total_tokens / total_char_count
        date_hierarchy = defaultdict(lambda: defaultdict(lambda: defaultdict(float)))

        for item in message_char_lengths:
            dt = item["date"]
            year = str(dt.year)
            month = f"{dt.month:02d}"
            day = f"{dt.day:02d}"
            estimated_tokens = item["length"] * tokens_per_char
            date_hierarchy[year][month][day] += estimated_tokens

        most_active_user = self._find_most_active_user(chat)

        return AnalysisResult(
            total_count=total_tokens,
            unit="tokens",
            date_hierarchy=dict(date_hierarchy),
            total_characters=total_char_count,
            most_active_user=most_active_user,
        )

    def build_analysis_tree(
        self, analysis_result: AnalysisResult, config: Dict[str, Any]
    ) -> TreeNode:
        """
        Builds analysis tree based on analysis result.

        Args:
            analysis_result: Analysis result with date hierarchy
            config: Configuration for tree building

        Returns:
            TreeNode: Root node of the analysis tree
        """
        if not analysis_result.date_hierarchy or analysis_result.total_count <= 0:
            from resources.translations import tr

            return TreeNode(tr("No Data"), 0)

        try:
            analyzer = TokenAnalyzer(
                date_hierarchy=analysis_result.date_hierarchy,
                config=config,
                unit=analysis_result.unit,
            )

            return analyzer.build_analysis_tree(total_count=analysis_result.total_count)

        except Exception as e:
            logger.error(f"Error building analysis tree: {e}")
            from resources.translations import tr

            return TreeNode(tr("Error"), 0)

    def _find_most_active_user(self, chat: Chat) -> Optional[Any]:
        """
        Finds the most active user in the chat.

        Args:
            chat: Chat to analyze

        Returns:
            Optional[User]: The most active user or None
        """
        if not chat.messages:
            return None

        user_message_counts = {}

        for msg in chat.messages:
            if isinstance(msg, Message):
                user_id = msg.author.id
                if user_id in user_message_counts:
                    user_message_counts[user_id]["count"] += 1
                else:
                    user_message_counts[user_id] = {"count": 1, "user": msg.author}

        if not user_message_counts:
            return None

        most_active_data = max(user_message_counts.values(), key=lambda x: x["count"])
        return most_active_data["user"]

    def get_chat_summary(self, chat: Chat) -> Dict[str, Any]:
        """
        Returns a brief chat summary.

        Args:
            chat: Chat to analyze

        Returns:
            Dict[str, Any]: Summary with main metrics
        """
        if not chat.messages:
            return {
                "total_messages": 0,
                "regular_messages": 0,
                "service_messages": 0,
                "unique_users": 0,
                "date_range": None,
                "most_active_user": None,
            }

        regular_messages = [msg for msg in chat.messages if isinstance(msg, Message)]
        service_messages = [
            msg for msg in chat.messages if not isinstance(msg, Message)
        ]

        users = chat.get_users()
        most_active_user = self._find_most_active_user(chat)

        try:
            start_date, end_date = chat.get_date_range()
            date_range = {
                "start": start_date,
                "end": end_date,
                "duration_days": (end_date - start_date).days,
            }
        except ValueError:
            date_range = None

        return {
            "total_messages": len(chat.messages),
            "regular_messages": len(regular_messages),
            "service_messages": len(service_messages),
            "unique_users": len(users),
            "date_range": date_range,
            "most_active_user": most_active_user.name if most_active_user else None,
        }

    def calculate_user_activity(self, chat: Chat) -> Dict[str, Dict[str, Any]]:
        """
        Calculates user activity statistics.

        Args:
            chat: Chat to analyze

        Returns:
            Dict[str, Dict[str, Any]]: Statistics by users
        """
        user_stats = {}

        for msg in chat.messages:
            if not isinstance(msg, Message):
                continue

            user_id = msg.author.id
            user_name = msg.author.name

            if user_id not in user_stats:
                user_stats[user_id] = {
                    "name": user_name,
                    "message_count": 0,
                    "character_count": 0,
                    "reaction_count": 0,
                    "first_message": None,
                    "last_message": None,
                }

            stats = user_stats[user_id]
            stats["message_count"] += 1

            if isinstance(msg.text, str):
                stats["character_count"] += len(msg.text)

            stats["reaction_count"] += len(msg.reactions)

            if stats["first_message"] is None or msg.date < stats["first_message"]:
                stats["first_message"] = msg.date
            if stats["last_message"] is None or msg.date > stats["last_message"]:
                stats["last_message"] = msg.date

        return user_stats

    def get_daily_activity(self, chat: Chat) -> Dict[str, int]:
        """
        Returns activity by day.

        Args:
            chat: Chat to analyze

        Returns:
            Dict[str, int]: Dictionary day -> number of messages
        """
        daily_counts = defaultdict(int)

        for msg in chat.messages:
            if isinstance(msg, Message):
                date_str = msg.date.strftime("%Y-%m-%d")
                daily_counts[date_str] += 1

        return dict(daily_counts)

    def get_hourly_activity(self, chat: Chat) -> Dict[int, int]:
        """
        Returns activity by hours of the day.

        Args:
            chat: Chat to analyze

        Returns:
            Dict[int, int]: Dictionary hour (0-23) -> number of messages
        """
        hourly_counts = defaultdict(int)

        for msg in chat.messages:
            if isinstance(msg, Message):
                hour = msg.date.hour
                hourly_counts[hour] += 1

        return dict(hourly_counts)


--- Файл: ./src/core/application/tokenizer_service.py ---
"""
Service for managing tokenizers.

Responsible for loading, caching and managing tokenizers
from Hugging Face without direct dependency on PyQt.
"""

import importlib.util
import logging
from typing import Any, Callable, Dict, Optional

logger = logging.getLogger(__name__)

TRANSFORMERS_AVAILABLE = importlib.util.find_spec("transformers") is not None

class TokenizerError(Exception):
    """Exception when working with tokenizer."""

    pass

class TokenizerService:
    """Service for managing tokenizers."""

    def __init__(self):
        self._current_tokenizer: Optional[Any] = None
        self._current_model_name: Optional[str] = None
        self._default_model = "google/gemma-2b"

    def is_transformers_available(self) -> bool:
        """Checks if transformers libraries are available."""
        return TRANSFORMERS_AVAILABLE

    def load_tokenizer(
        self,
        model_name: str,
        local_only: bool = True,
        progress_callback: Optional[Callable[[str], None]] = None,
    ) -> Any:
        """
        Loads tokenizer.

        Args:
            model_name: Model name to load
            local_only: Use only local files
            progress_callback: Function for progress reporting

        Returns:
            Any: Loaded tokenizer

        Raises:
            TokenizerError: On loading error
        """
        if not TRANSFORMERS_AVAILABLE:
            raise TokenizerError("Transformers library is not installed")

        try:
            if progress_callback:
                progress_callback(f"Loading tokenizer {model_name}...")

            from transformers import AutoTokenizer

            if local_only:

                tokenizer = AutoTokenizer.from_pretrained(
                    model_name, local_files_only=True
                )
            else:

                tokenizer = AutoTokenizer.from_pretrained(model_name)

            self._current_tokenizer = tokenizer
            self._current_model_name = model_name

            if progress_callback:
                progress_callback(f"Tokenizer {model_name} loaded successfully")

            return tokenizer

        except OSError as e:
            if "not found" in str(e).lower():
                raise TokenizerError(f"Model {model_name} not found in local cache")
            else:
                raise TokenizerError(f"Error loading tokenizer: {e}")
        except Exception as e:
            raise TokenizerError(f"Unexpected error: {e}")

    def load_default_tokenizer(
        self, progress_callback: Optional[Callable[[str], None]] = None
    ) -> Optional[Any]:
        """
        Loads default tokenizer STRICTLY from local cache.
        Does NOT attempt to download model from internet.

        Args:
            progress_callback: Function for progress reporting

        Returns:
            Optional[Any]: Tokenizer or None if failed to load
        """
        if not TRANSFORMERS_AVAILABLE:
            if progress_callback:
                progress_callback("Transformers library not found")
            return None

        cache_info = self.check_model_cache(self._default_model)
        if not cache_info.get("available", False):
            if progress_callback:
                progress_callback(f"Model {self._default_model} not found in cache")
            return None

        try:
            return self.load_tokenizer(
                self._default_model,
                local_only=True,
                progress_callback=progress_callback,
            )
        except TokenizerError as e:
            if progress_callback:
                progress_callback(f"Failed to load tokenizer from cache: {e}")
            return None

    def get_current_tokenizer(self) -> Optional[Any]:
        """Returns the currently loaded tokenizer."""
        return self._current_tokenizer

    def get_current_model_name(self) -> Optional[str]:
        """Returns the name of the current model."""
        return self._current_model_name

    def has_tokenizer_loaded(self) -> bool:
        """Checks if tokenizer is loaded."""
        return self._current_tokenizer is not None

    def is_tokenizer_loaded(self) -> bool:
        """Alias for has_tokenizer_loaded method."""
        return self.has_tokenizer_loaded()

    def unload_tokenizer(self):
        """Unloads the current tokenizer."""
        self._current_tokenizer = None
        self._current_model_name = None

    def get_tokenizer_info(self) -> Dict[str, Any]:
        """
        Returns information about the current tokenizer.

        Returns:
            Dict[str, Any]: Information about the tokenizer
        """
        if not self._current_tokenizer:
            return {
                "loaded": False,
                "model_name": None,
                "vocab_size": None,
                "model_max_length": None,
            }

        try:
            vocab_size = getattr(self._current_tokenizer, "vocab_size", None)
            model_max_length = getattr(
                self._current_tokenizer, "model_max_length", None
            )

            return {
                "loaded": True,
                "model_name": self._current_model_name,
                "vocab_size": vocab_size,
                "model_max_length": model_max_length,
            }
        except Exception as e:
            logger.warning(f"Error getting tokenizer info: {e}")
            return {
                "loaded": True,
                "model_name": self._current_model_name,
                "vocab_size": None,
                "model_max_length": None,
                "error": str(e),
            }

    def tokenize_text(self, text: str) -> int:
        """
        Tokenizes text and returns the number of tokens.

        Args:
            text: Text to tokenize

        Returns:
            int: Number of tokens

        Raises:
            TokenizerError: If tokenizer is not loaded
        """
        if not self._current_tokenizer:
            raise TokenizerError("Tokenizer not loaded")

        try:
            tokens = self._current_tokenizer.encode(text)
            return len(tokens)
        except Exception as e:
            raise TokenizerError(f"Tokenization error: {e}")

    def get_available_models(self) -> list[str]:
        """
        Returns a list of available models.

        Returns:
            list[str]: List of model names
        """

        return [
            "google/gemma-2b",
            "microsoft/DialoGPT-medium",
            "openai-gpt",
            "gpt2",
            "facebook/opt-125m",
            "EleutherAI/gpt-neo-125M",
        ]

    def get_default_model_name(self) -> str:
        """Returns the default model name."""
        return self._default_model

    def set_default_model(self, model_name: str):
        """
        Sets the default model.

        Args:
            model_name: Model name
        """
        self._default_model = model_name

    def check_model_cache(self, model_name: str) -> Dict[str, Any]:
        """
        Checks if a model exists in the local cache.

        Args:
            model_name: Model name to check

        Returns:
            Dict[str, Any]: Information about model availability in cache
        """
        if not TRANSFORMERS_AVAILABLE:
            return {"available": False, "reason": "transformers not installed"}

        try:

            from huggingface_hub import scan_cache_dir

            try:
                hf_cache_info = scan_cache_dir()

                repo_info = next(
                    (
                        repo
                        for repo in hf_cache_info.repos
                        if repo.repo_id == model_name
                    ),
                    None,
                )

                if repo_info:
                    return {
                        "available": True,
                        "model_name": model_name,
                        "cache_size": len(repo_info.revisions),
                    }
                else:
                    return {"available": False, "reason": "not in cache"}

            except Exception:

                from transformers import AutoTokenizer

                tokenizer = AutoTokenizer.from_pretrained(
                    model_name, local_files_only=True
                )

                return {
                    "available": True,
                    "model_name": model_name,
                    "vocab_size": getattr(tokenizer, "vocab_size", None),
                }

        except OSError:
            return {"available": False, "reason": "not in cache"}
        except Exception as e:
            return {"available": False, "reason": f"error: {e}"}

    def clear_cache_info(self, model_name: str) -> Dict[str, Any]:
        """
        Gets information for clearing model cache.

        Args:
            model_name: Model name

        Returns:
            Dict[str, Any]: Information for clearing cache
        """
        try:
            from huggingface_hub import scan_cache_dir

            hf_cache_info = scan_cache_dir()

            repo_info = next(
                (repo for repo in hf_cache_info.repos if repo.repo_id == model_name),
                None,
            )

            if not repo_info:
                return {"found": False, "message": "Model not found in cache"}

            revisions_to_delete = {rev.commit_hash for rev in repo_info.revisions}
            delete_strategy = hf_cache_info.delete_revisions(*revisions_to_delete)

            return {
                "found": True,
                "model_name": model_name,
                "size_to_free": delete_strategy.expected_freed_size_str,
                "revisions_count": len(revisions_to_delete),
            }

        except ImportError:
            return {"found": False, "error": "huggingface_hub not installed"}
        except Exception as e:
            return {"found": False, "error": str(e)}


--- Файл: ./src/core/application/conversion_service.py ---
"""
Service for converting chats to text format.

Handles conversion of domain chat objects to readable text
using configured formatters and conversion strategies.
"""

import logging
from typing import Any, Dict, Optional, Set

from core.analysis.tree_analyzer import TreeNode
from core.conversion.context import ConversionContext
from core.conversion.domain_adapters import (
    chat_to_dict,
    create_message_map,
    detect_user_ids_for_personal_chat,
    get_main_post_id,
)
from core.conversion.formatters.service_formatter import format_service_message
from core.conversion.main_converter import generate_plain_text
from core.conversion.message_formatter import format_message
from core.domain.models import Chat, Message, ServiceMessage

logger = logging.getLogger(__name__)

class ConversionService:
    """Service for converting chats to text."""

    def __init__(self, use_modern_formatters: bool = True):
        """
        Initializes conversion service.

        Args:
            use_modern_formatters: Use modern formatters (True)
                                 or old ones via domain_adapters (False)
        """
        self._use_modern_formatters = use_modern_formatters
        self._modern_converter = None

        if use_modern_formatters:
            try:
                from core.conversion.formatters.modern.main_converter import (
                    ModernChatConverter,
                )
                self._modern_converter = ModernChatConverter()

            except ImportError as e:
                logger.warning(f"ConversionService: Modern formatters not available, falling back to legacy: {e}")
                self._use_modern_formatters = False

    def convert_to_text(
        self,
        chat: Chat,
        config: Dict[str, Any],
        html_mode: bool = False,
        disabled_nodes: Optional[Set[TreeNode]] = None,
    ) -> str:
        """
        Converts chat to text format.

        Args:
            chat: Chat to convert
            config: Conversion configuration
            html_mode: HTML generation mode (for preview)
            disabled_nodes: Set of disabled TreeNode objects (for date filtering)

        Returns:
            str: Converted text
        """
        if not chat.messages:
            return ""

        if self._use_modern_formatters and self._modern_converter:

            return self._modern_converter.convert_to_text(
                chat, config, html_mode=html_mode, disabled_nodes=disabled_nodes
            )
        else:
            chat_dict = chat_to_dict(chat)
            return generate_plain_text(
                chat_dict, config, html_mode=html_mode, disabled_nodes=disabled_nodes
            )

    def convert_message_to_text(
        self,
        message: Message,
        previous_message: Optional[Message],
        config: Dict[str, Any],
        chat: Chat,
        html_mode: bool = False,
    ) -> str:
        """
        Converts individual message to text.

        Args:
            message: Message to convert
            previous_message: Previous message (for context)
            config: Conversion configuration
            chat: Chat that the message belongs to
            html_mode: HTML generation mode

        Returns:
            str: Converted message text
        """

        context = self._create_conversion_context(chat, config)

        from core.conversion.domain_adapters import message_to_dict

        msg_dict = message_to_dict(message)
        prev_msg_dict = message_to_dict(previous_message) if previous_message else None

        return format_message(msg_dict, prev_msg_dict, context, html_mode)

    def convert_service_message_to_text(
        self, service_message: ServiceMessage, config: Dict[str, Any], chat: Chat
    ) -> str:
        """
        Converts service message to text.

        Args:
            service_message: Service message
            config: Conversion configuration
            chat: Chat that the message belongs to

        Returns:
            str: Converted text or empty string if not to be shown
        """
        context = self._create_conversion_context(chat, config)

        from core.conversion.domain_adapters import service_message_to_dict

        service_dict = service_message_to_dict(service_message)

        result = format_service_message(service_dict, context)
        return result or ""

    def generate_preview(self, config: Dict[str, Any]) -> tuple[str, str]:
        """
        Generates preview for given configuration.

        Args:
            config: Configuration for preview

        Returns:
            tuple[str, str]: (html_text, preview_title)
        """

        from resources.translations import tr
        return f"<p>{tr('Preview is generated from loaded chat.')}</p>", tr("Preview")

    def _create_conversion_context(
        self, chat: Chat, config: Dict[str, Any]
    ) -> ConversionContext:
        """
        Creates conversion context for chat.

        Args:
            chat: Chat
            config: Configuration

        Returns:
            ConversionContext: Context for formatters
        """

        message_map = create_message_map(chat)

        main_post_id = get_main_post_id(chat)
        my_id, partner_id = detect_user_ids_for_personal_chat(chat)

        context = ConversionContext(config=config)
        context.message_map = message_map

        if main_post_id:
            context.main_post_id = main_post_id

        if my_id:
            context.my_id = my_id
        if partner_id:
            context.partner_id = partner_id

        return context

    def get_supported_profiles(self) -> list[str]:
        """Returns list of supported conversion profiles."""
        return ["group", "personal", "posts", "channel"]

    def validate_config(self, config: Dict[str, Any]) -> list[str]:
        """
        Validates conversion configuration.

        Args:
            config: Configuration to check

        Returns:
            list[str]: List of found issues
        """
        issues = []

        required_fields = ["profile", "show_time", "show_reactions"]
        for field in required_fields:
            if field not in config:
                issues.append(f"Missing required field: {field}")

        profile = config.get("profile")
        if profile not in self.get_supported_profiles():
            issues.append(f"Unsupported profile: {profile}")

        boolean_fields = [
            "show_time",
            "show_reactions",
            "show_reaction_authors",
            "show_optimization",
            "show_markdown",
            "show_links",
            "show_tech_info",
            "show_service_notifications",
        ]
        for field in boolean_fields:
            if field in config and not isinstance(config[field], bool):
                issues.append(f"Field {field} must be boolean")

        string_fields = ["my_name", "partner_name", "streak_break_time"]
        for field in string_fields:
            if field in config and not isinstance(config[field], str):
                issues.append(f"Field {field} must be string")

        streak_time = config.get("streak_break_time", "")
        if streak_time:
            import re

            if not re.match(r"^\d{1,2}:\d{2}$", streak_time):
                issues.append("Field streak_break_time must be in HH:MM format")

        return issues

    def get_default_config(self) -> Dict[str, Any]:
        """Returns default configuration."""
        return {
            "profile": "group",
            "show_time": True,
            "show_reactions": True,
            "show_reaction_authors": False,
            "my_name": "Me",
            "partner_name": "Partner",
            "show_optimization": False,
            "streak_break_time": "20:00",
            "show_markdown": True,
            "show_links": True,
            "show_tech_info": True,
            "show_service_notifications": True,
        }



--- Файл: ./src/core/dependency_injection.py ---
"""
Simple DI container for dependency management.

Provides centralized service registration and resolution
for dependency injection pattern implementation.
"""

import logging
from typing import Any, Callable, Dict, Type, TypeVar

logger = logging.getLogger(__name__)

T = TypeVar("T")

class DIContainer:
    """Simple container for Dependency Injection."""

    def __init__(self):
        self._singletons: Dict[Type, Any] = {}
        self._factories: Dict[Type, Callable[[], Any]] = {}
        self._transients: Dict[Type, Callable[[], Any]] = {}

    def register_singleton(self, interface: Type[T], factory: Callable[[], T]) -> None:
        """Registers service as singleton."""
        self._factories[interface] = factory

    def register_transient(self, interface: Type[T], factory: Callable[[], T]) -> None:
        """Registers service as transient (new instance each time)."""
        self._transients[interface] = factory

    def get(self, interface: Type[T]) -> T:
        """Gets service instance."""

        if interface in self._singletons:
            return self._singletons[interface]

        if interface in self._factories:
            instance = self._factories[interface]()
            self._singletons[interface] = instance
            return instance

        if interface in self._transients:
            instance = self._transients[interface]()
            return instance

        raise ValueError(f"Service {interface.__name__} not registered")

    def clear(self) -> None:
        """Clears all registered services."""
        self._singletons.clear()
        self._factories.clear()
        self._transients.clear()

_container = DIContainer()

def get_container() -> DIContainer:
    """Returns global DI container."""
    return _container

def setup_container() -> DIContainer:
    """Sets up DI container with basic services."""
    from core.application.analysis_service import AnalysisService
    from core.application.chat_service import ChatService
    from core.application.conversion_service import ConversionService
    from core.application.tokenizer_service import TokenizerService

    container = get_container()

    container.register_singleton(ChatService, lambda: ChatService())
    container.register_singleton(
        ConversionService, lambda: ConversionService(use_modern_formatters=False)
    )
    container.register_singleton(AnalysisService, lambda: AnalysisService())
    container.register_singleton(TokenizerService, lambda: TokenizerService())

    return container


--- Файл: ./src/todo.txt ---
Исправить сохранялку текста(нужно чтобы один раз проверялось наличие, а не циклично)
Исправить изменение размера шрифта в графике(сейчас ограничение не работает, "количество токенов" выпадает за свою область)
Придумать как сделать дистрибьюцию на арч, шинду и флатпак
Улучшить автоматический чек при активации режима(сейчас при первой загрузке он не работает, не подсчитывает токены)
Улучшить архитектуру, разбить презентер, улучшить менеджеры, разбить вещи на микросервисы(кажется что у функции сохранения этого разбития нет)

--- Файл: ./src/utils/__init__.py ---



--- Файл: ./src/utils/paths.py ---
import logging
import sys
from pathlib import Path

paths_logger = logging.getLogger("Paths")
paths_logger.setLevel(logging.WARNING)

def resource_path(relative_path: str) -> str:
    try:

        base_path = Path(sys._MEIPASS)
    except Exception:

        base_path = Path(__file__).resolve().parent.parent

    full_path = base_path / relative_path

    if full_path.exists():
        pass
    else:
        paths_logger.warning(f"Resource NOT found: {full_path}")

    return str(full_path)


--- Файл: ./src/utils/file_utils.py ---
"""
File utilities.
"""

import os
import re

def get_unique_filepath(directory: str, base_name: str, extension: str) -> str:
    """
    Generates unique filename in specified directory more efficiently.

    If file with such name already exists, adds or increments a counter in brackets.
    """
    base_name = os.path.splitext(base_name)[0]
    full_path = os.path.join(directory, f"{base_name}{extension}")

    if not os.path.exists(full_path):
        return full_path

    match = re.match(r"^(.*?) \((\d+)\)$", base_name)
    if match:
        clean_base = match.group(1)
        counter = int(match.group(2)) + 1
    else:
        clean_base = base_name
        counter = 1

    while True:
        new_name = f"{clean_base} ({counter})"
        new_path = os.path.join(directory, f"{new_name}{extension}")
        if not os.path.exists(new_path):
            return new_path
        counter += 1


--- Файл: ./src/presenters/task_manager.py ---


from PyQt6.QtCore import QObject, pyqtSignal, QThreadPool

class CancellableTaskManager(QObject):
    """
    Управляет запуском и отменой одного типа фоновых задач,
    гарантируя, что выполняется только самая последняя.
    """

    progress = pyqtSignal(str)
    finished = pyqtSignal(bool, str, object)

    def __init__(self, worker_class, parent=None):
        super().__init__(parent)
        self._worker_class = worker_class
        self._current_worker = None
        self._pending_args = None
        self._threadpool = QThreadPool.globalInstance()

    def submit(self, *args, **kwargs):
        """
        Запускает новую задачу, отменяя любую предыдущую.
        """

        if self._current_worker:
            self._current_worker.cancel()

        self._pending_args = (args, kwargs)

        if not self._current_worker:
            self._start_pending_task()

    def _start_pending_task(self):
        """Запускает ожидающую задачу, если она есть."""
        if self._pending_args is None:
            return

        args, kwargs = self._pending_args
        self._pending_args = None

        self._current_worker = self._worker_class(*args, **kwargs)
        self._current_worker.signals.progress.connect(self.progress)
        self._current_worker.signals.finished.connect(self._on_worker_finished)
        self._threadpool.start(self._current_worker)

    def _on_worker_finished(self, success, message, result):
        """Слот, вызываемый по завершении воркера."""

        if message != "Cancelled":
            self.finished.emit(success, message, result)

        self._current_worker = None

        if self._pending_args:
            self._start_pending_task()


--- Файл: ./src/presenters/config_presenter.py ---
import logging
from typing import Any

from PyQt6.QtCore import QObject, pyqtSignal

from presenters.app_state import AppState

logger = logging.getLogger(__name__)

class ConfigPresenter(QObject):
    """Presenter for managing configuration panel (Profile, Names, Options)."""

    config_changed = pyqtSignal(str, object)
    profile_auto_detected = pyqtSignal(str)
    analysis_unit_changed = pyqtSignal(str)
    preview_updated = pyqtSignal(str, str)

    def __init__(self, view, app_state: AppState, preview_service):
        super().__init__()
        self._view = view
        self._app_state = app_state
        self._preview_service = preview_service

        self._connect_signals()

    def _connect_signals(self):
        """Connects UI signals to presenter methods."""
        self._view.config_changed.connect(self.on_config_changed)

    def on_config_changed(self, key: str, value: Any):
        """Handles configuration changes."""
        old_value = self._app_state.get_config_value(key)

        if old_value != value:
            had_analysis_data_before = self._app_state.has_analysis_data()

            self._app_state.set_config_value(key, value)

            self.config_changed.emit(key, value)

            if not self._app_state.has_analysis_data():
                if had_analysis_data_before:
                    unit = self._app_state.get_preferred_analysis_unit()
                    if unit == "tokens":
                        self._view.show_status(message_key="Tokens reset", is_status=True)
                    else:
                        self._view.show_status(message_key="Characters reset", is_status=True)

            if key not in ["disabled_nodes"]:
                self._update_preview()

            if (self._app_state.get_config_value("auto_recalc", False) and
                self._app_state.has_chat_loaded() and
                not self._app_state.is_processing and
                key not in ["auto_detect_profile", "auto_recalc", "disabled_nodes"]):

                self.config_changed.emit("auto_recalc_triggered", True)

    def _update_preview(self):
        """Updates preview when configuration changes."""
        try:
            config = self._app_state.ui_config
            raw_text, title = self._preview_service.generate_preview_text(config)
            self.preview_updated.emit(raw_text, title)
        except Exception as e:
            logger.error(f"Error updating preview: {e}")
            error_message = f"Error: {e}"
            self.preview_updated.emit(error_message, "Preview Error")

    def handle_profile_auto_detection(self, detected_profile: str):
        """Handles automatic profile detection."""
        current_profile = self._app_state.get_config_value("profile")

        if detected_profile != current_profile:
            self._app_state.set_config_value("profile", detected_profile)
            self.profile_auto_detected.emit(detected_profile)
            self._update_preview()

    def get_config(self) -> dict:
        """Returns a copy of the current configuration."""
        return self._app_state.ui_config.copy()

    def get_config_value(self, key: str) -> Any:
        """Returns a specific configuration value."""
        return self._app_state.get_config_value(key)

    def set_config_value(self, key: str, value: Any):
        """Sets a specific configuration value."""
        self._app_state.set_config_value(key, value)
        self.config_changed.emit(key, value)


--- Файл: ./src/presenters/__init__.py ---



--- Файл: ./src/presenters/preview_service.py ---
import logging
from typing import Dict, Any

from core.conversion.main_converter import generate_plain_text
from resources.translations import tr

logger = logging.getLogger(__name__)

class PreviewService:
    """Service for generating preview data and HTML."""

    def __init__(self):
        self.logger = logging.getLogger("Preview")
        self.logger.setLevel(logging.ERROR)

        if not self.logger.handlers:
            formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                datefmt='%H:%M:%S'
            )

            console_handler = logging.StreamHandler()
            console_handler.setLevel(logging.ERROR)
            console_handler.setFormatter(formatter)

            self.logger.addHandler(console_handler)

    def generate_preview_data(self, config: dict) -> dict:
        """Generates hardcoded preview data based on configuration."""
        profile = config.get("profile", "group")

        my_name = config.get("my_name", tr("Me"))
        partner_name = config.get("partner_name", tr("Sister"))

        if profile == "group":
            preview_data = {
                "name": tr("Preview: Example Group"),
                "messages": [
                    {
                        "id": 1,
                        "type": "service",
                        "action": "create_group",
                        "actor": tr("Preview: Alaisa"),
                        "title": tr("Preview: Example Group"),
                        "members": [
                            tr("Preview: Alaisa"),
                            tr("Preview: Alice"),
                            tr("Preview: Bob"),
                        ],
                        "date": "2025-04-02T23:57:00",
                    },
                    {
                        "id": 2,
                        "type": "message",
                        "from": tr("Preview: Bob"),
                        "from_id": "user_bob",
                        "date": "2025-04-02T23:58:00",
                        "text": tr("Preview: Hello everyone!"),
                        "reactions": [
                            {
                                "emoji": "👍",
                                "count": 1,
                                "recent": [
                                    {"from": tr("Preview: Alice"), "from_id": "user_alice"}
                                ],
                            }
                        ],
                    },
                    {
                        "id": 3,
                        "type": "message",
                        "from": tr("Preview: Alice"),
                        "from_id": "user_alice",
                        "date": "2025-04-02T23:59:00",
                        "edited": "2025-04-02T23:59:30",
                        "text": [{"type": "italic", "text": tr("Preview: One moment")}],
                    },
                    {
                        "id": 4,
                        "type": "service",
                        "action": "invite_members",
                        "actor": tr("Preview: Alice"),
                        "members": [tr("Preview: Alexander")],
                        "date": "2025-04-02T23:59:50",
                    },
                    {
                        "id": 5,
                        "type": "message",
                        "from": tr("Preview: Alexander"),
                        "from_id": "user_alex",
                        "date": "2025-04-03T00:01:00",
                        "reply_to_message_id": 3,
                        "text": tr("Preview: Thanks"),
                        "media_type": "sticker",
                        "sticker_emoji": "❤",
                        "reactions": [
                            {
                                "emoji": "💯",
                                "count": 1,
                                "recent": [
                                    {"from": tr("Preview: Bob"), "from_id": "user_bob"}
                                ],
                            },
                            {
                                "emoji": "🔥",
                                "count": 2,
                                "recent": [
                                    {"from": tr("Preview: Alice"), "from_id": "user_alice"},
                                    {"from": tr("Preview: Bob"), "from_id": "user_bob"},
                                ],
                            },
                        ],
                    },
                ],
            }

        elif profile == "personal":
            real_my_name = tr("Preview: Misha")
            real_partner_name = tr("Preview: Alice")

            my_alias = config.get("my_name", tr("Me"))
            partner_alias = config.get("partner_name", tr("Sister"))

            preview_data = {
                "name": "Alice",
                "messages": [
                    {
                        "id": 1,
                        "type": "service",
                        "action": "set_messages_ttl",
                        "actor": partner_alias,
                        "period_seconds": 0,
                        "date": "2024-12-31T23:57:00",
                    },
                    {
                        "id": 2,
                        "type": "message",
                        "from": real_my_name,
                        "from_id": "user_misha",
                        "date": "2024-12-31T23:58:00",
                        "text": tr("Preview: Almost midnight..."),
                        "reactions": [
                            {
                                "emoji": "❤️",
                                "count": 1,
                                "recent": [
                                    {"from": partner_alias, "from_id": "user_alice"}
                                ],
                            }
                        ],
                    },
                    {
                        "id": 3,
                        "type": "message",
                        "from": real_partner_name,
                        "from_id": "user_alice",
                        "date": "2025-01-01T00:01:00",
                        "text": tr("Preview: Happy New Year!"),
                        "reactions": [
                            {
                                "emoji": "🔥",
                                "count": 1,
                                "recent": [{"from": my_alias, "from_id": "user_misha"}],
                            }
                        ],
                    },
                ],
            }

        elif profile == "posts":
            editor_name = tr("Preview: Main Editor")
            preview_data = {
                "name": editor_name,
                "messages": [
                    {
                        "id": 10,
                        "type": "message",
                        "from": editor_name,
                        "date": "2025-08-13T13:00:00",
                        "text": [
                            {"type": "bold", "text": tr("Preview: New Telegram Update")},
                            "\n\n",
                            tr("Preview: Update description"),
                            "\n\n",
                            {
                                "type": "text_link",
                                "text": editor_name,
                                "href": "http://t.me/me",
                            },
                        ],
                    },
                    {
                        "id": 11,
                        "type": "message",
                        "from": "Red One",
                        "from_id": "user_red",
                        "date": "2025-08-13T13:02:00",
                        "reply_to_message_id": 10,
                        "text": tr("Preview: Why do we need this?"),
                    },
                    {
                        "id": 12,
                        "type": "message",
                        "from": "Ficction",
                        "from_id": "user_ficc",
                        "date": "2025-08-13T13:04:00",
                        "reply_to_message_id": 11,
                        "text": tr("Preview: If you don't need it..."),
                    },
                ],
            }

        elif profile == "channel":
            preview_data = {
                "name": tr("Preview: Example Channel"),
                "messages": [
                    {
                        "id": 1,
                        "type": "message",
                        "from": tr("Preview: Bob"),
                        "from_id": "user_bob",
                        "date": "2025-04-02T23:58:00",
                        "text": tr("Preview: Hello everyone!"),
                    },
                    {
                        "id": 2,
                        "type": "message",
                        "from": tr("Preview: Bob"),
                        "from_id": "user_bob",
                        "date": "2025-04-02T23:58:30",
                        "text": tr("Preview: This is a second message from me."),
                    },
                    {
                        "id": 3,
                        "type": "message",
                        "from": tr("Preview: Alice"),
                        "from_id": "user_alice",
                        "date": "2025-04-02T23:59:00",
                        "edited": "2020-04-02T23:59:30",
                        "text": [{"type": "italic", "text": tr("Preview: One moment")}],
                    },
                ],
            }

        else:
            preview_data = {}

        return preview_data

    def generate_preview_text(self, config: dict) -> tuple[str, str]:
        """Generates preview text and title based on configuration."""
        try:
            preview_data = self.generate_preview_data(config)
            raw_text = generate_plain_text(preview_data, config, html_mode=True)

            profile = config.get("profile", "group")

            if profile == "group":
                title = tr("Preview: Group example")
            elif profile == "personal":
                title = tr("Preview: Personal example")
            elif profile == "posts":
                title = tr("Preview: Posts example")
            elif profile == "channel":
                title = tr("Preview: Channel example")
            else:
                title = tr("Preview")

            return raw_text, title

        except Exception as e:
            self.logger.error(f"=== PREVIEW GENERATION ERROR ===")
            self.logger.error(f"Error type: {type(e).__name__}")
            self.logger.error(f"Error message: {e}")
            import traceback
            self.logger.error(f"Traceback: {traceback.format_exc()}")

            error_message = f"Error: {e}"
            return error_message, "Preview Error"

    def get_longest_preview_html(self, config: dict) -> str:
        """
        Generates HTML for the longest static example ('posts').
        Used to calculate window height initially.
        """
        try:
            config_copy = config.copy()
            config_copy["profile"] = "posts"

            preview_data = self.generate_preview_data(config_copy)
            raw_text = generate_plain_text(preview_data, config_copy, html_mode=True)

            result_html = raw_text.replace("\n", "<br>")
            return result_html

        except Exception as e:
            self.logger.error(f"=== LONGEST PREVIEW GENERATION ERROR ===")
            self.logger.error(f"Error type: {type(e).__name__}")
            self.logger.error(f"Error message: {e}")
            import traceback
            self.logger.error(f"Traceback: {traceback.format_exc()}")
            return ""


--- Файл: ./src/presenters/analysis_presenter_extended.py ---
import logging
from typing import Optional, Set, Dict, Any

from PyQt6.QtCore import QObject, QThreadPool, pyqtSignal
from PyQt6.QtWidgets import QMessageBox

from core.analysis.tree_analyzer import TreeNode
from core.application.analysis_service import AnalysisService
from core.application.chat_service import ChatService
from core.conversion.domain_adapters import chat_to_dict
from core.domain.models import AnalysisResult, Chat
from presenters.app_state import AppState
from presenters.workers import AnalysisWorker, TreeBuildWorker
from resources.translations import tr

logger = logging.getLogger(__name__)

class AnalysisPresenterExtended(QObject):
    """Extended presenter for managing analysis functionality and dialogs."""

    filter_changed = pyqtSignal(set)
    analysis_count_updated = pyqtSignal(int, str)
    analysis_completed = pyqtSignal(TreeNode)
    disabled_nodes_changed = pyqtSignal(set)

    def __init__(self, view, app_state: AppState, analysis_service: AnalysisService, chat_service: ChatService, theme_manager):
        super().__init__()
        self._view = view
        self._app_state = app_state
        self._analysis_service = analysis_service
        self._chat_service = chat_service
        self._theme_manager = theme_manager

        self._threadpool = QThreadPool()
        self._current_workers = []

        self._analysis_dialog = None
        self._calendar_dialog = None

        self._connect_signals()

    def _connect_signals(self):
        """Connects UI signals to presenter methods."""
        self._view.recalculate_clicked.connect(self.on_recalculate_clicked)
        self._view.calendar_button_clicked.connect(self.on_calendar_clicked)
        self._view.diagram_button_clicked.connect(self.on_diagram_clicked)

    def on_recalculate_clicked(self):
        """Handles recalculate button click."""
        if not self._app_state.has_chat_loaded():
            self._view.show_status(message_key="Please load a JSON file first.", is_error=True)
            return

        if self._app_state.is_processing:
            return

        self.set_processing_state_in_view(True, message_key="Calculating...")

        worker = AnalysisWorker(
            self._analysis_service,
            self._app_state.loaded_chat,
            self._app_state.ui_config.copy(),
            self._app_state.tokenizer,
        )
        worker.signals.finished.connect(self._on_analysis_finished)

        self._current_workers.append(worker)
        self._threadpool.start(worker)

    def _on_analysis_finished(self, success: bool, message: str, result: Optional[AnalysisResult]):
        """Handles analysis completion."""
        self.set_processing_state_in_view(False)

        if success and result:
            self._app_state.set_analysis_result(result)
            self.analysis_count_updated.emit(result.total_count, result.unit)
        else:
            self._view.show_status(
                message_key="Analysis failed or no data found.",
                is_error=True
            )
            self.analysis_count_updated.emit(-1, "chars")

    def on_diagram_clicked(self):
        """Handles diagram button click."""
        if self._app_state.is_processing:
            return

        if not self._app_state.has_chat_loaded():
            self._view.show_status(message_key="Please load a JSON file first.", is_error=True)
            return

        if not self._app_state.has_analysis_data():
            self._view.show_message_box(
                tr("Token Analysis"),
                tr("Please calculate total tokens first by clicking 'Recalculate'."),
                QMessageBox.Icon.Information
            )
            return

        if not self._app_state.analysis_tree:
            self.set_processing_state_in_view(True, message_key="Building analysis tree...")

            worker = TreeBuildWorker(
                self._analysis_service,
                self._app_state.analysis_result,
                self._app_state.ui_config.copy(),
            )
            worker.signals.finished.connect(self._on_tree_build_finished)

            self._current_workers.append(worker)
            self._threadpool.start(worker)
        else:
            self._show_analysis_dialog()

    def _on_tree_build_finished(self, success: bool, message: str, result: Optional[TreeNode]):
        """Handles analysis tree building completion."""
        self.set_processing_state_in_view(False)

        if success and result:
            self._app_state.set_analysis_tree(result)
            self._show_analysis_dialog()
        else:
            self._view.show_status(message_key="Failed to build analysis tree", is_error=True)

    def _show_analysis_dialog(self):
        """Shows analysis dialog with bidirectional communication."""
        from ui.dialogs.analysis.analysis_dialog import AnalysisDialog

        if self._analysis_dialog is not None:
            try:
                self._analysis_dialog.accepted.disconnect(self._handle_analysis_accepted)
                self.disabled_nodes_changed.disconnect(self._analysis_dialog.presenter.view.on_external_update)
            except (TypeError, RuntimeError):
                pass
            try:
                self._analysis_dialog.close()
            except RuntimeError:
                pass
            self._analysis_dialog = None

        try:
            from presenters.analysis_presenter import AnalysisPresenter
            analysis_presenter = AnalysisPresenter()
            self._analysis_dialog = analysis_presenter.get_view(parent=self._view)

            self._analysis_dialog.accepted.connect(self._handle_analysis_accepted)
            self.disabled_nodes_changed.connect(analysis_presenter.view.on_external_update)

            def disconnect_analysis_signals(result_code=None):
                try:
                    if self._analysis_dialog:
                        self.disabled_nodes_changed.disconnect(self._analysis_dialog.on_external_update)
                        self._analysis_dialog.accepted.disconnect(self._handle_analysis_accepted)
                except (TypeError, RuntimeError):
                    pass

            self._analysis_dialog.finished.connect(disconnect_analysis_signals)

            if self._app_state.analysis_tree:
                analysis_presenter.load_analysis_data(
                    root_node=self._app_state.analysis_tree,
                    initial_disabled_nodes=self._app_state.disabled_time_nodes,
                    unit=self._app_state.last_analysis_unit
                )
            self._analysis_dialog.show()

        except Exception as e:
            logger.error(f"Error opening analysis dialog: {e}")

    def _handle_analysis_accepted(self):
        """Handles analysis dialog confirmation."""
        if self._analysis_dialog:
            final_disabled_nodes = self._analysis_dialog.disabled_nodes
            self.update_disabled_nodes(final_disabled_nodes)
        else:
            logger.warning("[AnalysisPresenter] _handle_analysis_accepted called, but _analysis_dialog is None")

    def on_calendar_clicked(self):
        """Handles calendar button click."""
        if self._app_state.is_processing:
            return

        if not self._app_state.has_chat_loaded():
            self._view.show_status(message_key="Please load a JSON file first.", is_error=True)
            return

        if not self._app_state.has_analysis_data():
            self._view.show_message_box(
                tr("Calendar"),
                tr("Please calculate total tokens first by clicking 'Recalculate'."),
                QMessageBox.Icon.Information
            )
            return

        if not self._app_state.analysis_tree:
            self.set_processing_state_in_view(True, message_key="Building analysis tree...")

            worker = TreeBuildWorker(
                self._analysis_service,
                self._app_state.analysis_result,
                self._app_state.ui_config.copy(),
            )
            worker.signals.finished.connect(self._on_calendar_tree_build_finished)

            self._current_workers.append(worker)
            self._threadpool.start(worker)
        else:
            self._show_calendar_dialog()

    def _on_calendar_tree_build_finished(self, success: bool, message: str, result: Optional[TreeNode]):
        """Handles calendar tree building completion."""
        self.set_processing_state_in_view(False)

        if success and result:
            self._app_state.set_processing_state(False)
            self._app_state.set_analysis_tree(result)
            self._show_calendar_dialog()
        else:
            self._view.show_status(
                tr("Failed to build analysis tree for calendar"), is_error=True
            )

    def _show_calendar_dialog(self):
        """Shows calendar dialog with bidirectional communication."""
        from ui.dialogs.calendar import CalendarDialog

        if self._calendar_dialog is not None:
            try:
                self._calendar_dialog.presenter.filter_changed.disconnect(self.update_disabled_nodes)
                self.disabled_nodes_changed.disconnect(self._calendar_dialog.presenter.set_disabled_nodes)
            except (TypeError, RuntimeError):
                pass
            try:
                self._calendar_dialog.close()
            except RuntimeError:
                pass
            self._calendar_dialog = None

        try:
            chat_as_dict = chat_to_dict(self._app_state.loaded_chat)
            messages_dict = chat_as_dict.get("messages", [])

            self._calendar_dialog = CalendarDialog(
                presenter=self,
                messages=messages_dict,
                config=self._app_state.ui_config.copy(),
                theme_manager=self._theme_manager,
                root_node=self._app_state.analysis_tree,
                initial_disabled_nodes=self._app_state.disabled_time_nodes,
                token_hierarchy=(
                    self._app_state.analysis_result.date_hierarchy
                    if self._app_state.analysis_result
                    else {}
                ),
                parent=self._view,
            )
            self._theme_manager.apply_theme_to_dialog(self._calendar_dialog)

            self._calendar_dialog.presenter.filter_changed.connect(self.update_disabled_nodes)
            self.disabled_nodes_changed.connect(self._calendar_dialog.presenter.set_disabled_nodes)

            def disconnect_calendar_signals(result_code=None):
                try:
                    if self._calendar_dialog:
                        self._calendar_dialog.presenter.filter_changed.disconnect(self.update_disabled_nodes)
                        self.disabled_nodes_changed.disconnect(self._calendar_dialog.presenter.set_disabled_nodes)
                except (TypeError, RuntimeError):
                    pass

            self._calendar_dialog.finished.connect(disconnect_calendar_signals)

            self._calendar_dialog.show()
        except Exception as e:
            logger.exception(f"Error opening calendar dialog: {e}")
            self._view.show_status(message_key="Error opening calendar dialog", is_error=True)

    def update_disabled_nodes(self, new_disabled_set: Set[TreeNode]):
        """Updates disabled nodes."""
        old_disabled_set = self._app_state.disabled_time_nodes.copy()
        if old_disabled_set != new_disabled_set:
            self._app_state.set_disabled_nodes(new_disabled_set)
            self.disabled_nodes_changed.emit(new_disabled_set)

    def set_processing_state_in_view(self, is_processing: bool, message: str = "", message_key: str = None, format_args: dict = None):
        """Proxy method for calling set_processing_state in view."""
        if message_key:
            translated_message = tr(message_key)
            self._app_state.set_processing_state(is_processing, translated_message)
        else:
            self._app_state.set_processing_state(is_processing, message)

        if hasattr(self._view, 'set_processing_state'):
            self._view.set_processing_state(is_processing, None, message_key, format_args)
        else:
            logger.warning("View does not have set_processing_state method")

    def get_analysis_stats(self) -> Optional[Dict[str, int]]:
        """Returns analysis statistics considering filtering."""
        if not self._app_state.analysis_result:
            return None

        total_count = self._app_state.analysis_result.total_count

        if self._app_state.analysis_tree and self._app_state.disabled_time_nodes:
            filtered_count = self._calculate_filtered_count()
        else:
            filtered_count = total_count

        return {
            "total_count": total_count,
            "filtered_count": filtered_count,
            "disabled_count": total_count - filtered_count,
        }

    def _calculate_filtered_count(self) -> int:
        """Calculates the number of tokens/characters after filtering."""
        if not self._app_state.analysis_tree:
            return 0

        return self._calculate_tree_value_excluding_disabled(
            self._app_state.analysis_tree
        )

    def _calculate_tree_value_excluding_disabled(self, node) -> int:
        """Recursively calculates the value of the tree, excluding disabled nodes."""
        if not isinstance(node, TreeNode):
            return 0

        if node in self._app_state.disabled_time_nodes:
            return 0

        if node.children:
            total = 0
            for child in node.children:
                total += self._calculate_tree_value_excluding_disabled(child)
            return total
        else:
            return node.value


--- Файл: ./src/presenters/action_presenter.py ---
import logging
import re
from typing import Optional

from PyQt6.QtCore import QObject, QThreadPool, pyqtSignal
from PyQt6.QtWidgets import QMessageBox

from core.application.conversion_service import ConversionService
from core.application.tokenizer_service import TokenizerService
from core.domain.models import Chat
from presenters.app_state import AppState
from presenters.workers import ConversionWorker, TokenizerLoadWorker, AIInstallerWorker
from resources.translations import tr

logger = logging.getLogger(__name__)

class ActionPresenter(QObject):
    """Presenter for managing action buttons (Save, Settings, Install, Help)."""

    save_completed = pyqtSignal(bool, str)
    language_changed = pyqtSignal()

    def __init__(self, view, app_state: AppState, conversion_service: ConversionService,
                 tokenizer_service: TokenizerService, settings_manager, theme_manager, app_instance):
        super().__init__()
        self._view = view
        self._app_state = app_state
        self._conversion_service = conversion_service
        self._tokenizer_service = tokenizer_service
        self._settings_manager = settings_manager
        self._theme_manager = theme_manager
        self._app = app_instance

        self._threadpool = QThreadPool()
        self._current_workers = []

        self._settings_dialog = None
        self._export_dialog = None
        self._install_dialog = None
        self._help_dialog = None

        self._installer_worker = None

        self._connect_signals()

    def _connect_signals(self):
        """Connects UI signals to presenter methods."""
        self._view.save_button_clicked.connect(self.on_save_clicked)
        self._view.settings_button_clicked.connect(self.on_settings_clicked)
        self._view.install_manager_button_clicked.connect(self.on_install_manager_clicked)
        self._view.help_button_clicked.connect(self.on_help_clicked)

    def on_save_clicked(self):
        """Handles save button click."""
        if self._app_state.is_processing:
            return

        if not self._app_state.has_chat_loaded():
            self._view.show_status(message_key="Please load a JSON file first.", is_error=True)
            return

        chat_name = self._app_state.get_chat_name()
        sanitized_name = re.sub(r'[\\/*?:"<>|]', "_", chat_name)[:80]

        from ui.dialogs.export_dialog import ExportDialog
        from utils.file_utils import get_unique_filepath

        if self._export_dialog is not None:
            try:
                self._view.bring_dialog_to_front(self._export_dialog, "export")
                return
            except RuntimeError:
                self._export_dialog = None

        try:
            self._export_dialog = ExportDialog(
                settings_manager=self._settings_manager,
                parent=self._view,
                suggested_filename=sanitized_name,
                get_unique_path_func=get_unique_filepath,
            )

            self._theme_manager.apply_theme_to_dialog(self._export_dialog)

            self.language_changed.connect(self._export_dialog.retranslate_ui)
            self._export_dialog.accepted.connect(self._handle_export_accepted)
            self._export_dialog.destroyed.connect(self._on_dialog_destroyed)
            self._export_dialog.show()
        except Exception as e:
            logger.error(f"Error opening export dialog: {e}")

    def _handle_export_accepted(self):
        """Handles export confirmation."""
        if not self._export_dialog:
            return

        options = self._export_dialog.get_export_options()
        output_dir, file_name = options["output_dir"], options["file_name"]
        use_default = options["use_default_dir"]

        self._settings_manager.settings.setValue("export_use_default_dir", use_default)
        if use_default:
            self._settings_manager.settings.setValue("export_default_dir", output_dir)

        from utils.file_utils import get_unique_filepath

        final_path = get_unique_filepath(output_dir, file_name, ".txt")

        self._export_dialog.close()
        self._export_dialog = None

        self.set_processing_state_in_view(True, message_key="Saving file...")

        worker = ConversionWorker(
            self._conversion_service,
            self._app_state.loaded_chat,
            self._app_state.ui_config.copy(),
            final_path,
            self._app_state.disabled_time_nodes,
        )
        worker.signals.finished.connect(self._on_save_finished)

        self._current_workers.append(worker)
        self._threadpool.start(worker)

    def _on_save_finished(self, success: bool, path_or_error: str, result: Optional[Any]):
        """Handles save completion."""
        self.set_processing_state_in_view(False)

        if success:
            self._view.show_status(
                message_key="File saved: {path}",
                format_args={"path": path_or_error},
            )
        else:
            self._view.show_status(
                is_error=True,
                message_key="Error saving file: {error}",
                format_args={"error": path_or_error},
            )

    def on_settings_clicked(self):
        """Handles settings button click."""
        from ui.dialogs.settings_dialog import SettingsDialog

        if self._settings_dialog is not None:
            try:
                if self._settings_dialog.isVisible():
                    self._view.bring_dialog_to_front(self._settings_dialog, "settings")
                    return
                else:
                    self._settings_dialog = None
            except RuntimeError:
                self._settings_dialog = None

        if self._settings_dialog is None:
            try:
                ui_settings = self._settings_manager.load_ui_settings()

                self._settings_dialog = SettingsDialog(
                    current_theme=self._theme_manager.get_current_theme(),
                    current_language=self._settings_manager.load_language(),
                    current_ui_font_mode=self._settings_manager.load_ui_font_mode(),
                    current_ui_font_family=self._settings_manager.load_ui_font_family(),
                    current_truncate_name_length=ui_settings.get("truncate_name_length", 20),
                    current_truncate_quote_length=ui_settings.get("truncate_quote_length", 50),
                    current_auto_detect_profile=ui_settings.get("auto_detect_profile", True),
                    current_auto_recalc=ui_settings.get("auto_recalc", False),
                    parent=self._view,
                )

                self._theme_manager.apply_theme_to_dialog(self._settings_dialog)

                self.language_changed.connect(self._settings_dialog.retranslate_ui)
                self._settings_dialog.accepted.connect(self._apply_settings_from_dialog)
                self._settings_dialog.destroyed.connect(self._on_dialog_destroyed)

                self._settings_dialog.show()

            except Exception as e:
                import traceback
                self._settings_dialog = None

    def _apply_settings_from_dialog(self):
        """Applies settings from dialog."""
        if not self._settings_dialog:
            return

        new_lang = self._settings_dialog.get_language()
        new_theme = self._settings_dialog.get_theme()
        new_font_mode, new_font_family = self._settings_dialog.get_font_settings()

        current_lang = self._settings_manager.load_language()
        if new_lang != current_lang:
            self._settings_manager.save_language(new_lang)
            from resources.translations import set_language
            set_language(new_lang)
            self.language_changed.emit()

        current_theme = self._theme_manager.get_current_theme()
        if new_theme != current_theme:
            self._settings_manager.save_theme(new_theme)
            self._theme_manager.set_theme(new_theme, self._app)

        current_font_mode = self._settings_manager.load_ui_font_mode()
        current_font_family = self._settings_manager.load_ui_font_family()

        if new_font_mode != current_font_mode or new_font_family != current_font_family:
            self._settings_manager.save_ui_font_settings(new_font_mode, new_font_family)
            from ui.font_manager import FontManager
            font_manager = FontManager.get_instance()
            font_manager.set_font(new_font_mode, new_font_family)

        new_trunc_settings = self._settings_dialog.get_truncation_settings()
        new_auto_detect_profile = self._settings_dialog.get_auto_detect_profile()
        new_auto_recalc = self._settings_dialog.get_auto_recalc()

        current_ui_settings = self._settings_manager.load_ui_settings()
        current_auto_detect = current_ui_settings.get("auto_detect_profile", True)
        current_auto_recalc = current_ui_settings.get("auto_recalc", False)

        settings_changed = False

        if current_auto_detect != new_auto_detect_profile:
            current_ui_settings["auto_detect_profile"] = new_auto_detect_profile
            self._app_state.set_config_value("auto_detect_profile", new_auto_detect_profile)
            settings_changed = True

        if current_auto_recalc != new_auto_recalc:
            current_ui_settings["auto_recalc"] = new_auto_recalc
            self._app_state.set_config_value("auto_recalc", new_auto_recalc)
            settings_changed = True

        if settings_changed:
            self._settings_manager.save_ui_settings(current_ui_settings)

        config_updated = False
        for key, value in new_trunc_settings.items():
            current_value = self._app_state.get_config_value(key)
            if current_value != value:
                self._app_state.set_config_value(key, value)
                config_updated = True

        if config_updated:

            self.language_changed.emit()

    def on_install_manager_clicked(self):
        """Handles install manager button click."""
        from ui.dialogs.installation_manager_dialog import InstallationManagerDialog

        if self._install_dialog is not None:
            try:
                self._view.bring_dialog_to_front(self._install_dialog, "install_manager")
                return
            except RuntimeError:
                self._install_dialog = None

        is_installed = self._tokenizer_service.is_transformers_available()
        is_loaded = self._app_state.has_tokenizer()
        loaded_model_name = self._app_state.tokenizer_model_name

        model_in_cache = False
        ai_settings = self._settings_manager.load_ai_settings()
        current_model = ai_settings.get(
            "tokenizer_model", self._settings_manager.get_default_tokenizer_model()
        )

        if is_installed:
            cache_info = self._tokenizer_service.check_model_cache(current_model)
            model_in_cache = cache_info.get("available", False)

        self._install_dialog = InstallationManagerDialog(
            is_installed=is_installed,
            is_loaded=is_loaded,
            loaded_model_name=loaded_model_name,
            settings_manager=self._settings_manager,
            settings=self._settings_manager.load_ai_settings(),
            model_in_cache=model_in_cache,
            theme_manager=self._theme_manager,
            parent=self._view,
        )

        self._install_dialog.install_triggered.connect(self._handle_install_transformers)
        self._install_dialog.remove_model_triggered.connect(self._handle_remove_model)
        self._install_dialog.load_model_triggered.connect(self._handle_ai_model_load)
        self._install_dialog.accepted.connect(self._handle_install_manager_accepted)

        self._install_dialog.destroyed.connect(self._on_dialog_destroyed)

        self._install_dialog.show()

    def _handle_install_transformers(self):
        """Handles transformers library installation."""
        self._run_installer_worker("install_deps")

    def _handle_remove_model(self):
        """Handles removing model from cache."""
        settings = self._settings_manager.load_ai_settings()
        model_name = settings.get(
            "tokenizer_model", self._settings_manager.get_default_tokenizer_model()
        )
        if model_name:
            self._run_installer_worker("remove_model", model_name=model_name)

    def _handle_ai_model_load(self, model_name: str):
        """Handles AI model loading."""
        if self._install_dialog:
            self._install_dialog.append_log(tr("Downloading tokenizer model '{model}'...").format(model=model_name))
            self._install_dialog.set_actions_enabled(False)

        worker = TokenizerLoadWorker(self._tokenizer_service, model_name)
        worker.signals.progress.connect(
            lambda msg: self._install_dialog.append_log(f'<span class="info">{msg}</span>') if self._install_dialog else None
        )
        worker.signals.finished.connect(self._on_tokenizer_load_finished)
        self._threadpool.start(worker)

    def _on_tokenizer_load_finished(self, success: bool, message: str, tokenizer: Optional[Any]):
        """Handles tokenizer loading completion."""
        model_name = self._tokenizer_service.get_current_model_name()
        if success and tokenizer:
            self._app_state.set_tokenizer(tokenizer, model_name)

            self.language_changed.emit()

            if self._install_dialog:
                self._install_dialog.append_log(
                    tr("Tokenizer '{model}' loaded successfully!").format(model=model_name)
                )
                is_installed = self._tokenizer_service.is_transformers_available()
                is_loaded = self._app_state.has_tokenizer()
                self._install_dialog.set_status(
                    is_installed, is_loaded, model_in_cache=True, loaded_model_name=model_name
                )
        else:
            logger.error(f"Failed to load tokenizer {model_name}: {message}")
            if self._install_dialog:
                self._install_dialog.append_log(tr("Error loading tokenizer: {error}").format(error=message))

        if self._install_dialog:
            self._install_dialog.set_actions_enabled(True)

    def _run_installer_worker(self, action: str, model_name: str | None = None):
        """Starts worker for installing/removing AI components."""
        if not self._install_dialog or self._installer_worker is not None:
            return

        self._view.show_status(
            message_key="Executing: {command}",
            format_args={"command": action}
        )
        self._install_dialog.set_actions_enabled(False)
        self._installer_worker = AIInstallerWorker(action, model_name)
        self._installer_worker.signals.progress.connect(self._on_install_progress)
        self._installer_worker.signals.finished.connect(self._on_install_finished)
        QThreadPool.globalInstance().start(self._installer_worker)

    def _on_install_progress(self, message: str):
        """Handles installation progress."""
        if self._install_dialog and not self._install_dialog.isHidden():
            try:
                if any(keyword in message.lower() for keyword in ["error", "failed", "exception"]):
                    log_type = "error"
                elif any(keyword in message.lower() for keyword in ["warning", "warn"]):
                    log_type = "status"
                else:
                    log_type = "info"
                self._install_dialog.append_log(f'<span class="{log_type}">{message}</span>')
            except RuntimeError:
                pass

    def _on_install_finished(self, success: bool, message: str):
        """Handles installation completion."""
        self._view.show_status(message_key="Operation completed.")

        if self._install_dialog and not self._install_dialog.isHidden():
            try:
                action = (
                    self._installer_worker.action
                    if self._installer_worker
                    else "install_deps"
                )

                if success and action == "remove_model":
                    removed_model_name = self._installer_worker.model_name
                    if (
                        self._app_state.tokenizer
                        and self._app_state.tokenizer_model_name == removed_model_name
                    ):
                        self._app_state.clear_tokenizer()
                        self.language_changed.emit()

                is_installed_now = self._tokenizer_service.is_transformers_available()
                is_loaded_now = self._app_state.has_tokenizer()

                model_in_cache = None
                if is_installed_now and not is_loaded_now:
                    ai_settings = self._settings_manager.load_ai_settings()
                    current_model = ai_settings.get(
                        "tokenizer_model",
                        self._settings_manager.get_default_tokenizer_model(),
                    )
                    cache_info = self._tokenizer_service.check_model_cache(
                        current_model
                    )
                    model_in_cache = cache_info.get("available", False)

                loaded_model_name = (
                    self._app_state.tokenizer_model_name if is_loaded_now else None
                )

                self._install_dialog.on_action_finished(
                    success=success,
                    message=message,
                    new_is_installed=is_installed_now,
                    new_is_loaded=is_loaded_now,
                    model_in_cache=model_in_cache,
                    loaded_model_name=loaded_model_name,
                )

                if success and action == "install_deps":
                    self._show_restart_notification()

            except RuntimeError:
                pass

        self._installer_worker = None

    def _show_restart_notification(self):
        """Shows restart notification."""
        self._view.show_message_box(
            tr("Restart Required"),
            tr("Library installation completed successfully!") + "\n" + tr("Please restart the application for changes to take effect."),
            QMessageBox.Icon.Information
        )

    def _handle_install_manager_accepted(self):
        """Handles install manager dialog confirmation."""
        if not self._install_dialog:
            return

        new_settings = self._install_dialog.get_settings()
        self._settings_manager.save_ai_settings(new_settings)

    def on_help_clicked(self):
        """Handles help button click."""
        from ui.dialogs.help_dialog import HelpDialog

        if self._help_dialog is not None:
            try:
                self._view.bring_dialog_to_front(self._help_dialog, "help")
                return
            except RuntimeError:
                self._help_dialog = None

        if self._help_dialog is None:
            try:
                self._help_dialog = HelpDialog(parent=self._view)
                self._theme_manager.apply_theme_to_dialog(self._help_dialog)
                self.language_changed.connect(self._help_dialog.retranslate_ui)
                self._help_dialog.destroyed.connect(self._on_dialog_destroyed)
                self._help_dialog.show()
            except Exception as e:
                logger.error(f"Error opening help dialog: {e}")
                self._help_dialog = None

    def _on_dialog_destroyed(self):
        """Handles dialog destruction."""
        sender = self.sender()

        if sender == self._settings_dialog:
            self.language_changed.disconnect(self._settings_dialog.retranslate_ui)
            self._settings_dialog = None
        elif sender == self._export_dialog:
            self.language_changed.disconnect(self._export_dialog.retranslate_ui)
            self._export_dialog = None
        elif sender == self._install_dialog:
            try:
                self.language_changed.disconnect(self._install_dialog.retranslate_ui)
            except (TypeError, RuntimeError) as e:
                logger.warning(f"[ActionPresenter] Error disconnecting language_changed for install_dialog: {e}")
            self._install_dialog = None
        elif sender == self._help_dialog:
            try:
                self.language_changed.disconnect(self._help_dialog.retranslate_ui)
            except (TypeError, RuntimeError):
                pass
            self._help_dialog = None

    def set_processing_state_in_view(self, is_processing: bool, message: str = "", message_key: str = None, format_args: dict = None):
        """Proxy method for calling set_processing_state in view."""
        if message_key:
            translated_message = tr(message_key)
            self._app_state.set_processing_state(is_processing, translated_message)
        else:
            self._app_state.set_processing_state(is_processing, message)

        if hasattr(self._view, 'set_processing_state'):
            self._view.set_processing_state(is_processing, None, message_key, format_args)
        else:
            logger.warning("View does not have set_processing_state method")


--- Файл: ./src/presenters/main_presenter.py ---
import logging
from typing import Any, Dict, Optional, Set

from PyQt6.QtCore import QObject, pyqtSignal

from core.analysis.tree_analyzer import TreeNode
from core.application.analysis_service import AnalysisService
from core.application.chat_service import ChatService
from core.application.conversion_service import ConversionService
from core.application.tokenizer_service import TokenizerService
from core.dependency_injection import DIContainer
from core.domain.models import AnalysisResult, Chat
from presenters.action_presenter import ActionPresenter
from presenters.analysis_presenter_extended import AnalysisPresenterExtended
from presenters.app_state import AppState
from presenters.config_presenter import ConfigPresenter
from presenters.file_presenter import FilePresenter
from presenters.preview_service import PreviewService
from resources.translations import tr

logger = logging.getLogger(__name__)

class MainPresenter(QObject):
    """Main presenter implementing Clean Architecture with service layer as a coordinator."""

    chat_loaded = pyqtSignal(bool, str, str)
    profile_auto_detected = pyqtSignal(str)
    config_changed = pyqtSignal(str, object)
    analysis_unit_changed = pyqtSignal(str)
    preview_updated = pyqtSignal(str, str)
    save_completed = pyqtSignal(bool, str)
    analysis_count_updated = pyqtSignal(int, str)
    analysis_completed = pyqtSignal(TreeNode)
    tokenizer_changed = pyqtSignal()
    tokenizer_loading_started = pyqtSignal(str)
    tokenizer_loaded = pyqtSignal(object, str)
    tokenizer_load_failed = pyqtSignal(str)
    disabled_nodes_changed = pyqtSignal(set)
    language_changed = pyqtSignal()

    set_drop_zone_style_command = pyqtSignal(str)

    def __init__(
        self,
        view,
        settings_manager,
        theme_manager,
        app_instance,
        di_container: DIContainer,
        initial_theme: str,
        initial_config: dict,
    ):
        super().__init__()

        self._view = view
        self._settings_manager = settings_manager
        self._theme_manager = theme_manager
        self._app = app_instance
        self._di_container = di_container

        self._current_session_theme = initial_theme

        self._app_state = AppState(ui_config=initial_config)

        self._chat_service = self._di_container.get(ChatService)
        self._conversion_service = self._di_container.get(ConversionService)
        self._analysis_service = self._di_container.get(AnalysisService)
        self._tokenizer_service = self._di_container.get(TokenizerService)

        self._preview_service = PreviewService()

        self._initialize_child_presenters()

        self._connect_signals()

        self._try_load_default_tokenizer()

        self._view.show_status(message_key="Ready to work", is_status=True)

    def _initialize_child_presenters(self):
        """Initialize all child presenters."""
        self.config_presenter = ConfigPresenter(
            self._view,
            self._app_state,
            self._preview_service
        )

        self.file_presenter = FilePresenter(
            self._view,
            self._app_state,
            self._chat_service,
            self._preview_service
        )

        self.analysis_presenter = AnalysisPresenterExtended(
            self._view,
            self._app_state,
            self._analysis_service,
            self._chat_service,
            self._theme_manager
        )

        self.action_presenter = ActionPresenter(
            self._view,
            self._app_state,
            self._conversion_service,
            self._tokenizer_service,
            self._settings_manager,
            self._theme_manager,
            self._app
        )

    def _connect_signals(self):
        """Connects signals between presenters and main presenter."""

        self.file_presenter.chat_loaded.connect(self.chat_loaded.emit)
        self.file_presenter.profile_auto_detected.connect(self.profile_auto_detected.emit)
        self.file_presenter.preview_updated.connect(self.preview_updated.emit)
        self.file_presenter.set_drop_zone_style_command.connect(self.set_drop_zone_style_command.emit)

        self.config_presenter.config_changed.connect(self.config_changed.emit)
        self.config_presenter.profile_auto_detected.connect(self.profile_auto_detected.emit)
        self.config_presenter.preview_updated.connect(self.preview_updated.emit)

        self.analysis_presenter.analysis_count_updated.connect(self.analysis_count_updated.emit)
        self.analysis_presenter.analysis_completed.connect(self.analysis_completed.emit)
        self.analysis_presenter.disabled_nodes_changed.connect(self.disabled_nodes_changed.emit)

        self.action_presenter.save_completed.connect(self.save_completed.emit)
        self.action_presenter.language_changed.connect(self.language_changed.emit)

        self._theme_manager.theme_changed.connect(self._on_app_theme_changed)

        self.config_presenter.config_changed.connect(self._handle_config_change_for_auto_recalc)

    def _handle_config_change_for_auto_recalc(self, key: str, value: Any):
        """Handles config changes that might trigger auto-recalculation."""
        if (key == "auto_recalc_triggered" and
            self._app_state.get_config_value("auto_recalc", False) and
            self._app_state.has_chat_loaded() and
            not self._app_state.is_processing):

            self.analysis_presenter.on_recalculate_clicked()

    def _try_load_default_tokenizer(self):
        """Attempts to load the default tokenizer ONLY from local cache."""
        if not self._tokenizer_service.is_transformers_available():
            return

        settings = self._settings_manager.load_ai_settings()
        load_on_startup = settings.get("load_on_startup", True)
        if not load_on_startup:
            return

        default_model = self._tokenizer_service.get_default_model_name()

        cache_info = self._tokenizer_service.check_model_cache(default_model)
        if not cache_info.get("available", False):
            return

        try:
            tokenizer = self._tokenizer_service.load_tokenizer(
                default_model, local_only=True, progress_callback=None
            )

            self._app_state.set_tokenizer(tokenizer, default_model)
            self._update_analysis_unit()
            self.tokenizer_changed.emit()

        except Exception as e:
            logger.warning(f"Failed to load tokenizer {default_model}: {e}")
            pass

    def _update_analysis_unit(self):
        """Updates the analysis unit based on tokenizer availability."""
        new_unit = self._app_state.get_preferred_analysis_unit()

        if self._app_state.last_analysis_unit != new_unit:
            self._app_state.last_analysis_unit = new_unit
            self.analysis_unit_changed.emit(new_unit)

    def _on_app_theme_changed(self):
        """Handles global application theme change."""
        new_palette = self._app.palette()

        self._view.setPalette(new_palette)
        self._view.refresh_theme_styles()

        for dialog in [self.action_presenter._settings_dialog,
                      self.action_presenter._export_dialog,
                      self.action_presenter._install_dialog,
                      self.action_presenter._help_dialog]:
            try:
                if dialog and dialog.isVisible():
                    dialog.setPalette(new_palette)

                    if hasattr(dialog, 'refresh_theme_styles'):
                        dialog.refresh_theme_styles()
                    else:
                        self._theme_manager.apply_theme_to_dialog(dialog)
            except RuntimeError as e:

                if dialog == self.action_presenter._settings_dialog:
                    self.action_presenter._settings_dialog = None
                elif dialog == self.action_presenter._export_dialog:
                    self.action_presenter._export_dialog = None
                elif dialog == self.action_presenter._install_dialog:
                    self.action_presenter._install_dialog = None
                elif dialog == self.action_presenter._help_dialog:
                    self.action_presenter._help_dialog = None

        for dialog in [self.analysis_presenter._analysis_dialog,
                      self.analysis_presenter._calendar_dialog]:
            try:
                if dialog and dialog.isVisible():
                    dialog.setPalette(new_palette)
                    if hasattr(dialog, 'refresh_theme_styles'):
                        dialog.refresh_theme_styles()
                    else:
                        self._theme_manager.apply_theme_to_dialog(dialog)
            except RuntimeError as e:
                if dialog == self.analysis_presenter._analysis_dialog:
                    self.analysis_presenter._analysis_dialog = None
                elif dialog == self.analysis_presenter._calendar_dialog:
                    self.analysis_presenter._calendar_dialog = None

        self.language_changed.emit()

    def get_longest_preview_html(self) -> str:
        """Generates HTML for the longest static example ('posts')."""
        return self._preview_service.get_longest_preview_html(self._app_state.ui_config)

    def get_analysis_stats(self) -> Optional[Dict[str, int]]:
        """Returns analysis statistics considering filtering."""
        return self.analysis_presenter.get_analysis_stats()

    def get_current_chat(self) -> Optional[Chat]:
        """Returns the currently loaded chat."""
        return self._app_state.loaded_chat

    def get_analysis_result(self) -> Optional[AnalysisResult]:
        """Returns the analysis result."""
        return self._app_state.analysis_result

    def get_analysis_tree(self) -> Optional[TreeNode]:
        """Returns the analysis tree."""
        return self._app_state.analysis_tree

    def get_config(self) -> Dict[str, Any]:
        """Returns a copy of the current configuration."""
        return self._app_state.ui_config.copy()

    def get_disabled_nodes(self) -> Set[TreeNode]:
        """Returns a copy of disabled nodes."""
        return self._app_state.disabled_time_nodes.copy()

    def has_chat_loaded(self) -> bool:
        """Checks if a chat is loaded."""
        return self._app_state.has_chat_loaded()

    def get_app_state(self) -> AppState:
        """Returns the application state (for complex dialogs)."""
        return self._app_state

    def get_current_file_path(self) -> Optional[str]:
        """Returns the path to the currently loaded file."""
        return self._chat_service.get_current_file_path()

    def update_disabled_nodes(self, new_disabled_set: Set[TreeNode]):
        """Updates disabled nodes."""
        self.analysis_presenter.update_disabled_nodes(new_disabled_set)

    def on_file_dropped(self, path: str):
        """Handles file drag-and-drop."""
        self.file_presenter.on_file_dropped(path)

    def on_drop_zone_hover_state_changed(self, is_hovered: bool):
        """Handles drop zone hover state changes."""
        self.file_presenter.on_drop_zone_hover_state_changed(is_hovered)

    def on_drop_zone_drag_active(self, is_active: bool):
        """Handles drop zone drag active state changes."""
        self.file_presenter.on_drop_zone_drag_active(is_active)

    def on_config_changed(self, key: str, value: Any):
        """Handles configuration changes."""
        self.config_presenter.on_config_changed(key, value)

    def handle_profile_auto_detection(self, detected_profile: str):
        """Handles automatic profile detection."""
        self.config_presenter.handle_profile_auto_detection(detected_profile)

    def on_recalculate_clicked(self):
        """Handles recalculate button click."""
        self.analysis_presenter.on_recalculate_clicked()

    def on_calendar_clicked(self):
        """Handles calendar button click."""
        self.analysis_presenter.on_calendar_clicked()

    def on_diagram_clicked(self):
        """Handles diagram button click."""
        self.analysis_presenter.on_diagram_clicked()

    def on_save_clicked(self):
        """Handles save button click."""
        self.action_presenter.on_save_clicked()

    def on_settings_clicked(self):
        """Handles settings button click."""
        self.action_presenter.on_settings_clicked()

    def on_install_manager_clicked(self):
        """Handles install manager button click."""
        self.action_presenter.on_install_manager_clicked()

    def on_help_clicked(self):
        """Handles help button click."""
        self.action_presenter.on_help_clicked()

    def _generate_preview(self):
        """Starts a preview generation using hardcoded data."""
        try:
            config = self._app_state.ui_config
            raw_text, title = self._preview_service.generate_preview_text(config)
            self.preview_updated.emit(raw_text, title)
        except Exception as e:
            logger.error(f"Error generating preview: {e}")
            error_message = f"Error: {e}"
            self.preview_updated.emit(error_message, "Preview Error")


--- Файл: ./src/presenters/workers.py ---
import logging
import subprocess
import sys
import threading
from typing import Any, Dict, Optional, Set

from PyQt6.QtCore import QObject, QRunnable, pyqtSignal

from core.analysis.tree_analyzer import TreeNode
from core.application.analysis_service import AnalysisService
from core.application.chat_service import ChatLoadError, ChatService
from core.application.conversion_service import ConversionService
from core.application.tokenizer_service import TokenizerError, TokenizerService
from core.domain.models import AnalysisResult, Chat
from resources.translations import tr

logger = logging.getLogger(__name__)

class WorkerSignals(QObject):
    """Signals for worker threads."""

    progress = pyqtSignal(str)
    finished = pyqtSignal(bool, str, object)

class AIInstallerSignals(QObject):
    """Signals for AI Installer Worker."""

    progress = pyqtSignal(str)
    finished = pyqtSignal(bool, str)

class ChatLoadWorker(QRunnable):
    """Worker for loading chat in a separate thread."""

    def __init__(self, chat_service: ChatService, file_path: str):
        super().__init__()
        self.chat_service = chat_service
        self.file_path = file_path
        self.signals = WorkerSignals()

    def run(self):
        try:
            chat = self.chat_service.load_chat_from_file(self.file_path)
            self.signals.finished.emit(True, tr("File loaded successfully"), chat)
        except ChatLoadError as e:
            self.signals.finished.emit(False, str(e), None)
        except Exception as e:
            logger.error(f"Unexpected error loading chat: {e}")
            self.signals.finished.emit(
                False, tr("Unexpected error: {error}").format(error=str(e)), None
            )

class ConversionWorker(QRunnable):
    """Worker for converting chat to text in a separate thread."""

    def __init__(
        self,
        conversion_service: ConversionService,
        chat: Chat,
        config: Dict[str, Any],
        save_path: str,
        disabled_nodes: Optional[Set[TreeNode]] = None,
    ):
        super().__init__()
        self.conversion_service = conversion_service
        self.chat = chat
        self.config = config
        self.save_path = save_path
        self.disabled_nodes = disabled_nodes or set()
        self.signals = WorkerSignals()

    def run(self):
        try:
            self.signals.progress.emit(tr("Converting chat..."))
            text = self.conversion_service.convert_to_text(
                self.chat,
                self.config,
                html_mode=False,
                disabled_nodes=self.disabled_nodes,
            )

            with open(self.save_path, "w", encoding="utf-8") as f:
                f.write(text)

            self.signals.finished.emit(True, self.save_path, None)
        except Exception as e:
            logger.error(f"Conversion error: {e}")
            self.signals.finished.emit(False, str(e), None)

class AnalysisWorker(QRunnable):
    """Worker for analyzing chat in a separate thread."""

    def __init__(
        self,
        analysis_service: AnalysisService,
        chat: Chat,
        config: Dict[str, Any],
        tokenizer: Optional[Any] = None,
    ):
        super().__init__()
        self.analysis_service = analysis_service
        self.chat = chat
        self.config = config
        self.tokenizer = tokenizer
        self.signals = WorkerSignals()
        self._is_cancelled = False
        self._lock = threading.Lock()

    def cancel(self):
        """Запрашивает отмену задачи."""
        with self._lock:
            self._is_cancelled = True

    def is_cancelled(self):
        """Проверяет, была ли запрошена отмена."""
        with self._lock:
            return self._is_cancelled

    def run(self):
        try:

            if self.is_cancelled():
                self.signals.finished.emit(False, "Cancelled", None)
                return

            if self.tokenizer:
                result = self.analysis_service.calculate_token_stats(
                    self.chat, self.config, self.tokenizer
                )
            else:
                result = self.analysis_service.calculate_character_stats(
                    self.chat, self.config
                )

            if self.is_cancelled():
                self.signals.finished.emit(False, "Cancelled", None)
                return

            self.signals.finished.emit(True, tr("Analysis completed"), result)
        except Exception as e:
            if not self.is_cancelled():
                logger.error(f"Analysis error: {e}")
                self.signals.finished.emit(False, str(e), None)

class TreeBuildWorker(QRunnable):
    """Worker for building analysis tree in a separate thread."""

    def __init__(
        self,
        analysis_service: AnalysisService,
        analysis_result: AnalysisResult,
        config: Dict[str, Any],
    ):
        super().__init__()
        self.analysis_service = analysis_service
        self.analysis_result = analysis_result
        self.config = config
        self.signals = WorkerSignals()
        self._is_cancelled = False
        self._lock = threading.Lock()

    def cancel(self):
        """Запрашивает отмену задачи."""
        with self._lock:
            self._is_cancelled = True

    def is_cancelled(self):
        """Проверяет, была ли запрошена отмена."""
        with self._lock:
            return self._is_cancelled

    def run(self):
        try:
            self.signals.progress.emit(tr("Building analysis tree..."))

            if self.is_cancelled():
                self.signals.finished.emit(False, "Cancelled", None)
                return

            tree = self.analysis_service.build_analysis_tree(
                self.analysis_result, self.config
            )

            if self.is_cancelled():
                self.signals.finished.emit(False, "Cancelled", None)
                return

            self.signals.finished.emit(True, tr("Tree built successfully"), tree)
        except Exception as e:
            if not self.is_cancelled():
                logger.error(f"Tree building error: {e}")
                self.signals.finished.emit(False, str(e), None)

class TokenizerLoadWorker(QRunnable):
    """Worker for loading tokenizer in a separate thread."""

    def __init__(self, tokenizer_service: TokenizerService, model_name: str):
        super().__init__()
        self.tokenizer_service = tokenizer_service
        self.model_name = model_name
        self.signals = WorkerSignals()
        self._is_cancelled = False
        self._lock = threading.Lock()

    def cancel(self):
        """Запрашивает отмену задачи."""
        with self._lock:
            self._is_cancelled = True

    def is_cancelled(self):
        """Проверяет, была ли запрошена отмена."""
        with self._lock:
            return self._is_cancelled

    def run(self):
        try:

            if self.is_cancelled():
                self.signals.finished.emit(False, "Cancelled", None)
                return

            progress_callback = lambda msg: self.signals.progress.emit(msg)
            tokenizer = self.tokenizer_service.load_tokenizer(
                self.model_name, local_only=False, progress_callback=progress_callback
            )

            if self.is_cancelled():
                self.signals.finished.emit(False, "Cancelled", None)
                return

            self.signals.finished.emit(
                True, tr("Tokenizer loaded successfully"), tokenizer
            )
        except TokenizerError as e:
            if not self.is_cancelled():
                self.signals.finished.emit(False, str(e), None)
        except Exception as e:
            if not self.is_cancelled():
                logger.error(f"Unexpected tokenizer error: {e}")
                self.signals.finished.emit(False, str(e), None)

class AIInstallerWorker(QRunnable):
    """Worker for installing/removing AI components."""

    def __init__(self, action: str, model_name: str | None = None):
        super().__init__()
        self.signals = AIInstallerSignals()
        self.action = action
        self.model_name = model_name

    def run(self):
        if self.action == "install_deps":
            self._install_dependencies()
        elif self.action == "remove_model":
            self._remove_model_cache()

    def _remove_model_cache(self):
        """Removes model from HuggingFace cache."""
        if not self.model_name:
            self.signals.finished.emit(False, tr("Model name not provided."))
            return

        try:
            from huggingface_hub import scan_cache_dir
        except ImportError:
            self.signals.finished.emit(False, tr("huggingface_hub is not installed."))
            return

        try:
            self.signals.progress.emit(tr("Scanning cache for model..."))
            hf_cache_info = scan_cache_dir()

            repo_info = next(
                (
                    repo
                    for repo in hf_cache_info.repos
                    if repo.repo_id == self.model_name
                ),
                None,
            )

            if not repo_info:
                self.signals.progress.emit(tr("Model not found in cache."))
                self.signals.finished.emit(
                    True, tr("Model cache removed successfully.")
                )
                return

            self.signals.progress.emit(tr("Found model, preparing to delete..."))
            revisions_to_delete = {rev.commit_hash for rev in repo_info.revisions}

            delete_strategy = hf_cache_info.delete_revisions(*revisions_to_delete)
            self.signals.progress.emit(
                tr("Will free: {size}").format(
                    size=delete_strategy.expected_freed_size_str
                )
            )
            self.signals.progress.emit(tr("Deleting model from cache..."))
            delete_strategy.execute()

            self.signals.finished.emit(True, tr("Model cache removed successfully."))
        except Exception as e:
            self.signals.finished.emit(False, str(e))

    def _install_dependencies(self):
        """Installs transformers dependencies."""
        packages = ["transformers[sentencepiece,torch]", "huggingface_hub"]
        if sys.prefix == sys.base_prefix:
            error_msg = tr(
                "Refusing to install packages into the system Python. Please run this application from a virtual environment (venv)."
            )
            self.signals.progress.emit(f"ERROR: {error_msg}")
            self.signals.finished.emit(False, error_msg)
            return
        command = [sys.executable, "-m", "pip", "install", "--upgrade", *packages]
        try:
            self.signals.progress.emit(
                tr("Executing: {command}").format(command=" ".join(command))
            )
            process = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                encoding="utf-8",
                errors="replace",
            )

            for line in iter(process.stdout.readline, ""):
                self.signals.progress.emit(line.strip())

            process.wait()

            if process.returncode == 0:
                self.signals.finished.emit(True, tr("Operation successful."))
            else:
                self.signals.finished.emit(
                    False,
                    tr("Operation failed with code: {code}").format(
                        code=process.returncode
                    ),
                )
        except Exception as e:
            self.signals.finished.emit(False, str(e))


--- Файл: ./src/presenters/modern_presenter.py ---
import logging
import re
from typing import Any, Dict, Optional, Set

from PyQt6.QtCore import QObject, QThreadPool, pyqtSignal
from PyQt6.QtWidgets import QMessageBox

from core.analysis.tree_analyzer import TreeNode
from core.application.analysis_service import AnalysisService
from core.application.chat_service import ChatService
from core.application.conversion_service import ConversionService
from core.application.tokenizer_service import TokenizerService
from core.conversion.domain_adapters import chat_to_dict
from core.dependency_injection import DIContainer
from presenters.analysis_presenter import AnalysisPresenter
from presenters.workers import (
    ChatLoadWorker, ConversionWorker, AnalysisWorker,
    TreeBuildWorker, TokenizerLoadWorker, AIInstallerWorker
)
from presenters.task_manager import CancellableTaskManager
from core.domain.models import AnalysisResult, Chat
from presenters.app_state import AppState
from resources.translations import set_language, tr
from ui.dialogs.help_dialog import HelpDialog

preview_logger = logging.getLogger("Preview")
preview_logger.setLevel(logging.ERROR)

logger = logging.getLogger("ModernPresenter")

if not preview_logger.handlers:
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%H:%M:%S'
    )

    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.ERROR)
    console_handler.setFormatter(formatter)

    preview_logger.addHandler(console_handler)

logger = logging.getLogger(__name__)

class ModernTkonverterPresenter(QObject):
    """Main presenter implementing Clean Architecture with service layer."""

    chat_loaded = pyqtSignal(bool, str, str)
    profile_auto_detected = pyqtSignal(str)
    config_changed = pyqtSignal(str, object)
    analysis_unit_changed = pyqtSignal(str)
    preview_updated = pyqtSignal(str, str)
    save_completed = pyqtSignal(bool, str)
    analysis_count_updated = pyqtSignal(int, str)
    analysis_completed = pyqtSignal(TreeNode)
    tokenizer_changed = pyqtSignal()
    tokenizer_loading_started = pyqtSignal(str)
    tokenizer_loaded = pyqtSignal(object, str)
    tokenizer_load_failed = pyqtSignal(str)
    disabled_nodes_changed = pyqtSignal(set)
    language_changed = pyqtSignal()

    set_drop_zone_style_command = pyqtSignal(str)

    def __init__(
        self,
        view,
        settings_manager,
        theme_manager,
        app_instance,
        di_container: DIContainer,
        initial_theme: str,
        initial_config: dict,
    ):
        super().__init__()

        self._view = view
        self._settings_manager = settings_manager
        self._theme_manager = theme_manager
        self._app = app_instance
        self._di_container = di_container

        self._current_session_theme = initial_theme

        self._app_state = AppState(ui_config=initial_config)

        self._chat_service = self._di_container.get(ChatService)
        self._conversion_service = self._di_container.get(ConversionService)
        self._analysis_service = self._di_container.get(AnalysisService)
        self._tokenizer_service = self._di_container.get(TokenizerService)

        self._settings_dialog = None
        self._export_dialog = None
        self._analysis_dialog = None
        self._install_dialog = None
        self._calendar_dialog = None
        self._help_dialog = None

        self._install_process = None
        self._installer_worker = None

        self._threadpool = QThreadPool()
        self._current_workers = []

        self.analysis_task_manager = CancellableTaskManager(AnalysisWorker)

        self._connect_signals()

        self._try_load_default_tokenizer()

        self._is_drop_zone_hovered = False
        self._is_drop_zone_drag_active = False
        self._view.show_status(message_key="Ready to work", is_status=True)

    def _connect_signals(self):
        """Connects UI signals to presenter methods."""

        self._view.config_changed.connect(self.on_config_changed)
        self._view.save_button_clicked.connect(self.on_save_clicked)
        self._view.settings_button_clicked.connect(self.on_settings_clicked)
        self._view.install_manager_button_clicked.connect(
            self.on_install_manager_clicked
        )
        self._view.recalculate_clicked.connect(self.on_recalculate_clicked)
        self._view.calendar_button_clicked.connect(self.on_calendar_clicked)
        self._view.diagram_button_clicked.connect(self.on_diagram_clicked)
        self._view.help_button_clicked.connect(self.on_help_clicked)

        self._theme_manager.theme_changed.connect(self._on_app_theme_changed)

        self.analysis_task_manager.finished.connect(self._on_analysis_finished)
        self.analysis_task_manager.progress.connect(self._view.show_status)

    def _try_load_default_tokenizer(self):
        """Attempts to load the default tokenizer ONLY from local cache."""

        if not self._tokenizer_service.is_transformers_available():
            return

        settings = self._settings_manager.load_ai_settings()
        load_on_startup = settings.get("load_on_startup", True)
        if not load_on_startup:
            return

        default_model = self._tokenizer_service.get_default_model_name()

        cache_info = self._tokenizer_service.check_model_cache(default_model)
        if not cache_info.get("available", False):
            return

        try:
            tokenizer = self._tokenizer_service.load_tokenizer(
                default_model, local_only=True, progress_callback=None
            )

            self._app_state.set_tokenizer(tokenizer, default_model)
            self._update_analysis_unit()
            self.tokenizer_changed.emit()

        except Exception as e:
            logger.warning(f"Failed to load tokenizer {default_model}: {e}")
            pass

    def _update_analysis_unit(self):
        """Updates the analysis unit based on tokenizer availability."""
        new_unit = self._app_state.get_preferred_analysis_unit()

        if self._app_state.last_analysis_unit != new_unit:
            self._app_state.last_analysis_unit = new_unit
            self.analysis_unit_changed.emit(new_unit)

    def _on_install_dialog_destroyed(self):
        """Handles the destruction of the installation manager dialog specifically."""
        self._install_dialog = None
        self._update_analysis_unit()

    def _generate_preview(self):
        """Starts a preview generation using hardcoded data."""
        try:
            from presenters.preview_service import PreviewService
            preview_service = PreviewService()
            config = self._app_state.ui_config
            raw_text, title = preview_service.generate_preview_text(config)
            self.preview_updated.emit(raw_text, title)

        except Exception as e:
            preview_logger.error(f"=== PREVIEW GENERATION ERROR ===")
            preview_logger.error(f"Error type: {type(e).__name__}")
            preview_logger.error(f"Error message: {e}")
            import traceback
            preview_logger.error(f"Traceback: {traceback.format_exc()}")

            error_message = f"Error: {e}"
            self.preview_updated.emit(error_message, "Preview Error")

    def get_longest_preview_html(self) -> str:
        """
        Generates HTML for the longest static example ('posts').
        Used to calculate window height initially.
        Presenter generates raw_text, View formats it to HTML.
        """
        try:
            from presenters.preview_service import PreviewService
            preview_service = PreviewService()
            config = self._app_state.ui_config.copy()
            return preview_service.get_longest_preview_html(config)

        except Exception as e:
            preview_logger.error(f"=== LONGEST PREVIEW GENERATION ERROR ===")
            preview_logger.error(f"Error type: {type(e).__name__}")
            preview_logger.error(f"Error message: {e}")
            import traceback
            preview_logger.error(f"Traceback: {traceback.format_exc()}")
            return ""

    def on_file_dropped(self, path: str):
        """Handles file drag-and-drop."""

        if self._app_state.is_processing:
            logger.warning("Application is already processing a file, ignoring new one")
            return

        self.set_processing_state_in_view(True, message_key="Loading file...")

        worker = ChatLoadWorker(self._chat_service, path)
        worker.signals.progress.connect(self._view.show_status)
        worker.signals.finished.connect(self._on_chat_load_finished)

        self._current_workers.append(worker)
        self._threadpool.start(worker)

    def _on_chat_load_finished(
        self, success: bool, message: str, result: Optional[Chat]
    ):
        """Handles chat loading completion."""
        self.set_processing_state_in_view(False)

        if success and result:

            auto_detect_enabled = self._app_state.get_config_value("auto_detect_profile", True)

            if auto_detect_enabled:
                detected_profile = self._chat_service.detect_chat_type(result)

                current_profile = self._app_state.get_config_value("profile")

                if detected_profile != current_profile:

                    self._app_state.set_config_value("profile", detected_profile)
                    self.profile_auto_detected.emit(detected_profile)
            else:
                pass

            file_path = self._chat_service.get_current_file_path()
            self._app_state.set_chat(result, file_path)

            if auto_detect_enabled:
                self._generate_preview()

            chat_name = self._app_state.get_chat_name()

            self.chat_loaded.emit(True, "", chat_name)

            if self._app_state.get_config_value("auto_recalc", False):
                self.on_recalculate_clicked()

        else:
            self.chat_loaded.emit(False, message, "")

    def on_config_changed(self, key: str, value: Any):
        """Handles configuration changes."""
        old_value = self._app_state.get_config_value(key)

        if old_value != value:

            had_analysis_data_before = self._app_state.has_analysis_data()

            self._app_state.set_config_value(key, value)

            self.config_changed.emit(key, value)

            if not self._app_state.has_analysis_data():

                self.analysis_count_updated.emit(-1, "chars")

                if had_analysis_data_before:
                    unit = self._app_state.get_preferred_analysis_unit()
                    if unit == "tokens":
                        self._view.show_status(message_key="Tokens reset", is_status=True)
                    else:
                        self._view.show_status(message_key="Characters reset", is_status=True)

            if key not in ["disabled_nodes"]:
                self._generate_preview()

            if (self._app_state.get_config_value("auto_recalc", False) and
                self._app_state.has_chat_loaded() and
                not self._app_state.is_processing and
                key not in ["auto_detect_profile", "auto_recalc", "disabled_nodes"]):

                self.on_recalculate_clicked()

    def on_save_clicked(self):
        """Handles save button click."""
        if self._app_state.is_processing:
            return

        if not self._app_state.has_chat_loaded():
            self._view.show_status(message_key="Please load a JSON file first.", is_error=True)
            return

        chat_name = self._app_state.get_chat_name()
        sanitized_name = re.sub(r'[\\/*?:"<>|]', "_", chat_name)[:80]

        from ui.dialogs.export_dialog import ExportDialog
        from utils.file_utils import get_unique_filepath

        if self._export_dialog is not None:
            try:

                self._view.bring_dialog_to_front(self._export_dialog, "export")
                return
            except RuntimeError:
                self._export_dialog = None

        try:
            self._export_dialog = ExportDialog(
                settings_manager=self._settings_manager,
                parent=self._view,
                suggested_filename=sanitized_name,
                get_unique_path_func=get_unique_filepath,
            )

            self._theme_manager.apply_theme_to_dialog(self._export_dialog)

            self.language_changed.connect(self._export_dialog.retranslate_ui)
            self._export_dialog.accepted.connect(self._handle_export_accepted)
            self._export_dialog.destroyed.connect(self._on_dialog_destroyed)
            self._export_dialog.show()
        except Exception as e:
            logger.error(f"Error opening export dialog: {e}")

    def _handle_export_accepted(self):
        """Handles export confirmation."""
        if not self._export_dialog:
            return

        options = self._export_dialog.get_export_options()
        output_dir, file_name = options["output_dir"], options["file_name"]
        use_default = options["use_default_dir"]

        self._settings_manager.settings.setValue("export_use_default_dir", use_default)
        if use_default:
            self._settings_manager.settings.setValue("export_default_dir", output_dir)

        from utils.file_utils import get_unique_filepath

        final_path = get_unique_filepath(output_dir, file_name, ".txt")

        self._export_dialog.close()
        self._export_dialog = None

        self.set_processing_state_in_view(True, message_key="Saving file...")

        worker = ConversionWorker(
            self._conversion_service,
            self._app_state.loaded_chat,
            self._app_state.ui_config.copy(),
            final_path,
            self._app_state.disabled_time_nodes,
        )
        worker.signals.finished.connect(self._on_save_finished)

        self._current_workers.append(worker)
        self._threadpool.start(worker)

    def _on_save_finished(self, success: bool, path_or_error: str, result: Any):
        """Handles save completion."""
        self.set_processing_state_in_view(False)

        if success:
            self._view.show_status(
                message_key="File saved: {path}",
                format_args={"path": path_or_error},
            )
        else:
            self._view.show_status(
                is_error=True,
                message_key="Error saving file: {error}",
                format_args={"error": path_or_error},
            )

    def on_recalculate_clicked(self):
        """Handles recalculate button click."""
        if not self._app_state.has_chat_loaded():
            self._view.show_status(message_key="Please load a JSON file first.", is_error=True)
            return

        self.set_processing_state_in_view(True, message_key="Calculating...")

        self.analysis_task_manager.submit(
            analysis_service=self._analysis_service,
            chat=self._app_state.loaded_chat,
            config=self._app_state.ui_config.copy(),
            tokenizer=self._app_state.tokenizer,
        )

    def _on_analysis_finished(
        self, success: bool, message: str, result: Optional[AnalysisResult]
    ):
        """Handles analysis completion."""

        if self.analysis_task_manager._pending_args is None:
            self.set_processing_state_in_view(False)

        if success and result:
            self._app_state.set_analysis_result(result)
            self.analysis_count_updated.emit(result.total_count, result.unit)
        else:

            if message != "Cancelled":
                self._view.show_status(
                    message_key="Analysis failed or no data found.",
                    is_error=True
                )
                self.analysis_count_updated.emit(-1, "chars")

    def on_diagram_clicked(self):
        """Handles diagram button click."""
        if self._app_state.is_processing:
            return

        if not self._app_state.has_chat_loaded():
            self._view.show_status(message_key="Please load a JSON file first.", is_error=True)
            return

        if not self._app_state.has_analysis_data():

            self._view.show_message_box(
                tr("Token Analysis"),
                tr("Please calculate total tokens first by clicking 'Recalculate'."),
                QMessageBox.Icon.Information
            )
            return

        if not self._app_state.analysis_tree:

            self.set_processing_state_in_view(True, message_key="Building analysis tree...")

            worker = TreeBuildWorker(
                self._analysis_service,
                self._app_state.analysis_result,
                self._app_state.ui_config.copy(),
            )
            worker.signals.finished.connect(self._on_tree_build_finished)

            self._current_workers.append(worker)
            self._threadpool.start(worker)
        else:
            self._show_analysis_dialog()

    def on_help_clicked(self):
        """Handles help button click."""
        if self._help_dialog is not None:
            try:
                self._view.bring_dialog_to_front(self._help_dialog, "help")
                return
            except RuntimeError:
                self._help_dialog = None

        if self._help_dialog is None:
            try:
                self._help_dialog = HelpDialog(parent=self._view)
                self._theme_manager.apply_theme_to_dialog(self._help_dialog)
                self.language_changed.connect(self._help_dialog.retranslate_ui)
                self._help_dialog.destroyed.connect(self._on_dialog_destroyed)
                self._help_dialog.show()
            except Exception as e:
                logger.error(f"Error opening help dialog: {e}")
                self._help_dialog = None

    def _on_tree_build_finished(
        self, success: bool, message: str, result: Optional[TreeNode]
    ):
        """Handles analysis tree building completion."""
        self.set_processing_state_in_view(False)

        if success and result:
            self._app_state.set_analysis_tree(result)

            self._show_analysis_dialog()
        else:
            self._view.show_status(message_key="Failed to build analysis tree", is_error=True)

    def _show_analysis_dialog(self):
        """Shows analysis dialog with bidirectional communication."""
        from ui.dialogs.analysis.analysis_dialog import AnalysisDialog

        if self._analysis_dialog is not None:
            try:

                self._analysis_dialog.accepted.disconnect(self._handle_analysis_accepted)
                self.disabled_nodes_changed.disconnect(self._analysis_dialog.presenter.view.on_external_update)
            except (TypeError, RuntimeError):
                pass
            try:
                self._analysis_dialog.close()
            except RuntimeError:
                pass
            self._analysis_dialog = None

        try:

            analysis_presenter = AnalysisPresenter()
            self._analysis_dialog = analysis_presenter.get_view(parent=self._view)

            self._analysis_dialog.accepted.connect(self._handle_analysis_accepted)

            self.disabled_nodes_changed.connect(analysis_presenter.view.on_external_update)

            def disconnect_analysis_signals(result_code=None):
                try:
                    if self._analysis_dialog:
                        self.disabled_nodes_changed.disconnect(self._analysis_dialog.on_external_update)
                        self._analysis_dialog.accepted.disconnect(self._handle_analysis_accepted)
                except (TypeError, RuntimeError):
                    pass

            self._analysis_dialog.finished.connect(disconnect_analysis_signals)

            if self._app_state.analysis_tree:
                analysis_presenter.load_analysis_data(
                    root_node=self._app_state.analysis_tree,
                    initial_disabled_nodes=self._app_state.disabled_time_nodes,
                    unit=self._app_state.last_analysis_unit
                )
            self._analysis_dialog.show()

        except Exception as e:
            logger.error(f"Error opening analysis dialog: {e}")

    def _handle_analysis_accepted(self):
        """Handles analysis dialog confirmation."""
        if self._analysis_dialog:

            final_disabled_nodes = self._analysis_dialog.disabled_nodes
            self.update_disabled_nodes(final_disabled_nodes)
        else:
            logger.warning("[ModernPresenter] _handle_analysis_accepted called, but _analysis_dialog is None")

    def on_calendar_clicked(self):
        """Handles calendar button click."""
        if self._app_state.is_processing:
            return

        if not self._app_state.has_chat_loaded():
            self._view.show_status(message_key="Please load a JSON file first.", is_error=True)
            return

        if not self._app_state.has_analysis_data():

            self._view.show_message_box(
                tr("Calendar"),
                tr("Please calculate total tokens first by clicking 'Recalculate'."),
                QMessageBox.Icon.Information
            )
            return

        if not self._app_state.analysis_tree:

            self.set_processing_state_in_view(True, message_key="Building analysis tree...")

            worker = TreeBuildWorker(
                self._analysis_service,
                self._app_state.analysis_result,
                self._app_state.ui_config.copy(),
            )
            worker.signals.finished.connect(self._on_calendar_tree_build_finished)

            self._current_workers.append(worker)
            self._threadpool.start(worker)
        else:
            self._show_calendar_dialog()

    def _on_calendar_tree_build_finished(
        self, success: bool, message: str, result: Optional[TreeNode]
    ):
        """Handles calendar tree building completion."""
        self.set_processing_state_in_view(False)

        if success and result:
            self._app_state.set_processing_state(False)
            self._app_state.set_analysis_tree(result)
            self._show_calendar_dialog()
        else:
            self._view.show_status(
                tr("Failed to build analysis tree for calendar"), is_error=True
            )

    def _show_calendar_dialog(self):
        """Shows calendar dialog with bidirectional communication."""
        from ui.dialogs.calendar import CalendarDialog

        if self._calendar_dialog is not None:
            try:
                self._calendar_dialog.presenter.filter_changed.disconnect(self.update_disabled_nodes)
                self.disabled_nodes_changed.disconnect(self._calendar_dialog.presenter.set_disabled_nodes)
            except (TypeError, RuntimeError):
                pass
            try:
                self._calendar_dialog.close()
            except RuntimeError:
                pass
            self._calendar_dialog = None

        try:
            chat_as_dict = chat_to_dict(self._app_state.loaded_chat)
            messages_dict = chat_as_dict.get("messages", [])

            self._calendar_dialog = CalendarDialog(
                presenter=self,
                messages=messages_dict,
                config=self._app_state.ui_config.copy(),
                theme_manager=self._theme_manager,
                root_node=self._app_state.analysis_tree,
                initial_disabled_nodes=self._app_state.disabled_time_nodes,
                token_hierarchy=(
                    self._app_state.analysis_result.date_hierarchy
                    if self._app_state.analysis_result
                    else {}
                ),
                parent=self._view,
            )
            self._theme_manager.apply_theme_to_dialog(self._calendar_dialog)
            self.language_changed.connect(self._calendar_dialog.retranslate_ui)

            self._calendar_dialog.presenter.filter_changed.connect(self.update_disabled_nodes)

            self.disabled_nodes_changed.connect(self._calendar_dialog.presenter.set_disabled_nodes)

            def disconnect_calendar_signals(result_code=None):
                try:
                    if self._calendar_dialog:
                        self._calendar_dialog.presenter.filter_changed.disconnect(self.update_disabled_nodes)

                        self.disabled_nodes_changed.disconnect(self._calendar_dialog.presenter.set_disabled_nodes)
                except (TypeError, RuntimeError):
                    pass

            self._calendar_dialog.finished.connect(disconnect_calendar_signals)

            self._calendar_dialog.show()
        except Exception as e:
            logger.exception(f"Error opening calendar dialog: {e}")
            self._view.show_status(message_key="Error opening calendar dialog", is_error=True)

    def on_settings_clicked(self):
        """Handles settings button click."""
        from ui.dialogs.settings_dialog import SettingsDialog

        if self._settings_dialog is not None:
            try:
                if self._settings_dialog.isVisible():
                    self._view.bring_dialog_to_front(self._settings_dialog, "settings")
                    return
                else:
                    self._settings_dialog = None
            except RuntimeError:
                self._settings_dialog = None

        if self._settings_dialog is None:
            try:

                ui_settings = self._settings_manager.load_ui_settings()

                self._settings_dialog = SettingsDialog(
                    current_theme=self._current_session_theme,
                    current_language=self._settings_manager.load_language(),
                    current_ui_font_mode=self._settings_manager.load_ui_font_mode(),
                    current_ui_font_family=self._settings_manager.load_ui_font_family(),
                    current_truncate_name_length=ui_settings.get("truncate_name_length", 20),
                    current_truncate_quote_length=ui_settings.get("truncate_quote_length", 50),
                    current_auto_detect_profile=ui_settings.get("auto_detect_profile", True),
                    current_auto_recalc=ui_settings.get("auto_recalc", False),
                    parent=self._view,
                )

                self._theme_manager.apply_theme_to_dialog(self._settings_dialog)

                self.language_changed.connect(self._settings_dialog.retranslate_ui)
                self._settings_dialog.accepted.connect(self._apply_settings_from_dialog)
                self._settings_dialog.destroyed.connect(self._on_dialog_destroyed)

                self._settings_dialog.show()

            except Exception as e:
                import traceback
                self._settings_dialog = None

    def _apply_settings_from_dialog(self):
        """Applies settings from dialog."""
        if not self._settings_dialog:
            return

        new_lang = self._settings_dialog.get_language()
        new_theme = self._settings_dialog.get_theme()
        new_font_mode, new_font_family = self._settings_dialog.get_font_settings()

        current_lang = self._settings_manager.load_language()
        if new_lang != current_lang:
            self._settings_manager.save_language(new_lang)
            set_language(new_lang)
            self.language_changed.emit()

        current_theme = self._current_session_theme
        if new_theme != current_theme:
            self._settings_manager.save_theme(new_theme)
            self._theme_manager.set_theme(new_theme, self._app)
            self._current_session_theme = new_theme

        current_font_mode = self._settings_manager.load_ui_font_mode()
        current_font_family = self._settings_manager.load_ui_font_family()

        if new_font_mode != current_font_mode or new_font_family != current_font_family:
            self._settings_manager.save_ui_font_settings(new_font_mode, new_font_family)
            from ui.font_manager import FontManager
            font_manager = FontManager.get_instance()
            font_manager.set_font(new_font_mode, new_font_family)

        new_trunc_settings = self._settings_dialog.get_truncation_settings()
        new_auto_detect_profile = self._settings_dialog.get_auto_detect_profile()
        new_auto_recalc = self._settings_dialog.get_auto_recalc()

        current_ui_settings = self._settings_manager.load_ui_settings()
        current_auto_detect = current_ui_settings.get("auto_detect_profile", True)
        current_auto_recalc = current_ui_settings.get("auto_recalc", False)

        settings_changed = False

        if current_auto_detect != new_auto_detect_profile:
            current_ui_settings["auto_detect_profile"] = new_auto_detect_profile
            self._app_state.set_config_value("auto_detect_profile", new_auto_detect_profile)
            settings_changed = True

        if current_auto_recalc != new_auto_recalc:
            current_ui_settings["auto_recalc"] = new_auto_recalc
            self._app_state.set_config_value("auto_recalc", new_auto_recalc)
            settings_changed = True

        if settings_changed:
            self._settings_manager.save_ui_settings(current_ui_settings)

        config_updated = False
        for key, value in new_trunc_settings.items():
            current_value = self._app_state.get_config_value(key)
            if current_value != value:
                self._app_state.set_config_value(key, value)
                config_updated = True

        if config_updated:
            self._generate_preview()

    def on_install_manager_clicked(self):
        """Handles install manager button click."""
        from ui.dialogs.installation_manager_dialog import InstallationManagerDialog

        if self._install_dialog is not None:
            try:

                self._view.bring_dialog_to_front(self._install_dialog, "install_manager")
                return
            except RuntimeError:
                self._install_dialog = None

        is_installed = self._tokenizer_service.is_transformers_available()
        is_loaded = self._app_state.has_tokenizer()
        loaded_model_name = self._app_state.tokenizer_model_name

        model_in_cache = False
        ai_settings = self._settings_manager.load_ai_settings()
        current_model = ai_settings.get(
            "tokenizer_model", self._settings_manager.get_default_tokenizer_model()
        )

        if is_installed:
            cache_info = self._tokenizer_service.check_model_cache(current_model)
            model_in_cache = cache_info.get("available", False)

        self._install_dialog = InstallationManagerDialog(
            is_installed=is_installed,
            is_loaded=is_loaded,
            loaded_model_name=loaded_model_name,
            settings_manager=self._settings_manager,
            settings=self._settings_manager.load_ai_settings(),
            model_in_cache=model_in_cache,
            theme_manager=self._theme_manager,
            parent=self._view,
        )

        self._install_dialog.install_triggered.connect(
            self._handle_install_transformers
        )
        self._install_dialog.remove_model_triggered.connect(self._handle_remove_model)
        self._install_dialog.load_model_triggered.connect(self._handle_ai_model_load)
        self._install_dialog.accepted.connect(self._handle_install_manager_accepted)

        self._install_dialog.destroyed.connect(self._on_install_dialog_destroyed)

        self._install_dialog.show()

    def _on_dialog_destroyed(self):
        """Handles dialog destruction."""
        sender = self.sender()

        if sender == self._settings_dialog:
            self.language_changed.disconnect(self._settings_dialog.retranslate_ui)
            self._settings_dialog = None
        elif sender == self._export_dialog:
            self.language_changed.disconnect(self._export_dialog.retranslate_ui)
            self._export_dialog = None
        elif sender == self._analysis_dialog:
            try:
                self.language_changed.disconnect(self._analysis_dialog.retranslate_ui)
            except (TypeError, RuntimeError) as e:
                logger.warning(f"[ModernPresenter] Error disconnecting language_changed for analysis_dialog: {e}")
            self._analysis_dialog = None

        elif sender == self._calendar_dialog:
            try:
                self.language_changed.disconnect(self._calendar_dialog.retranslate_ui)
                self._calendar_dialog.destroyed.disconnect(self._on_dialog_destroyed)
            except (TypeError, RuntimeError) as e:
                logger.warning(f"[ModernPresenter] Error disconnecting signals for calendar_dialog: {e}")
            self._calendar_dialog = None
        elif sender == self._help_dialog:
            try:
                self.language_changed.disconnect(self._help_dialog.retranslate_ui)
            except (TypeError, RuntimeError):
                pass
            self._help_dialog = None

    def _handle_install_transformers(self):
        """Handles transformers library installation."""
        self._run_installer_worker("install_deps")

    def _handle_remove_model(self):
        """Handles removing model from cache."""
        settings = self._settings_manager.load_ai_settings()
        model_name = settings.get(
            "tokenizer_model", self._settings_manager.get_default_tokenizer_model()
        )
        if model_name:
            self._run_installer_worker("remove_model", model_name=model_name)

    def _handle_ai_model_load(self, model_name: str):
        """Handles AI model loading."""
        if self._install_dialog:
            self._install_dialog.append_log(tr("Downloading tokenizer model '{model}'...").format(model=model_name))
            self._install_dialog.set_actions_enabled(False)

        worker = TokenizerLoadWorker(self._tokenizer_service, model_name)
        worker.signals.progress.connect(
            lambda msg: self._install_dialog.append_log(f'<span class="info">{msg}</span>') if self._install_dialog else None
        )
        worker.signals.finished.connect(self._on_tokenizer_load_finished)
        self._threadpool.start(worker)

    def _on_tokenizer_load_finished(self, success: bool, message: str, tokenizer: Optional[Any]):
        """Handles tokenizer loading completion."""
        model_name = self._tokenizer_service.get_current_model_name()
        if success and tokenizer:
            self._app_state.set_tokenizer(tokenizer, model_name)
            self._update_analysis_unit()
            self.tokenizer_changed.emit()

            if self._install_dialog:
                self._install_dialog.append_log(
                    tr("Tokenizer '{model}' loaded successfully!").format(model=model_name)
                )
                is_installed = self._tokenizer_service.is_transformers_available()
                is_loaded = self._app_state.has_tokenizer()
                self._install_dialog.set_status(
                    is_installed, is_loaded, model_in_cache=True, loaded_model_name=model_name
                )
        else:
            logger.error(f"Failed to load tokenizer {model_name}: {message}")
            if self._install_dialog:
                self._install_dialog.append_log(tr("Error loading tokenizer: {error}").format(error=message))
            self.tokenizer_load_failed.emit(message)

        if self._install_dialog:
            self._install_dialog.set_actions_enabled(True)

    def _run_installer_worker(self, action: str, model_name: str | None = None):
        """Starts worker for installing/removing AI components."""
        if not self._install_dialog or self._installer_worker is not None:
            return

        self._view.show_status(
            message_key="Executing: {command}",
            format_args={"command": action}
        )
        self._install_dialog.set_actions_enabled(False)
        self._installer_worker = AIInstallerWorker(action, model_name)
        self._installer_worker.signals.progress.connect(self._on_install_progress)
        self._installer_worker.signals.finished.connect(self._on_install_finished)
        QThreadPool.globalInstance().start(self._installer_worker)

    def _on_install_progress(self, message: str):
        """Handles installation progress."""
        if self._install_dialog and not self._install_dialog.isHidden():
            try:

                if any(keyword in message.lower() for keyword in ["error", "failed", "exception"]):
                    log_type = "error"
                elif any(keyword in message.lower() for keyword in ["warning", "warn"]):
                    log_type = "status"
                else:
                    log_type = "info"
                self._install_dialog.append_log(f'<span class="{log_type}">{message}</span>')
            except RuntimeError:
                pass

    def _on_install_finished(self, success: bool, message: str):
        """Handles installation completion."""
        self._view.show_status(message_key="Operation completed.")

        if self._install_dialog and not self._install_dialog.isHidden():
            try:
                action = (
                    self._installer_worker.action
                    if self._installer_worker
                    else "install_deps"
                )

                if success and action == "remove_model":
                    removed_model_name = self._installer_worker.model_name
                    if (
                        self._app_state.tokenizer
                        and self._app_state.tokenizer_model_name == removed_model_name
                    ):
                        self._app_state.clear_tokenizer()
                        self._update_analysis_unit()
                        self.tokenizer_changed.emit()

                is_installed_now = self._tokenizer_service.is_transformers_available()
                is_loaded_now = self._app_state.has_tokenizer()

                model_in_cache = None
                if is_installed_now and not is_loaded_now:
                    ai_settings = self._settings_manager.load_ai_settings()
                    current_model = ai_settings.get(
                        "tokenizer_model",
                        self._settings_manager.get_default_tokenizer_model(),
                    )
                    cache_info = self._tokenizer_service.check_model_cache(
                        current_model
                    )
                    model_in_cache = cache_info.get("available", False)

                loaded_model_name = (
                    self._app_state.tokenizer_model_name if is_loaded_now else None
                )

                self._install_dialog.on_action_finished(
                    success=success,
                    message=message,
                    new_is_installed=is_installed_now,
                    new_is_loaded=is_loaded_now,
                    model_in_cache=model_in_cache,
                    loaded_model_name=loaded_model_name,
                )

                if success and action == "install_deps":
                    self._show_restart_notification()

            except RuntimeError:
                pass

        self._installer_worker = None

    def _show_restart_notification(self):
        """Shows restart notification (Presenter commands View)."""
        self._view.show_message_box(
            tr("Restart Required"),
            tr("Library installation completed successfully!") + "\n" + tr("Please restart the application for changes to take effect."),
            QMessageBox.Icon.Information
        )

    def _handle_install_manager_accepted(self):
        """Handles install manager dialog confirmation."""
        if not self._install_dialog:
            return

        new_settings = self._install_dialog.get_settings()
        self._settings_manager.save_ai_settings(new_settings)

    def update_disabled_nodes(self, new_disabled_set: Set[TreeNode]):
        """Updates disabled nodes."""
        old_disabled_set = self._app_state.disabled_time_nodes.copy()
        if old_disabled_set != new_disabled_set:
            self._app_state.set_disabled_nodes(new_disabled_set)
            self.disabled_nodes_changed.emit(new_disabled_set)

    def _on_app_theme_changed(self):
        """
        Handles global application theme change.
        Presenter coordinates updating all managed Views.
        """

        new_palette = self._app.palette()

        self._view.setPalette(new_palette)
        self._view.refresh_theme_styles()

        for dialog in [self._settings_dialog, self._export_dialog, self._analysis_dialog, self._install_dialog, self._calendar_dialog, self._help_dialog]:
            try:
                if dialog and dialog.isVisible():

                    dialog.setPalette(new_palette)

                    if hasattr(dialog, 'refresh_theme_styles'):
                        dialog.refresh_theme_styles()
                    else:
                        self._theme_manager.apply_theme_to_dialog(dialog)
            except RuntimeError as e:

                if dialog == self._settings_dialog:
                    self._settings_dialog = None
                elif dialog == self._export_dialog:
                    self._export_dialog = None
                elif dialog == self._analysis_dialog:
                    self._analysis_dialog = None
                elif dialog == self._install_dialog:
                    self._install_dialog = None
                elif dialog == self._calendar_dialog:
                    self._calendar_dialog = None
                elif dialog == self._help_dialog:
                    self._help_dialog = None

        self.language_changed.emit()

    def get_analysis_stats(self) -> Optional[Dict[str, int]]:
        """Returns analysis statistics considering filtering."""
        if not self._app_state.analysis_result:
            return None

        total_count = self._app_state.analysis_result.total_count

        if self._app_state.analysis_tree and self._app_state.disabled_time_nodes:
            filtered_count = self._calculate_filtered_count()
        else:
            filtered_count = total_count

        return {
            "total_count": total_count,
            "filtered_count": filtered_count,
            "disabled_count": total_count - filtered_count,
        }

    def _calculate_filtered_count(self) -> int:
        """Calculates the number of tokens/characters after filtering."""
        if not self._app_state.analysis_tree:
            return 0

        return self._calculate_tree_value_excluding_disabled(
            self._app_state.analysis_tree
        )

    def _calculate_tree_value_excluding_disabled(self, node) -> int:
        """Recursively calculates the value of the tree, excluding disabled nodes."""
        from core.analysis.tree_analyzer import TreeNode

        if not isinstance(node, TreeNode):
            return 0

        if node in self._app_state.disabled_time_nodes:
            return 0

        if node.children:
            total = 0
            for child in node.children:
                total += self._calculate_tree_value_excluding_disabled(child)
            return total
        else:
            return node.value

    def get_current_chat(self) -> Optional[Chat]:
        """Returns the currently loaded chat."""
        return self._app_state.loaded_chat

    def get_analysis_result(self) -> Optional[AnalysisResult]:
        """Returns the analysis result."""
        return self._app_state.analysis_result

    def get_analysis_tree(self) -> Optional[TreeNode]:
        """Returns the analysis tree."""
        return self._app_state.analysis_tree

    def get_config(self) -> Dict[str, Any]:
        """Returns a copy of the current configuration."""
        return self._app_state.ui_config.copy()

    def get_disabled_nodes(self) -> Set[TreeNode]:
        """Returns a copy of disabled nodes."""
        return self._app_state.disabled_time_nodes.copy()

    def has_chat_loaded(self) -> bool:
        """Checks if a chat is loaded."""
        return self._app_state.has_chat_loaded()

    def get_app_state(self) -> AppState:
        """Returns the application state (for complex dialogs)."""
        return self._app_state

    def get_current_file_path(self) -> Optional[str]:
        """Returns the path to the currently loaded file."""
        return self._chat_service.get_current_file_path()

    def set_processing_state_in_view(self, is_processing: bool, message: str = "", message_key: str = None, format_args: dict = None):
        """Proxy method for calling set_processing_state in view."""
        if message_key:
            translated_message = tr(message_key)
            self._app_state.set_processing_state(is_processing, translated_message)
        else:
            self._app_state.set_processing_state(is_processing, message)

        if hasattr(self._view, 'set_processing_state'):
            self._view.set_processing_state(is_processing, None, message_key, format_args)
        else:
            logger.warning("View does not have set_processing_state method")

    def on_drop_zone_hover_state_changed(self, is_hovered: bool):
        if self._is_drop_zone_drag_active:
            self._is_drop_zone_drag_active = False

        self._is_drop_zone_hovered = is_hovered
        self._update_drop_zone_style()

    def on_drop_zone_drag_active(self, is_active: bool):
        self._is_drop_zone_drag_active = is_active
        self._update_drop_zone_style()

    def _update_drop_zone_style(self):
        """Updates drop_zone style based on state."""
        if self._is_drop_zone_drag_active:

            self.set_drop_zone_style_command.emit("border: 2px solid #0078d4; background-color: rgba(0, 120, 212, 0.1);")
        else:

            self.set_drop_zone_style_command.emit("border: 2px dashed #aaa;")


--- Файл: ./src/presenters/app_state.py ---
"""
Centralized application state.

Contains application data and provides centralized access
for state management across the application.
"""

from dataclasses import dataclass, field
from typing import Any, Dict, Optional, Set

from core.analysis.tree_analyzer import TreeNode
from core.domain.models import AnalysisResult, Chat

@dataclass
class AppState:
    """Application state."""

    loaded_chat: Optional[Chat] = None
    chat_file_path: Optional[str] = None

    analysis_result: Optional[AnalysisResult] = None
    analysis_tree: Optional[TreeNode] = None

    tokenizer: Optional[Any] = None
    tokenizer_model_name: Optional[str] = None

    ui_config: Dict[str, Any] = field(
        default_factory=lambda: {
            "profile": "group",
            "auto_detect_profile": True,
            "auto_recalc": False,
            "show_time": True,
            "show_reactions": True,
            "show_reaction_authors": False,
            "my_name": "Me",
            "partner_name": "Partner",
            "show_optimization": False,
            "streak_break_time": "20:00",
            "show_markdown": True,
            "show_links": True,
            "show_tech_info": True,
            "show_service_notifications": True,
            "truncate_name_length": 20,
            "truncate_quote_length": 50,
        }
    )

    disabled_time_nodes: Set[TreeNode] = field(default_factory=set)

    last_analysis_unit: str = "Characters"
    last_analysis_count: int = 0

    is_processing: bool = False
    current_status_message: str = ""

    def __post_init__(self):
        """Initialization after object creation."""
        if "my_name" not in self.ui_config:
            from resources.translations import tr

            self.ui_config["my_name"] = tr("Me")
            self.ui_config["partner_name"] = tr("Partner")

        self.ui_config.setdefault("auto_detect_profile", True)
        self.ui_config.setdefault("auto_recalc", False)

    def has_chat_loaded(self) -> bool:
        """Checks if chat is loaded."""
        return self.loaded_chat is not None

    def clear_chat(self):
        """Clears loaded chat and related data."""
        self.loaded_chat = None
        self.chat_file_path = None
        self.analysis_result = None
        self.analysis_tree = None
        self.disabled_time_nodes.clear()
        self.last_analysis_count = 0

    def set_chat(self, chat: Chat, file_path: str):
        """
        Sets new chat.

        Args:
            chat: Loaded chat
            file_path: Path to chat file
        """
        self.clear_chat()
        self.loaded_chat = chat
        self.chat_file_path = file_path

    def get_chat_name(self) -> str:
        """Returns current chat name or default value."""
        if self.loaded_chat:
            return self.loaded_chat.name
        from resources.translations import tr

        return tr("chat_history")

    def has_analysis_data(self) -> bool:
        """Checks if there are analysis results."""
        return self.analysis_result is not None and self.analysis_result.total_count > 0

    def set_analysis_result(self, result: AnalysisResult):
        """
        Sets analysis result.

        Args:
            result: Analysis result
        """
        self.analysis_result = result
        self.last_analysis_unit = result.unit
        self.last_analysis_count = result.total_count

        self.analysis_tree = None

    def set_analysis_tree(self, tree: TreeNode):
        """
        Sets analysis tree.

        Args:
            tree: Analysis tree
        """
        self.analysis_tree = tree

    def clear_analysis(self):
        """Clears analysis results."""
        self.analysis_result = None
        self.analysis_tree = None
        self.disabled_time_nodes.clear()
        self.last_analysis_count = 0

    def has_tokenizer(self) -> bool:
        """Checks if tokenizer is loaded."""
        return self.tokenizer is not None

    def set_tokenizer(self, tokenizer: Any, model_name: str):
        """
        Sets tokenizer.

        Args:
            tokenizer: Tokenizer
            model_name: Model name
        """
        self.tokenizer = tokenizer
        self.tokenizer_model_name = model_name

        if self.analysis_result and self.analysis_result.unit == "tokens":
            self.clear_analysis()

    def clear_tokenizer(self):
        """Clears tokenizer."""
        self.tokenizer = None
        self.tokenizer_model_name = None

        if self.analysis_result and self.analysis_result.unit == "tokens":
            self.clear_analysis()

    def get_preferred_analysis_unit(self) -> str:
        """Returns preferred analysis unit."""
        return "tokens" if self.has_tokenizer() else "Characters"

    def get_config_value(self, key: str, default: Any = None) -> Any:
        """
        Gets value from configuration.

        Args:
            key: Configuration key
            default: Default value

        Returns:
            Any: Configuration value
        """
        return self.ui_config.get(key, default)

    def set_config_value(self, key: str, value: Any):
        """
        Sets value in configuration.

        Args:
            key: Configuration key
            value: New value
        """
        import logging
        logger = logging.getLogger("AppState")

        old_value = self.ui_config.get(key)
        if old_value != value:
            self.ui_config[key] = value

            if key in [
                "profile",
                "show_service_notifications",
                "show_markdown",
                "show_links",
                "show_time",
                "show_reactions",
                "show_reaction_authors",
                "show_optimization",
                "streak_break_time",
                "show_tech_info",
                "my_name",
                "partner_name",
            ]:
                self.clear_analysis()

    def update_config(self, new_config: Dict[str, Any]):
        """
        Updates configuration.

        Args:
            new_config: New configuration
        """
        old_config = self.ui_config.copy()
        self.ui_config.update(new_config)

        important_keys = [
            "profile",
            "show_service_notifications",
            "show_markdown",
            "show_links",
            "show_time",
            "show_reactions",
            "show_reaction_authors",
            "show_optimization",
            "streak_break_time",
            "show_tech_info",
            "my_name",
            "partner_name",
        ]
        if any(old_config.get(key) != new_config.get(key) for key in important_keys):
            self.clear_analysis()

    def set_disabled_nodes(self, nodes: Set[TreeNode]):
        """
        Sets disabled nodes.

        Args:
            nodes: Set of disabled nodes
        """
        self.disabled_time_nodes = nodes.copy()

    def add_disabled_node(self, node: TreeNode):
        """
        Adds node to disabled ones.

        Args:
            node: Node to disable
        """
        self.disabled_time_nodes.add(node)

    def remove_disabled_node(self, node: TreeNode):
        """
        Removes node from disabled ones.

        Args:
            node: Node to enable
        """
        self.disabled_time_nodes.discard(node)

    def clear_disabled_nodes(self):
        """Clears all disabled nodes."""
        self.disabled_time_nodes.clear()

    def has_disabled_nodes(self) -> bool:
        """Checks if there are disabled nodes."""
        return len(self.disabled_time_nodes) > 0

    def set_processing_state(self, is_processing: bool, message: str = ""):
        """
        Sets processing state.

        Args:
            is_processing: Processing state flag
            message: Current operation message
        """
        self.is_processing = is_processing
        self.current_status_message = message

    def is_ready_for_operation(self) -> bool:
        """Checks if application is ready for operations."""
        return not self.is_processing and self.has_chat_loaded()

    def get_state_summary(self) -> Dict[str, Any]:
        """
        Returns current state summary.

        Returns:
            Dict[str, Any]: State summary
        """
        return {
            "has_chat": self.has_chat_loaded(),
            "chat_name": self.get_chat_name() if self.has_chat_loaded() else None,
            "message_count": (
                self.loaded_chat.total_message_count if self.has_chat_loaded() else 0
            ),
            "has_tokenizer": self.has_tokenizer(),
            "tokenizer_model": self.tokenizer_model_name,
            "has_analysis": self.has_analysis_data(),
            "analysis_unit": self.last_analysis_unit,
            "analysis_count": self.last_analysis_count,
            "disabled_nodes_count": len(self.disabled_time_nodes),
            "is_processing": self.is_processing,
            "current_profile": self.get_config_value("profile", "group"),
        }

    def validate_state(self) -> list[str]:
        """
        Validates current state and returns list of issues.

        Returns:
            list[str]: List of found issues
        """
        issues = []

        if self.has_analysis_data() and not self.has_chat_loaded():
            issues.append("There are analysis results, but no loaded chat")

        if (
            self.analysis_result
            and self.analysis_result.unit == "tokens"
            and not self.has_tokenizer()
        ):
            issues.append("Analysis in tokens, but tokenizer is not loaded")

        if self.has_chat_loaded() and not self.loaded_chat.messages:
            issues.append("Empty chat loaded")

        profile = self.get_config_value("profile")
        if profile not in ["group", "personal", "posts", "channel"]:
            issues.append(f"Incorrect profile: {profile}")

        return issues


--- Файл: ./src/presenters/analysis_presenter.py ---
import logging
from typing import Optional, Set

from PyQt6.QtCore import QObject, pyqtSignal

from core.analysis.tree_analyzer import TreeNode

logger = logging.getLogger(__name__)

class AnalysisPresenter(QObject):

    filter_changed = pyqtSignal(set)

    def __init__(self):
        super().__init__()
        self.view = None

    def get_view(self, parent):

        from ui.dialogs.analysis.analysis_dialog import AnalysisDialog
        from ui.theme import ThemeManager

        if self.view is None:
            self.view = AnalysisDialog(
                presenter=self,
                theme_manager=ThemeManager.get_instance(),
                parent=parent,
            )

            self.view.rejected.connect(self.on_view_closed)
            self.view.finished.connect(self.on_view_closed)
        return self.view

    def load_analysis_data(self, root_node: TreeNode, initial_disabled_nodes: Set[TreeNode], unit: str):
        if self.view:
            self.view.load_data_and_show(root_node, initial_disabled_nodes, unit)
        else:
            logger.error("[AnalysisPresenter] view is None, cannot load data")

    def on_filter_accepted(self, new_disabled_nodes: set):
        self.filter_changed.emit(new_disabled_nodes)

    def on_view_closed(self):

        self.view = None



--- Файл: ./src/presenters/file_presenter.py ---
import logging
from typing import Optional

from PyQt6.QtCore import QObject, QThreadPool, pyqtSignal

from core.application.chat_service import ChatService
from core.domain.models import Chat
from presenters.app_state import AppState
from presenters.workers import ChatLoadWorker

logger = logging.getLogger(__name__)

class FilePresenter(QObject):
    """Presenter for managing file loading and drop zone functionality."""

    chat_loaded = pyqtSignal(bool, str, str)
    profile_auto_detected = pyqtSignal(str)
    preview_updated = pyqtSignal(str, str)
    set_drop_zone_style_command = pyqtSignal(str)

    def __init__(self, view, app_state: AppState, chat_service: ChatService, preview_service):
        super().__init__()
        self._view = view
        self._app_state = app_state
        self._chat_service = chat_service
        self._preview_service = preview_service

        self._threadpool = QThreadPool()
        self._current_workers = []

        self._is_drop_zone_hovered = False
        self._is_drop_zone_drag_active = False

        self._connect_signals()

    def _connect_signals(self):
        """Connects UI signals to presenter methods."""

    def on_file_dropped(self, path: str):
        """Handles file drag-and-drop."""
        if self._app_state.is_processing:
            logger.warning("Application is already processing a file, ignoring new one")
            return

        self.set_processing_state_in_view(True, message_key="Loading file...")

        worker = ChatLoadWorker(self._chat_service, path)
        worker.signals.progress.connect(self._view.show_status)
        worker.signals.finished.connect(self._on_chat_load_finished)

        self._current_workers.append(worker)
        self._threadpool.start(worker)

    def _on_chat_load_finished(self, success: bool, message: str, result: Optional[Chat]):
        """Handles chat loading completion."""
        self.set_processing_state_in_view(False)

        if success and result:
            auto_detect_enabled = self._app_state.get_config_value("auto_detect_profile", True)

            if auto_detect_enabled:
                detected_profile = self._chat_service.detect_chat_type(result)
                current_profile = self._app_state.get_config_value("profile")

                if detected_profile != current_profile:
                    self._app_state.set_config_value("profile", detected_profile)
                    self.profile_auto_detected.emit(detected_profile)

            file_path = self._chat_service.get_current_file_path()
            self._app_state.set_chat(result, file_path)

            if auto_detect_enabled:
                self._update_preview()

            chat_name = self._app_state.get_chat_name()
            self.chat_loaded.emit(True, "", chat_name)

        else:
            self.chat_loaded.emit(False, message, "")

    def _update_preview(self):
        """Updates preview after file loading."""
        try:
            config = self._app_state.ui_config
            raw_text, title = self._preview_service.generate_preview_text(config)
            self.preview_updated.emit(raw_text, title)
        except Exception as e:
            logger.error(f"Error updating preview: {e}")
            error_message = f"Error: {e}"
            self.preview_updated.emit(error_message, "Preview Error")

    def on_drop_zone_hover_state_changed(self, is_hovered: bool):
        """Handles drop zone hover state changes."""
        if self._is_drop_zone_drag_active:
            self._is_drop_zone_drag_active = False

        self._is_drop_zone_hovered = is_hovered
        self._update_drop_zone_style()

    def on_drop_zone_drag_active(self, is_active: bool):
        """Handles drop zone drag active state changes."""
        self._is_drop_zone_drag_active = is_active
        self._update_drop_zone_style()

    def _update_drop_zone_style(self):
        """Updates drop zone style based on state."""
        if self._is_drop_zone_drag_active:
            self.set_drop_zone_style_command.emit(
                "border: 2px solid #0078d4; background-color: rgba(0, 120, 212, 0.1);"
            )
        else:
            self.set_drop_zone_style_command.emit("border: 2px dashed #aaa;")

    def set_processing_state_in_view(self, is_processing: bool, message: str = "", message_key: str = None, format_args: dict = None):
        """Proxy method for calling set_processing_state in view."""
        if message_key:
            from resources.translations import tr
            translated_message = tr(message_key)
            self._app_state.set_processing_state(is_processing, translated_message)
        else:
            self._app_state.set_processing_state(is_processing, message)

        if hasattr(self._view, 'set_processing_state'):
            self._view.set_processing_state(is_processing, None, message_key, format_args)
        else:
            logger.warning("View does not have set_processing_state method")

    def get_current_file_path(self) -> Optional[str]:
        """Returns the path to the currently loaded file."""
        return self._chat_service.get_current_file_path()

    def has_chat_loaded(self) -> bool:
        """Checks if a chat is loaded."""
        return self._app_state.has_chat_loaded()

    def get_current_chat(self) -> Optional[Chat]:
        """Returns the currently loaded chat."""
        return self._app_state.loaded_chat


--- Файл: ./src/presenters/calendar_presenter.py ---
"""
Presenter for calendar dialog.

Manages communication between CalendarService and UI components,
processes user interactions and maintains ViewModel state.
"""

import logging
from datetime import datetime
from typing import List, Optional, Set, Dict, Any

from PyQt6.QtCore import QDate, QObject, pyqtSignal

logger = logging.getLogger(__name__)

from core.analysis.tree_analyzer import TreeNode
from core.application.calendar_service import CalendarService, DateHierarchy
from core.conversion.context import ConversionContext
from core.conversion.message_formatter import format_message
from resources.translations import tr
from core.view_models import CalendarDayInfo, CalendarMonthInfo, CalendarViewModel

class CalendarPresenter(QObject):
    """Presenter for calendar dialog."""

    view_model_updated = pyqtSignal(object)
    messages_for_date_updated = pyqtSignal(object)
    filter_changed = pyqtSignal(set)

    def __init__(self, calendar_service: CalendarService):
        super().__init__()
        self._calendar_service = calendar_service
        self._current_hierarchy: Optional[DateHierarchy] = None
        self._current_disabled_nodes: Set[TreeNode] = set()
        self._view_model = CalendarViewModel(current_year=2024, current_month=1, current_day=1)
        self.last_valid_selection: Optional[QDate] = None
        self._view_model.view_mode = "days"
        self._token_hierarchy: Dict[str, Dict[str, Dict[str, float]]] = {}

        self._raw_messages: List[Dict[str, Any]] = []
        self._conversion_context: Optional[ConversionContext] = None

    def load_calendar_data(
        self,
        raw_messages: List[dict],
        analysis_tree: Optional[TreeNode],
        initial_disabled_nodes: Set[TreeNode],
        token_hierarchy: dict | None = None,
        config: dict | None = None,
    ):
        self._raw_messages = raw_messages
        self._current_hierarchy = self._calendar_service.build_date_hierarchy_from_raw_messages(
            raw_messages, analysis_tree
        )
        self._current_disabled_nodes = initial_disabled_nodes.copy()
        self._token_hierarchy = token_hierarchy or {}

        if config:
            message_map = {msg["id"]: msg for msg in raw_messages if "id" in msg}
            self._conversion_context = ConversionContext(config=config, message_map=message_map)

        start_date, end_date = self._current_hierarchy.get_date_range()
        initial_date = end_date or start_date
        if initial_date:
            self._view_model.current_year = initial_date.year()
            self._view_model.current_month = initial_date.month()
            self.last_valid_selection = initial_date
        else:
            today = QDate.currentDate()
            self._view_model.current_year = today.year()
            self._view_model.current_month = today.month()
            self.last_valid_selection = None

        self._update_view_model()
        if self.last_valid_selection:
            self.emit_messages_for_date(self.last_valid_selection)

    def emit_messages_for_date(self, date: QDate):
        """Formats and emits messages for specified date."""

        formatted_messages = self._format_messages_for_date(date)
        self.messages_for_date_updated.emit(formatted_messages)

    def _format_messages_for_date(self, date: QDate) -> str:
        """Internal method for formatting messages for a day."""
        if not self._raw_messages or not self._conversion_context:
            return tr("No messages on this date.")

        messages_for_day = [
            msg for msg in self._raw_messages
            if "date" in msg and datetime.fromisoformat(msg["date"]).date() == date.toPyDate()
        ]

        if not messages_for_day:
            return tr("No messages on this date.")

        output_parts = []
        previous_message = None

        sorted_messages = sorted(messages_for_day, key=lambda m: m.get("date", ""))
        for msg in sorted_messages:
            formatted_text = ""
            if msg.get("type") == "message":
                formatted_text = format_message(
                    msg, previous_message, self._conversion_context, html_mode=True
                )
                previous_message = msg
            if formatted_text:
                output_parts.append(formatted_text)

        return "".join(output_parts).strip()

    def set_view_mode(self, mode: str):
        if self._view_model.view_mode != mode:
            self._view_model.view_mode = mode
            self._update_view_model()

    def navigate_previous(self):
        current_date_base = QDate(self._view_model.current_year, self._view_model.current_month, 1)
        if self._view_model.view_mode == "days":
            new_date = self._calendar_service.find_adjacent_month(current_date_base, -1, self._current_hierarchy)
            if new_date:
                self.navigate_to_date(new_date)
        elif self._view_model.view_mode == "months":
            new_date = self._calendar_service.find_adjacent_year(current_date_base, -1, self._current_hierarchy)
            if new_date:
                self.navigate_to_date(new_date)

    def navigate_next(self):
        current_date_base = QDate(self._view_model.current_year, self._view_model.current_month, 1)
        if self._view_model.view_mode == "days":
            new_date = self._calendar_service.find_adjacent_month(current_date_base, 1, self._current_hierarchy)
            if new_date:
                self.navigate_to_date(new_date)
        elif self._view_model.view_mode == "months":
            new_date = self._calendar_service.find_adjacent_year(current_date_base, 1, self._current_hierarchy)
            if new_date:
                self.navigate_to_date(new_date)

    def navigate_to_date(self, date: QDate):
        self._view_model.current_year = date.year()
        self._view_model.current_month = date.month()
        self._update_view_model()

    def select_date(self, date: QDate):
        if self._current_hierarchy and self._calendar_service.get_message_count_for_date(date, self._current_hierarchy) > 0:
            self.last_valid_selection = date
            self._update_view_model()
            self.emit_messages_for_date(date)

    def select_month(self, year: int, month: int):
        self._view_model.current_year = year
        self._view_model.current_month = month
        self.set_view_mode("days")

    def select_year(self, year: int):
        self._view_model.current_year = year
        self.set_view_mode("months")

    def toggle_filter_for_date(self, date: QDate):
        if not self._current_hierarchy: return
        node = self._current_hierarchy.date_to_node_map.get(date)
        if node:
            self.toggle_filter_for_node(node)

    def toggle_filter_for_month(self, year: int, month: int):
        if not self._current_hierarchy: return
        month_key = (year, month)
        node = self._current_hierarchy.month_to_node_map.get(month_key)
        if node:
            self.toggle_filter_for_node(node)

    def toggle_filter_for_year(self, year: int):
        if not self._current_hierarchy: return
        node = self._current_hierarchy.year_to_node_map.get(year)
        if node:
            self.toggle_filter_for_node(node)

    def toggle_filter_for_node(self, node: TreeNode):
        day_nodes = self._get_descendant_day_nodes(node)
        if not day_nodes:
            return

        all_disabled = all(d in self._current_disabled_nodes for d in day_nodes)

        if all_disabled:
            self._current_disabled_nodes.difference_update(day_nodes)
        else:
            self._current_disabled_nodes.update(day_nodes)

        self._update_view_model()

        self._update_view_model()

    def _get_descendant_day_nodes(self, node: TreeNode) -> list[TreeNode]:
        is_leafy = not node.children and not (hasattr(node, "aggregated_children") and node.aggregated_children)
        if is_leafy:
            if node.name.isdigit():
                return [node]
            return []

        day_nodes = []
        children_to_scan = node.children[:]
        if hasattr(node, "aggregated_children") and node.aggregated_children:
            children_to_scan.extend(node.aggregated_children)

        for child in children_to_scan:
            day_nodes.extend(self._get_descendant_day_nodes(child))

        return day_nodes

    def set_disabled_nodes(self, disabled_nodes: Set[TreeNode]):
        old_disabled_nodes = self._current_disabled_nodes.copy()
        if old_disabled_nodes != disabled_nodes:
            self._current_disabled_nodes = disabled_nodes.copy()
            self._update_view_model()

            self.filter_changed.emit(self._current_disabled_nodes)

    def get_disabled_nodes(self) -> Set[TreeNode]:
        return self._current_disabled_nodes.copy()

    def get_current_view_model(self) -> CalendarViewModel:
        return self._view_model

    def _update_view_model(self):
        if not self._current_hierarchy: return

        if self._view_model.view_mode == "days":
            self._update_day_view_model()
        elif self._view_model.view_mode == "months":
            self._update_month_view_model()
        elif self._view_model.view_mode == "years":
            self._update_year_view_model()

        self._update_navigation_state()
        self._update_statistics()
        self.view_model_updated.emit(self._view_model)

    def _update_day_view_model(self):
        year, month = self._view_model.current_year, self._view_model.current_month
        self._view_model.days_in_current_month = []

        first_day_of_month = QDate(year, month, 1)
        start_date = first_day_of_month.addDays(-(first_day_of_month.dayOfWeek() - 1))

        for i in range(42):
            current_date = start_date.addDays(i)

            is_in_month = current_date.month() == month

            message_count = self._calendar_service.get_message_count_for_date(current_date, self._current_hierarchy)

            is_available = message_count > 0

            is_disabled = self._calendar_service.is_date_disabled_for_export(current_date, self._current_disabled_nodes, self._current_hierarchy)

            year_str, month_str, day_str = str(current_date.year()), f"{current_date.month():02d}", f"{current_date.day():02d}"
            token_count = self._token_hierarchy.get(year_str, {}).get(month_str, {}).get(day_str, 0)

            display_value = f"{int(token_count)}" if token_count > 0 else f"{message_count}"

            day_info = CalendarDayInfo(
                date=current_date,
                message_count=display_value,
                is_available=is_available,
                is_disabled=is_disabled,
                is_selected=(self.last_valid_selection and current_date == self.last_valid_selection),
                is_in_current_month=is_in_month
            )
            self._view_model.days_in_current_month.append(day_info)

        self._view_model.navigation_title = f"{tr(f'month_{month}')} {year}"

    def _update_month_view_model(self):
        year = self._view_model.current_year
        self._view_model.months_in_current_year = []

        for month_num in range(1, 13):
            has_messages = self._calendar_service.has_messages_in_month(year, month_num, self._current_hierarchy)

            year_str, month_str = str(year), f"{month_num:02d}"
            month_token_data = self._token_hierarchy.get(year_str, {}).get(month_str, {})
            month_token_count = sum(month_token_data.values())

            message_count = sum(self._calendar_service.get_message_count_for_date(d, self._current_hierarchy) for d in self._calendar_service.get_dates_in_month(year, month_num, self._current_hierarchy))
            display_value = f"{int(month_token_count)}" if month_token_count > 0 else f"{message_count}"

            is_disabled = False
            month_node = self._current_hierarchy.month_to_node_map.get((year, month_num))
            if month_node:
                day_nodes = self._get_descendant_day_nodes(month_node)
                if day_nodes: is_disabled = all(d in self._current_disabled_nodes for d in day_nodes)

            self._view_model.months_in_current_year.append(CalendarMonthInfo(
                year=year, month=month_num, name=tr(f"month_{month_num}"),
                message_count=display_value, days=[], is_current=False,
                is_available=has_messages, is_disabled=is_disabled,
            ))
        self._view_model.navigation_title = str(year)

    def _update_year_view_model(self):
        self._view_model.available_years = []
        if not self._current_hierarchy or not self._current_hierarchy.sorted_years:
            return

        for year in self._current_hierarchy.sorted_years:
            year_str = str(year)
            year_token_data = self._token_hierarchy.get(year_str, {})
            year_token_count = sum(sum(month.values()) for month in year_token_data.values())

            year_msg_count = sum(self._calendar_service.get_message_count_for_date(d, self._current_hierarchy) for d in self._current_hierarchy.messages_by_date if d.year() == year)
            display_value = f"{int(year_token_count)}" if year_token_count > 0 else f"{year_msg_count}"

            is_disabled = False
            year_node = self._current_hierarchy.year_to_node_map.get(year)
            if year_node:
                day_nodes = self._get_descendant_day_nodes(year_node)
                if day_nodes: is_disabled = all(d in self._current_disabled_nodes for d in day_nodes)

            self._view_model.available_years.append(CalendarMonthInfo(
                year=year, month=0, name=str(year), message_count=display_value,
                days=[], is_current=(year == self._view_model.current_year),
                is_available=True, is_disabled=is_disabled,
            ))

        self._view_model.navigation_title = tr("Years")

    def _update_navigation_state(self):
        if not self._current_hierarchy:
            self._view_model.can_go_previous = self._view_model.can_go_next = False
            return

        current_date = QDate(self._view_model.current_year, self._view_model.current_month, 1)
        if self._view_model.view_mode == "days":
            self._view_model.can_go_previous = self._calendar_service.find_adjacent_month(current_date, -1, self._current_hierarchy) is not None
            self._view_model.can_go_next = self._calendar_service.find_adjacent_month(current_date, 1, self._current_hierarchy) is not None
        elif self._view_model.view_mode == "months":
            self._view_model.can_go_previous = self._calendar_service.find_adjacent_year(current_date, -1, self._current_hierarchy) is not None
            self._view_model.can_go_next = self._calendar_service.find_adjacent_year(current_date, 1, self._current_hierarchy) is not None
        else:
            self._view_model.can_go_previous = self._view_model.can_go_next = False

    def _update_statistics(self):
        if not self._current_hierarchy: return

        total_dates = len(self._current_hierarchy.messages_by_date)
        disabled_dates = self._calendar_service.get_filtered_dates(self._current_disabled_nodes, self._current_hierarchy)

        self._view_model.total_available_dates = total_dates
        self._view_model.total_disabled_dates = len(disabled_dates)
        self._view_model.selected_dates_count = total_dates - len(disabled_dates)


--- Файл: ./src/resources/translations.py ---
_current_language = "ru"

en_translations = {
    "Profile": "Profile",
    "Group Chat": "Group Chat",
    "Posts and Comments": "Posts and Comments",
    "Personal Chat": "Personal Chat",
    "Names for Personal Chat": "Names for Personal Chat",
    "Your name (in chat):": "Your name (in chat):",
    "Partner's name:": "Partner's name:",
    "Options": "Options",
    "Show message time": "Show message time",
    "Show reactions": "Show reactions",
    "Show reaction authors": "Show reaction authors",
    "Optimization": "Optimization",
    "Streak break time:": "Streak break time:",
    "Show Markdown": "Show Markdown",
    "Show links": "Show links",
    "Show technical information": "Show technical information",
    "Show service notifications": "Show service notifications",
    "Preview": "Preview",
    "Terminal": "Terminal",
    "Drag and drop result.json file here": "Drag and drop result.json file here",
    "Settings": "Settings",
    "Save to file...": "Save to file",
    "Tkonverter": "Tkonverter",
    "Ready to work": "Ready to work",
    "Loading file...": "Loading file...",
    "Updating preview...": "Updating preview...",
    "File loaded: {filename}": "File loaded: {filename}",
    "Loading error.": "Loading error.",
    "Please load a JSON file first.": "Please load a JSON file first.",
    "Saving file...": "Saving file...",
    "File saved: {path}": "File saved: {path}",
    "Error saving file: {error}": "Error saving file: {error}",
    "Chat name: {name}": "Chat name: {name}",
    "Preview: Group example": "Example: Group Chat",
    "Preview: Personal example": "Example: Personal Chat",
    "Preview: Posts example": "Example: Posts and Comments",
    "Preview: Example Group": "Example Group",
    "Preview: Channel example": "Example: Channel",
    "Preview: Example Channel": "Example Channel",
    "Preview: Alaisa": "Alaisa",
    "Preview: Alice": "Alice",
    "Preview: Bob": "Bob",
    "Preview: Alexander": "Alexander",
    "Preview: Misha": "Misha",
    "Preview: Main Editor": "Main Editor",
    "Preview: Hello everyone!": "Hello everyone!",
    "Preview: One moment": "One moment",
    "Preview: Thanks": "Thanks",
    "Preview: Almost midnight...": "Almost midnight...",
    "Preview: Happy New Year!": "Happy New Year!",
    "Preview: New Telegram Update": "New important update in Telegram that everyone has been waiting for",
    "Preview: Update description": "Today a new update was released, now Telegram has a built-in TON wallet.",
    "Preview: Why do we need this?": "Why do we need this?",
    "Preview: If you don't need it...": "If 'you don't need it', it doesn't mean that **everyone** doesn't need it!",
    "Preview: This is a second message from me.": "This is a second message from me.",
    "Personal correspondence": "Personal correspondence",
    "Channel": "Channel",
    "Group chat": "Group chat",
    "Me": "Me",
    "Partner": "Partner",
    "{actor} created group «{title}»": "{actor} created group «{title}»",
    " and invited {members}": " and invited {members}",
    "{actor} invited {members}": "{actor} invited {members}",
    "{actor} left the group": "{actor} left the group",
    "{actor} removed {member}": "{actor} removed {member}",
    "Outgoing call": "Outgoing call",
    "Incoming call": "Incoming call",
    ", duration: {duration}": ", duration: {duration}",
    " (missed)": " (missed)",
    " (declined)": " (declined)",
    "{actor} started a video chat": "{actor} started a video chat",
    "{actor} joined group by link from {inviter}": "{actor} joined group by link from {inviter}",
    "{actor} joined group by link": "{actor} joined group by link",
    " and {remaining_count} more": " and {remaining_count} more",
    "[SPOILER]": "[SPOILER]",
    "[Poll]": "[Poll]",
    "Signature: {signature}": "Signature: {signature}",
    " (from: {authors})": " (from: {authors})",
    "Theme:": "Theme:",
    "Auto": "Auto",
    "Light": "Light",
    "Dark": "Dark",
    "UI Font": "UI Font",
    "Built-in font": "Built-in font",
    "System default": "System default",
    "Custom": "Custom",
    "Select font...": "Select font...",
    "Truncation length": "Truncation length",
    "Nicknames:": "Nicknames:",
    "Quotes in replies:": "Quotes in replies:",
    "Auto-detect profile": "Auto-detect profile",
    "Automatic recalculation": "Automatic recalculation",
    "OK": "OK",
    "Language:": "Language:",
    "English": "English",
    "Russian": "Russian",
    "Export Chat": "Export Chat",
    "Folder to save:": "Folder to save:",
    "Browse...": "Browse...",
    "Error": "Error",
    "No Data": "No Data",
    "Token Analysis by Date": "Token Analysis by Date",
    "Analyzing...": "Analyzing...",
    "Rendering chart...": "Rendering chart...",
    "No messages on this date.": "No messages on this date.",
    "Choose folder": "Choose folder",
    "From Favorites": "From Favorites",
    "Please calculate total tokens first by clicking 'Recalculate'.": "Please calculate total tokens first by clicking 'Recalculate'.",
    "Unknown Chat": "Unknown Chat",
    "User": "User",
    "System": "System",
    "disabled": "disabled",
    "24 hours": "24 hours",
    "7 days": "7 days",
    "1 month": "1 month",
    "{days} d.": "{days} d.",
    "{hours} h.": "{hours} h.",
    "{minutes} min.": "{minutes} min.",
    "{seconds} sec.": "{seconds} sec.",
    "unknown source": "unknown source",
    "file": "file",
    "Analyzing...": "Analyzing...",
    "Token Count": "Token Count",
    "chat_history": "chat_history",
    "weekday_mon": "Mon",
    "weekday_tue": "Tue",
    "weekday_wed": "Wed",
    "weekday_thu": "Thu",
    "weekday_fri": "Fri",
    "weekday_sat": "Sat",
    "weekday_sun": "Sun",
    "month_gen_1": "January",
    "month_gen_2": "February",
    "month_gen_3": "March",
    "month_gen_4": "April",
    "month_gen_5": "May",
    "month_gen_6": "June",
    "month_gen_7": "July",
    "month_gen_8": "August",
    "month_gen_9": "September",
    "month_gen_10": "October",
    "month_gen_11": "November",
    "month_gen_12": "December",
    "month_1": "January",
    "month_2": "February",
    "month_3": "March",
    "month_4": "April",
    "month_5": "May",
    "month_6": "June",
    "month_7": "July",
    "month_8": "August",
    "month_9": "September",
    "month_10": "October",
    "month_11": "November",
    "month_12": "December",
    "Use as default folder": "Use as default folder",
    "To Favorites": "To Favorites",
    "From Favorites": "From Favorites",
    "File name (without extension):": "File name (without extension):",
    "Save": "Save",
    "Choose folder": "Choose folder",
    "Cancel": "Cancel",
    "Participants": "Participants",
    "Reaction notation": "Reaction notation",
    "from": "from",
    "Unknown": "Unknown",
    "Service message from": "Service message from",
    " (edited)": " (edited)",
    "[Buttons under message]": "[Buttons under message]",
    "Row": "Row",
    "via bot": "via bot",
    "forwarded from": "forwarded from",
    "[Mini-game]": "[Mini-game]",
    "[Empty message]": "[Empty message]",
    "[Audio]": "[Audio]",
    "[Video]": "[Video]",
    "[Voice message]": "[Voice message]",
    "[Video message]": "[Video message]",
    "[Sticker]": "[Sticker]",
    "[Emoji]": "[Emoji]",
    "Custom": "Custom",
    "Emoji": "Emoji",
    "[Animation]": "[Animation]",
    "[File]": "[File]",
    "Signature": "Signature",
    "file not found": "file not found",
    "[Photo]": "[Photo]",
    "[Photo ({details})]": "[Photo ({details})]",
    "Unknown performer": "Unknown performer",
    "[Audio: {performer} - {title} ({duration})]": "[Audio: {performer} - {title} ({duration})]",
    "[Video ({details})]": "[Video ({details})]",
    "[Voice message ({duration})]": "[Voice message ({duration})]",
    "[Video message ({duration})]": "[Video message ({duration})]",
    "[Sticker {emoji}]": "[Sticker {emoji}]",
    "[Animation ({details})]": "[Animation ({details})]",
    "[File: {filename}]": "[File: {filename}]",
    "phone not specified": "phone not specified",
    "[Contact: {name}, {phone}]": "[Contact: {name}, {phone}]",
    "[Geoposition]": "[Geoposition]",
    "[Geoposition: {lat:.6f}, {lon:.6f}]": "[Geoposition: {lat:.6f}, {lon:.6f}]", "Address not specified": "Address not specified",
    "[Place: {place}, {address} (Coordinates: {lat:.6f}, {lon:.6f})]": "[Place: {place}, {address} (Coordinates: {lat:.6f}, {lon:.6f})]",
    "[Place: {place}, {address}]": "[Place: {place}, {address}]",
    "No title": "No title",
    "[Place: {title}, {address}]": "[Place: {title}, {address}]",
    "[Dice roll: {emoji} (Result: {value})]": "[Dice roll: {emoji} (Result: {value})]",
    "Question": "Question",
    "No question": "No question",
    "No text": "No text",
    "Your choice": "Your choice",
    "people_form1": "person",
    "people_form2": "people",
    "people_form5": "people",
    "Total voted": "Total voted",
    "Poll closed": "Poll closed",
    "[Game]": "[Game]",
    "Title": "Title",
    "Description": "Description",
    "[Payment invoice]": "[Payment invoice]",
    "Amount": "Amount",
    "[Media]": "[Media]",
    "pinned message": "pinned message",
    "Video chat ended, duration": "Video chat ended, duration",
    "started video chat": "started video chat",
    "duration": "duration",
    "missed": "missed",
    "busy": "busy",
    "declined": "declined",
    "created group": "created group",
    "and invited": "and invited",
    "joined group": "joined group",
    "invited": "invited",
    "joined group by link from": "joined group by link from",
    "joined group by link": "joined group by link",
    "gifted Telegram Premium": "gifted Telegram Premium",
    "for": "for",
    "months": "months",
    "time": "time",
    "times": "times",
    "boosted group": "boosted group",
    "scored": "scored",
    "points in game": "points in game",
    "Payment for": "Payment for",
    "Giveaway": "Giveaway",
    "Prize:": "Prize:",
    "Additionally:": "Additionally:",
    "Until:": "Until:",
    "{quantity} Premium subscriptions for {months} {months_text}": "{quantity} Premium subscriptions for {months} {months_text}",
    "Giveaway Results": "Giveaway Results",
    "Winners:": "Winners:",
    "month_form1": "month",
    "month_form2": "months",
    "month_form5": "months",
    "winner_form1": "winner",
    "winner_form2": "winners",
    "winner_form5": "winners",
    "unclaimed_form1": "unclaimed prize",
    "unclaimed_form2": "unclaimed prizes",
    "unclaimed_form5": "unclaimed prizes",
    "time_form1": "time",
    "time_form2": "times",
    "time_form5": "times",
    "sent": "sent",
    "created channel": "created channel",
    "changed group name to": "changed group name to",
    "changed group photo": "changed group photo",
    "deleted group photo": "deleted group photo",
    "History cleared": "History cleared",
    "converted this group to supergroup": "converted this group to supergroup",
    "converted group": "converted group",
    "to this supergroup": "to this supergroup",
    "changed chat theme to": "changed chat theme to",
    "disabled chat theme": "disabled chat theme",
    "created topic": "created topic",
    "changed topic name to": "changed topic name to",
    "edited topic": "edited topic",
    "left group": "left group",
    "removed": "removed",
    "took screenshot": "took screenshot",
    "joined Telegram": "joined Telegram",
    "set message auto-delete timer to": "set message auto-delete timer to",
    "disabled message auto-delete timer": "disabled message auto-delete timer",
    "scheduled video chat for": "scheduled video chat for",
    "scheduled video chat": "scheduled video chat",
    "Terminal": "Terminal",
    "Analysis": "Analysis",
    "Tokens:": "Tokens:",
    "Recalculate": "Recalculate",
    "Installation Manager": "Installation Manager",
    "Help": "Help",
    "Tokens": "Tokens",
    "Characters": "Characters",
    "Characters:": "Characters:",
    "Calculate": "Calculate",
    "{unit} calculated: {count}": "{unit} calculated: {count}",
    "Tokens calculated: {count}": "Tokens calculated: {count}",
    "Characters calculated: {count}": "Characters calculated: {count}",
    "Token Analysis": "Token Analysis",
    "Calculating...": "Calculating...",
    "Character Count": "Character Count",
    "Token analysis feature is under development.": "Token analysis feature is under development.",
    "Tokens calculated: {count}": "Tokens calculated: {count}",
    "N/A": "N/A",
    "Token Count": "Token Count",
    "Tokens per Participant": "Tokens per Participant",
    "Analyzing tokens per participant...": "Analyzing tokens per participant...",
    "Analysis failed or no data found.": "Analysis failed or no data found.",
    "Tokenizer Error": "Tokenizer Error",
    "Tokenizer not ready.": "Tokenizer not ready.",
    "Tokenizer not ready. Please run total calculation first.": "Tokenizer not ready. Please run total calculation first.",
    "Token Analysis by Date": "Token Analysis by Date",
    "Please calculate total tokens first by clicking 'Recalculate'.": "Please calculate total tokens first by clicking 'Recalculate'.",
    "Analyzing token distribution by date...": "Analyzing token distribution by date...",
    "Rendering chart...": "Rendering chart...",
    "Token Analysis": "Token Analysis",
    "Save": "Save",
    "Close": "Close",
    "Save filter settings for export": "Save filter settings for export",
    "Filter settings saved. They will be applied on the next export.": "Filter settings saved. They will be applied on the next export.",
    "Filter settings cleared.": "Filter settings cleared.",
    "Year": "Year",
    "Month": "Month",
    "Day": "Day",
    "Others": "Others",
    "Remaining": "Remaining",
    "Total": "Total",
    "Total Characters": "Total Characters",
    "Calendar View": "Calendar View",
    "Calendar": "Calendar",
    "Date": "Date",
    "No messages on this date.": "No messages on this date.",
    "Analyzing token distribution...": "Analyzing token distribution...",
    "Analysis complete.": "Analysis complete.",
    "HF transformers not found": "HuggingFace 'transformers' not found. Please run 'pip install transformers sentencepiece'",
    "HF transformers not found. Skipping.": "HuggingFace 'transformers' not found. Skipping.",
    "Downloading tokenizer": "Downloading tokenizer model (first time)...",
    "Initialization complete": "Initialization complete!",
    "Error: {error}": "Error: {error}",
    "Error opening calendar dialog": "Error opening calendar dialog",
    "File not found": "File not found.",
    "Error": "Error",
    "{count} others": "{count} others",
    "click to go up": "(click to go up)",
    "No Data": "No Data",
    "Model not found in cache. Skipping.": "Model not found in cache. Skipping.",
    "Warning": "Warning",
    "Please enter a model name": "Please enter a model name",
    "Downloading tokenizer model '{model}'...": "Downloading tokenizer model '{model}'...",
    "Tokenizer '{model}' loaded successfully!": "Tokenizer '{model}' loaded successfully!",
    "Error loading tokenizer: {error}": "Error loading tokenizer: {error}",
    "Failed to load tokenizer: {error}": "Failed to load tokenizer: {error}",
    "Executing: {command}": "Executing: {command}",
    "Operation completed.": "Operation completed.",
    "Tokens: {count}": "Tokens: {count}",
    "Characters: {count}": "Characters: {count}",
    "System Prompt": "System Prompt",
    "Tool Calls": "Tool Calls",
    "Analysis complete.": "Analysis complete.",
    "Export completed successfully.": "Export completed successfully.",
    "Done": "Done",
    "Building analysis tree...": "Building analysis tree...",
    "Building analysis tree for {count} {unit}": "Building analysis tree for {count} {unit}",
    "Failed to build analysis tree": "Failed to build analysis tree",
    "Start time: {time}": "Start time: {time}",
    "Created time intervals:": "Created time intervals:",
    "Years: {count}": "Years: {count}",
    "Months: {count}": "Months: {count}",
    "Days: {count}": "Days: {count}",
    "Year {year}: {count} {unit} ({percent:.1f}%)": "Year {year}: {count} {unit} ({percent:.1f}%)",
    "Month {month} {year}: {count} {unit} ({percent:.1f}% of year)": "Month {month} {year}: {count} {unit} ({percent:.1f}% of year)",
    "Day {day} {month} {year}: {count} {unit} ({percent:.1f}% of month)": "Day {day} {month} {year}: {count} {unit} ({percent:.1f}% of month)",
    "Creating tree nodes...": "Creating tree nodes...",
    "Analysis tree built successfully": "Analysis tree built successfully",
    "Final structure: {name} ({count} years)": "Final structure: {name} ({count} years)",
    "Execution time: {time:.3f} seconds": "Execution time: {time:.3f} seconds",
    "End time: {time}": "End time: {time}",
    "Worker: Starting tree construction for {count} tokens": "Worker: Starting tree construction for {count} tokens",
    "Worker: Start time: {time}": "Worker: Start time: {time}",
    "Worker: Creating TokenAnalyzer...": "Worker: Creating TokenAnalyzer...",
    "Worker: Starting analysis tree construction...": "Worker: Starting analysis tree construction...",
    "Worker: Tree built successfully": "Worker: Tree built successfully",
    "Worker: Final structure: {name} with {count} child nodes": "Worker: Final structure: {name} with {count} child nodes",
    "Worker: Execution time: {time:.3f} seconds": "Worker: Execution time: {time:.3f} seconds",
    "Worker: End time: {time}": "Worker: End time: {time}",
    "Worker: Sending analysis result...": "Worker: Sending analysis result...",
    "Using cached analysis tree.": "Using cached analysis tree.",
    "Message filtering: no disabled nodes, returning all messages": "Message filtering: no disabled nodes, returning all messages",
    "Starting message filtering by {count} disabled nodes": "Starting message filtering by {count} disabled nodes",
    "Disabled date: {date} (node: {name}, value: {value:.1f})": "Disabled date: {date} (node: {name}, value: {value:.1f})",
    "Node '{name}' contains {count} aggregated subnodes:": "Node '{name}' contains {count} aggregated subnodes:",
    "Child {index}: '{name}': {value:.1f} tokens": "Child {index}: '{name}': {value:.1f} tokens",
    "Total disabled dates: {count}": "Total disabled dates: {count}",
    "Disabled dates: {dates}": "Disabled dates: {dates}",
    "Filtering completed: {original} → {filtered} messages (filtered: {count})": "Filtering completed: {original} → {filtered} messages (filtered: {count})",
    "Starting conversion context creation": "Starting conversion context creation",
    "Chat name: {name}": "Chat name: {name}",
    "Total messages: {count}": "Total messages: {count}",
    "Messages with ID: {count}": "Messages with ID: {count}",
    "Profile: {profile}": "Profile: {profile}",
    "Processing personal profile...": "Processing personal profile...",
    "Found authors: {count}": "Found authors: {count}",
    "Author {name} ({id}): {count} messages": "Author {name} ({id}): {count} messages",
    "My ID: {id} ({name})": "My ID: {id} ({name})",
    "Partner ID: {id} ({name})": "Partner ID: {id} ({name})",
    "Processing posts profile...": "Processing posts profile...",
    "Channel name: {name}": "Channel name: {name}",
    "Main post ID: {id}": "Main post ID: {id}",
    "Conversion context created successfully": "Conversion context created successfully",
    "Starting text generation for export": "Starting text generation for export",
    "HTML mode: {mode}": "HTML mode: {mode}",
    "Applying filters: {yes_no}": "Applying filters: {yes_no}",
    "Disabled nodes: {count}": "Disabled nodes: {count}",
    "Disabled node: {name} (value: {value:.1f})": "Disabled node: {name} (value: {value:.1f})",
    "... and {count} more nodes": "... and {count} more nodes",
    "Title: {title} - {name}": "Title: {title} - {name}",
    "Participants: {my_name} ({my_full}), {partner_name} ({partner_full})": "Participants: {my_name} ({my_full}), {partner_name} ({partner_full})",
    "Total messages to process: {count}": "Total messages to process: {count}",
    "Messages after filtering: {count}": "Messages after filtering: {count}",
    "First date: {date}": "First date: {date}",
    "Processing completed: {count} messages processed": "Processing completed: {count} messages processed",
    "Output text size: {size} characters": "Output text size: {size} characters",
    "Starting chart construction for node '{name}'": "Starting chart construction for node '{name}'",
    "Root node has no children": "Root node has no children",
    "Chart built successfully": "Chart built successfully",
    "Right click on node: '{name}'": "Right click on node: '{name}'",
    "Enabled {count} days for '{name}'": "Enabled {count} days for '{name}'",
    "Disabled {count} days for '{name}'": "Disabled {count} days for '{name}'",
    "Left click on node: '{name}'": "Left click on node: '{name}'",
    "Enabled {count} days for node '{name}'.": "Enabled {count} days for node '{name}'.",
    "Disabled {count} days for node '{name}'.": "Disabled {count} days for node '{name}'.",
    "Node aggregation: '{name}' (Force full detail: {force})": "Node aggregation: '{name}' (Force full detail: {force})",
    "Node '{name}' has no children or value is 0": "Node '{name}' has no children or value is 0",
    "Maximum detail: showing all {count} children": "Maximum detail: showing all {count} children",
    "Smart limit: share {share:.2%}, child limit: {limit} (from {min} to {max})": "Smart limit: share {share:.2%}, child limit: {limit} (from {min} to {max})",
    "Smart limit: top level node, child limit: {limit}": "Smart limit: top level node, child limit: {limit}",
    "Aggregation threshold: {threshold:.1f} tokens ({percent}% of {value:.1f})": "Aggregation threshold: {threshold:.1f} tokens ({percent}% of {value:.1f})",
    "Analyzing {count} child nodes...": "Analyzing {count} child nodes...",
    "Showing '{name}': {value:.1f} tokens (>= threshold and in top {limit})": "Showing '{name}': {value:.1f} tokens (>= threshold and in top {limit})",
    "Hiding '{name}': {value:.1f} tokens (< threshold {threshold:.1f})": "Hiding '{name}': {value:.1f} tokens (< threshold {threshold:.1f})",
    "Hiding '{name}': {value:.1f} tokens (outside top {limit})": "Hiding '{name}': {value:.1f} tokens (outside top {limit})",
    "Created '{name}' node with {count} hidden nodes (total value: {value:.1f})": "Created '{name}' node with {count} hidden nodes (total value: {value:.1f})",
    "Total showing: {count} nodes + 1 aggregated": "Total showing: {count} nodes + 1 aggregated",
    "Showing all {count} nodes (aggregation not needed)": "Showing all {count} nodes (aggregation not needed)",
    "Aggregated {count} subnodes": "Aggregated {count} subnodes",
    "GEOMETRY: Constants: CENTER_HOLE_RADIUS={radius}, RING_WIDTH={width}, MAX_DEPTH={depth}": "GEOMETRY: Constants: CENTER_HOLE_RADIUS={radius}, RING_WIDTH={width}, MAX_DEPTH={depth}",
    "--- [ Starting chart construction for node '{name}' ] ---": "--- [ Starting chart construction for node '{name}' ] ---",
    "--- [ ✅ Chart for '{name}' built successfully ] ---": "--- [ ✅ Chart for '{name}' built successfully ] ---",
    "AI Component Management": "AI Component Management",
    "Status:": "Status:",
    "Loaded and active": "Loaded and active",
    "Not available": "Not available",
    "Actions": "Actions",
    "Install / Update": "Install / Update",
    "Remove": "Remove",
    "Load AI components on startup": "Load AI components on startup",
    "Configuration": "Configuration",
    "Hugging Face Model:": "Hugging Face Model:",
    "Reset to Default": "Reset to Default",
    "Terminal Output": "Terminal Output",
    "Installed. Please restart the application to use.": "Installed. Please restart the application to use.",
    "Please restart the application for the changes to take effect.": "Please restart the application for the changes to take effect.",
    "Close": "Close",
    "Executing: {command}": "Executing: {command}",
    "Operation successful.": "Operation successful.",
    "Operation failed with code: {code}": "Operation failed with code: {code}",
    "Installed (active)": "Installed (active)",
    "Installed (restart required)": "Installed (restart required)",
    "Installed (model not in cache)": "Installed (model not in cache)",
    "Not installed": "Not installed",
    "Loaded model: {model}": "Loaded model: {model}",
    "Remove Model from Cache": "Remove Model from Cache",
    "Scanning cache for model...": "Scanning cache for model...",
    "Model not found in cache.": "Model not found in cache.",
    "Found model, preparing to delete...": "Found model, preparing to delete...",
    "Will free: {size}": "Will free: {size}",
    "Deleting model from cache...": "Deleting model from cache...",
    "Model cache removed successfully.": "Model cache removed successfully.",
    "Refusing to install packages into the system Python. Please run this application from a virtual environment (venv).": "Refusing to install packages into the system Python. Please run this application from a virtual environment (venv).",
    "Error: Model name cannot be empty": "Error: Model name cannot be empty",
    "Load Model": "Load Model",
    "Install/Update transformers library": "Install/Update transformers library",
    "This action requires restart": "This action requires restart",
    "Removes the model specified in the configuration from the local cache to free up disk space.": "Removes the model specified in the configuration from the local cache to free up disk space.",
    "Library Status:": "Library Status:",
    "Loaded Model:": "Loaded Model:",
    "Installed (model not loaded)": "Installed (model not loaded)",
    "in cache": "in cache",
    "Restart Required": "Restart Required",
    "Library installation completed successfully!": "Library installation completed successfully!",
    "Please restart the application for changes to take effect.": "Please restart the application for changes to take effect.",
    "On": "On",
    "Off": "Off",
    "Tokens reset": "Tokens reset",
    "Characters reset": "Characters reset",

    "gifted": "gifted",
    "star_form1": "star",
    "star_form2": "stars",
    "star_form5": "stars",
    "won_prize_from": "won a prize from {actor}: {count} ★ {stars_text}",
    "updated_tasks_in_list": "updated tasks in the to-do list",
    "added_tasks": "added tasks",

    "Tkonverter Help": "Tkonverter Help",
    "Help Section: Introduction": "Introduction",
    "Help Section: File Management": "File Management",
    "Help Section: Conversion Options": "Conversion Options",
    "Help Section: Analysis Tools": "Analysis Tools",
    "Help Section: AI Features": "AI Features",
    "Help Section: Exporting": "Exporting",
    "help_intro_html": """
<body>
    <h2>Welcome to Tkonverter!</h2>
    <p>This application is designed to convert and analyze exported Telegram chats, primarily for pre-processing data for Large Language Models (LLMs).</p>
    <p>Use the navigation on the left to learn about specific features.</p>
</body>
""",
    "help_files_html": """
<body>
    <h2>File Management</h2>
    <p>To begin, <b>drag and drop</b> your <code>result.json</code> file from a Telegram data export onto the main application window.</p>
</body>
""",
    "help_conversion_html": """
<body>
    <h2>Conversion Options</h2>
    <h3>Profiles</h3>
    <p>The profile affects how messages are formatted. In most cases, <b>Auto-detect profile</b> (in Settings) works best.</p>
    <ul>
        <li><b>Group Chat:</b> Standard formatting for multi-user chats.</li>
        <li><b>Personal Chat:</b> Formats the conversation from the perspective of "Me" and "Partner". You can set custom names for these roles.</li>
        <li><b>Channel:</b> Simplified format suitable for channel posts.</li>
        <li><b>Posts and Comments:</b> A special mode for channels where comments are enabled. It treats the first message as the main post and subsequent messages as replies.</li>
    </ul>
    <h3>Key Options</h3>
    <ul>
        <li><b>Show reactions:</b> Includes message reactions (e.g., 👍 2).</li>
        <li><b>Optimization:</b> A mode for channels that groups consecutive messages from the same author to save tokens.</li>
    </ul>
</body>
""",
    "help_analysis_html": """
<body>
    <h2>Analysis Tools</h2>
    <p>Before using the analysis tools, you must first load a chat and click <b>"Calculate"</b> to process the data.</p>
    <h3>Analysis Chart (Sunburst Diagram)</h3>
    <ul>
        <li><b>Left-click:</b> Zoom into a segment (e.g., click a year to see its months).</li>
        <li><b>Right-click:</b> Toggle a segment and all its children as <b>disabled</b> for export. Disabled segments will be grayed out. This allows you to exclude specific time periods from your final text file.</li>
        <li><b>Click the center:</b> Zoom out to the parent level.</li>
    </ul>
    <h3>Calendar</h3>
    <ul>
        <li><b>Left-click a day:</b> View the messages for that specific day in the right-hand panel.</li>
        <li><b>Left-click a month/year:</b> Zoom into that month/year.</li>
        <li><b>Right-click a day/month/year:</b> Toggle that entire period as <b>disabled</b> for export.</li>
        <li><b>Click the title (e.g., "August 2025"):</b> Zoom out to the parent level (e.g., to the year view).</li>
    </ul>
</body>
""",
    "help_ai_html": """
<body>
    <h2>AI & Tokenizer Features</h2>
    <p>Tkonverter can calculate the exact number of tokens your chat will use with a specific AI model. This requires the <b>transformers</b> library.</p>
    <ul>
        <li>Click the <b>Download</b> icon to open the <b>Installation Manager</b>.</li>
        <li>From there, you can install the necessary libraries and download tokenizer models from Hugging Face.</li>
        <li>Once a tokenizer is loaded, the analysis will switch from counting characters to counting tokens.</li>
    </ul>
</body>
""",
    "help_export_html": """
<body>
    <h2>Exporting</h2>
    <p>Click <b>"Save to file..."</b> to open the export dialog.</p>
    <p>The final <code>.txt</code> file will respect all your selected formatting options and any date filters you have applied using the Analysis Chart or Calendar.</p>
</body>
""",
}

ru_translations = {

    "Profile": "Профиль",
    "Group Chat": "Групповой чат",
    "Posts and Comments": "Посты и комментарии",
    "Personal Chat": "Личная переписка",
    "Names for Personal Chat": "Имена для личной переписки",
    "Your name (in chat):": "Ваше имя (в чате):",
    "Partner's name:": "Имя собеседника:",
    "Options": "Опции",
    "Show message time": "Отображать время сообщения",
    "Show reactions": "Отображать реакции",
    "Show reaction authors": "Имена отреагировавших",
    "Optimization": "Оптимизация",
    "Streak break time:": "Разрыв серии через:",
    "Show Markdown": "Отображать Markdown",
    "Show links": "Отображать ссылки",
    "Show technical information": "Техническая информация",
    "Show service notifications": "Служебные уведомления",
    "Preview": "Предпросмотр",
    "Terminal": "Терминал",
    "Drag and drop result.json file here": "Перетащите сюда файл result.json",
    "Settings": "Настройки",
    "Save to file...": "Сохранить в файл",
    "Tkonverter": "Tkonverter",
    "Ready to work": "Готов к работе",
    "Loading file...": "Загрузка файла...",
    "Updating preview...": "Обновление примера...",
    "File loaded: {filename}": "Файл загружен: {filename}",
    "Loading error.": "Ошибка загрузки файла.",
    "Please load a JSON file first.": "Сначала загрузите JSON файл.",
    "Saving file...": "Сохранение файла...",
    "File saved: {path}": "Файл сохранен: {path}",
    "Error saving file: {error}": "Ошибка сохранения: {error}",
    "Error opening calendar dialog": "Ошибка открытия календарного диалога",
    "Chat name: {name}": "Имя чата: {name}",

    "Preview: Group example": "Пример: Групповой чат",
    "Preview: Personal example": "Пример: Личная переписка",
    "Preview: Posts example": "Пример: Посты и комментарии",
    "Preview: Example Group": "Пример группы",
    "Preview: Channel example": "Пример: Канал",
    "Preview: Example Channel": "Пример канала",
    "Preview: Alaisa": "Алаиса",
    "Preview: Alice": "Алиса",
    "Preview: Bob": "Боб",
    "Preview: Alexander": "Александр",
    "Preview: Misha": "Миша",
    "Preview: Main Editor": "Главный редач",
    "Preview: Hello everyone!": "Всем привет!",
    "Preview: One moment": "Секунду",
    "Preview: Thanks": "Спасибо",
    "Preview: Almost midnight...": "Почти полночь...",
    "Preview: Happy New Year!": "С новым годом!",
    "Preview: New Telegram Update": "Новое важное обновление в Telegram, которого все так долго ждали",
    "Preview: Update description": "Сегодня был выпуск нового обновления, теперь в Telegram есть встроенный кошелёк TON.",
    "Preview: Why do we need this?": "Ну и зачем нам это?",
    "Preview: If you don't need it...": "Если 'тебе не надо', это же не означает что **всем** не надо!",
    "Preview: This is a second message from me.": "Это второе сообщение от меня.",

    "Personal correspondence": "Личная переписка",
    "Channel": "Канал",
    "Group chat": "Групповой чат",
    "Me": "Я",
    "Partner": "Собеседник",
    "{actor} created group «{title}»": "{actor} создал(а) группу «{title}»",
    " and invited {members}": " и пригласил(а) {members}",
    "{actor} invited {members}": "{actor} пригласил(а) {members}",
    "{actor} left the group": "{actor} покинул(а) группу",
    "{actor} removed {member}": "{actor} исключил(а) {member}",
    "Outgoing call": "Исходящий звонок",
    "Incoming call": "Входящий звонок",
    ", duration: {duration}": ", длительность: {duration}",
    " (missed)": " (пропущен)",
    " (declined)": " (отклонён)",
    "{actor} started a video chat": "{actor} начал(а) видеочат",
    "{actor} joined group by link from {inviter}": "{actor} присоединился(лась) к группе по ссылке от {inviter}",
    "{actor} joined group by link": "{actor} присоединился(лась) к группе по ссылке",
    " and {remaining_count} more": " и ещё +{remaining_count}",
    "[SPOILER]": "[СПОЙЛЕР]",
    "[Poll]": "[Опрос]",
    "Signature": "Подпись",
    "Signature: {signature}": "Подпись: {signature}",
    " (from: {authors})": " (от: {authors})",
    "Theme:": "Тема:",
    "Auto": "Авто",
    "Light": "Светлая",
    "Dark": "Тёмная",
    "Giveaway": "Розыгрыш",
    "Prize:": "Приз:",
    "Additionally:": "Дополнительно:",
    "Until:": "До:",
    "{quantity} Premium subscriptions for {months} {months_text}": "{quantity} подписок Premium на {months} {months_text}",
    "Giveaway Results": "Результаты розыгрыша",
    "Winners:": "Победители:",
    "month_form1": "месяц",
    "month_form2": "месяца",
    "month_form5": "месяцев",
    "winner_form1": "победитель",
    "winner_form2": "победителя",
    "winner_form5": "победителей",
    "unclaimed_form1": "невостребованный приз",
    "unclaimed_form2": "невостребованных приза",
    "unclaimed_form5": "невостребованных призов",
    "boosted group": "ускорил(а) группу",
    "time_form1": "раз",
    "time_form2": "раза",
    "time_form5": "раз",
    "UI Font": "Шрифт интерфейса",
    "Built-in font": "Встроенный шрифт",
    "System default": "Системный по умолчанию",
    "Custom": "Пользовательский",
    "Select font...": "Выбрать шрифт...",
    "Truncation length": "Длина обрезки",
    "Nicknames:": "Никнеймы:",
    "Quotes in replies:": "Цитаты в ответах:",
    "Auto-detect profile": "Автоопределение профиля",
    "Automatic recalculation": "Автоматический пересчёт",
    "OK": "ОК",
    "Language:": "Язык:",
    "English": "Английский",
    "Russian": "Русский",
    "Export Chat": "Экспорт чата",
    "Folder to save:": "Папка для сохранения:",
    "Browse...": "Обзор...",
    "Error": "Ошибка",
    "No Data": "Нет данных",
    "Token Analysis by Date": "Анализ токенов по датам",
    "Analyzing...": "Анализ...",
    "Rendering chart...": "Отрисовка диаграммы...",
    "No messages on this date.": "Нет сообщений за эту дату.",
    "Choose folder": "Выбрать папку",
    "From Favorites": "Из Избранного",
    "Please calculate total tokens first by clicking 'Recalculate'.": "Пожалуйста, сначала рассчитайте общее число токенов, нажав 'Пересчитать'.",
    "Unknown Chat": "Неизвестный чат",
    "User": "Неизвестен",
    "System": "Система",
    "disabled": "отключен",
    "24 hours": "24 часа",
    "7 days": "7 дней",
    "1 month": "1 месяц",
    "{days} d.": "{days} дн.",
    "{hours} h.": "{hours} ч.",
    "{minutes} min.": "{minutes} мин.",
    "{seconds} sec.": "{seconds} сек.",
    "unknown source": "неизвестный источник",
    "file": "файл",

    "Token Count": "Токены:",
    "chat_history": "история_чата",
    "weekday_mon": "Пн",
    "weekday_tue": "Вт",
    "weekday_wed": "Ср",
    "weekday_thu": "Чт",
    "weekday_fri": "Пт",
    "weekday_sat": "Сб",
    "weekday_sun": "Вс",
    "month_gen_1": "Января",
    "month_gen_2": "Февраля",
    "month_gen_3": "Марта",
    "month_gen_4": "Апреля",
    "month_gen_5": "Мая",
    "month_gen_6": "Июня",
    "month_gen_7": "Июля",
    "month_gen_8": "Августа",
    "month_gen_9": "Сентября",
    "month_gen_10": "Октября",
    "month_gen_11": "Ноября",
    "month_gen_12": "Декабря",
    "month_1": "Январь",
    "month_2": "Февраль",
    "month_3": "Март",
    "month_4": "Апрель",
    "month_5": "Май",
    "month_6": "Июнь",
    "month_7": "Июль",
    "month_8": "Август",
    "month_9": "Сентябрь",
    "month_10": "Октябрь",
    "month_11": "Ноябрь",
    "month_12": "Декабрь",
    "Use as default folder": "Использовать как папку по умолчанию",
    "To Favorites": "В Избранное",

    "File name (without extension):": "Имя файла (без расширения):",
    "Save": "Сохранить",

    "Cancel": "Отмена",
    "Participants": "Участники",
    "Reaction notation": "Обозначение реакций",
    "from": "от",
    "Unknown": "Неизвестно",
    "Service message from": "Служебное сообщение от",
    " (edited)": " (отредактировано)",
    "[Buttons under message]": "[Кнопки под сообщением]",
    "Row": "Строка",
    "via bot": "через бота",
    "forwarded from": "переслано из",
    "[Mini-game]": "[Мини-игра]",
    "[Empty message]": "[Пустое сообщение]",
    "file not found": "файл не найден",
    "No title": "Без названия",
    "Question": "Вопрос",
    "No question": "Нет вопроса",
    "No text": "Нет текста",
    "Your choice": "Ваш выбор",
    "people_form1": "человек",
    "people_form2": "человека",
    "people_form5": "человек",
    "Total voted": "Всего проголосовало",
    "Poll closed": "Опрос закрыт",
    "Title": "Название",
    "Description": "Описание",
    "Amount": "Сумма",

    "phone not specified": "номер не указан",
    "Address not specified": "Адрес не указан",
    "duration": "длительность",
    "time": "раз",
    "times": "раза",
    "sent": "отправлен",

    "[Audio]": "[Аудио]",
    "[Video]": "[Видео]",
    "[Voice message]": "[Голосовое сообщение]",
    "[Video message]": "[Видео-сообщение]",
    "[Sticker]": "[Стикер]",
    "[Emoji]": "[Эмодзи]",
    "Custom": "Кастомный",
    "Emoji": "Эмодзи",
    "[Animation]": "[Анимация]",
    "[File]": "[Файл]",
    "[Photo]": "[Фото]",
    "[Photo ({details})]": "[Фото ({details})]",
    "Unknown performer": "Неизвестный исполнитель",
    "[Audio: {performer} - {title} ({duration})]": "[Аудио: {performer} - {title} ({duration})]",
    "[Video ({details})]": "[Видео ({details})]",
    "[Voice message ({duration})]": "[Голосовое сообщение ({duration})]",
    "[Video message ({duration})]": "[Видео-сообщение ({duration})]",
    "[Sticker {emoji}]": "[Стикер {emoji}]",
    "[Animation ({details})]": "[Анимация ({details})]",
    "[File: {filename}]": "[Файл: {filename}]",
    "[Contact: {name}, {phone}]": "[Контакт: {name}, {phone}]",
    "[Geoposition]": "[Геопозиция]",
    "[Geoposition: {lat:.6f}, {lon:.6f}]": "[Геопозиция: {lat:.6f}, {lon:.6f}]", "Address not specified": "Адрес не указан",
    "[Place: {place}, {address} (Coordinates: {lat:.6f}, {lon:.6f})]": "[Место: {place}, {address} (Координаты: {lat:.6f}, {lon:.6f})]",
    "[Place: {place}, {address}]": "[Место: {place}, {address}]",
    "[Dice roll: {emoji} (Result: {value})]": "[Бросок кубика: {emoji} (Результат: {value})]",
    "[Game]": "[Игра]",
    "[Payment invoice]": "[Платежный счет]",
    "[Media]": "[Медиа]",

    "pinned message": "закрепил сообщение",
    "Video chat ended, duration": "Видеочат завершён, длительность",
    "started video chat": "начал(а) видеочат",
    "missed": "пропущен",
    "busy": "занято",
    "declined": "отклонён",
    "created group": "создал(а) группу",
    "and invited": "и пригласил(а)",
    "joined group": "присоединился(лась) к группе",
    "invited": "пригласил(а)",
    "joined group by link from": "присоединился(лась) к группе по ссылке от",
    "joined group by link": "присоединился(лась) к группе по ссылке",
    "gifted Telegram Premium": "подарил(а) Telegram Premium",
    "for": "на",
    "months": "месяцев",
    "boosted group": "ускорил(а) группу",
    "scored": "набрал(а)",
    "points in game": "очков в игре",
    "Payment for": "Платёж на",
    "created channel": "создал(а) канал",
    "changed group name to": "изменил(а) название группы на",
    "changed chat wallpaper": "изменил(а) обои чата",
    "changed group photo": "сменил(а) фото группы",
    "deleted group photo": "удалил(а) фото группы",
    "History cleared": "История очищена",
    "converted this group to supergroup": "преобразовал(а) эту группу в супергруппу",
    "converted group": "преобразовал(а) группу",
    "to this supergroup": "в эту супергруппу",
    "changed chat theme to": "изменил(а) тему чата на",
    "disabled chat theme": "отключил(а) тему чата",
    "created topic": "создал(а) тему",
    "changed topic name to": "изменил(а) название темы на",
    "edited topic": "отредактировал(а) тему",
    "left group": "покинул(а) группу",
    "removed": "исключил(а)",
    "took screenshot": "сделал(а) скриншот",
    "joined Telegram": "присоединился(лась) к Telegram",
    "set message auto-delete timer to": "установил(а) таймер автоудаления сообщений на",
    "disabled message auto-delete timer": "отключил(а) таймер автоудаления сообщений",
    "scheduled video chat for": "запланировал(а) видеочат на",
    "scheduled video chat": "запланировал(а) видеочат",

    "Analysis": "Анализ",
    "Tokens:": "Токены:",
    "Recalculate": "Пересчитать",
    "Installation Manager": "Менеджер установки",
    "Help": "Справка",
    "Tokens": "Токены",
    "Characters": "Символы",
    "Characters:": "Символы:",
    "Calculate": "Посчитать",
    "{unit} calculated: {count}": "{unit} подсчитано: {count}",
    "Tokens calculated: {count}": "Токены подсчитаны: {count}",
    "Characters calculated: {count}": "Символы подсчитаны: {count}",
    "Token Analysis": "Анализ токенов",
    "Calculating...": "Подсчёт...",
    "Character Count": "Количество символов",
    "Token analysis feature is under development.": "Функция анализа токенов находится в разработке.",
    "Tokens calculated: {count}": "Токенов подсчитано: {count}",
    "N/A": "Н/Д",
    "Tokens per Participant": "Токены по участникам",
    "Analyzing tokens per participant...": "Анализ токенов по участникам...",
    "Analysis failed or no data found.": "Анализ не удался или данные не найдены.",
    "Tokenizer Error": "Ошибка токенизатора",
    "Tokenizer not ready.": "Токенизатор не готов.",
    "Tokenizer not ready. Please run total calculation first.": "Токенизатор не готов. Сначала выполните общий подсчет.",
    "Token Analysis by Date": "Анализ токенов по датам",
    "Please calculate total tokens first by clicking 'Recalculate'.": "Пожалуйста, сначала рассчитайте общее число токенов, нажав 'Пересчитать'.",
    "Analyzing token distribution by date...": "Анализ распределения токенов по датам...",
    "Rendering chart...": "Отрисовка диаграммы...",

    "Save": "Сохранить",
    "Close": "Закрыть",
    "Save filter settings for export": "Сохранить настройки фильтра для экспорта",
    "Filter settings saved. They will be applied on the next export.": "Настройки фильтра сохранены. Они будут применены при следующем экспорте.",
    "Filter settings cleared.": "Настройки фильтра очищены.",
    "Year": "Год",
    "Month": "Месяц",
    "Day": "День",
    "Others": "Прочее",
    "Remaining": "Осталось",
    "Total": "Всего",
    "Total Characters": "Всего символов",
    "Calendar View": "Просмотр в календаре",
    "Calendar": "Календарь",
    "Date": "Дата",

    "Analyzing token distribution...": "Анализ распределения токенов...",
    "Analysis complete.": "Анализ завершён.",
    "HF transformers not found": "Библиотека HuggingFace 'transformers' не найдена. Выполните 'pip install transformers sentencepiece'",
    "HF transformers not found. Skipping.": "HuggingFace 'transformers' не найдена. Пропускаем.",
    "Downloading tokenizer": "Скачивание модели токенизатора (первый раз)...",
    "Initialization complete": "Инициализация завершена!",
    "Error: {error}": "Ошибка: {error}",
    "File not found": "Файл не найден.",

    "{count} others": "{count} прочих",
    "click to go up": "(нажмите для возврата)",

    "Model not found in cache. Skipping.": "Модель не найдена в кэше. Пропускаем.",
    "Warning": "Внимание",
    "Please enter a model name": "Пожалуйста, введите имя модели",
    "Downloading tokenizer model '{model}'...": "Загрузка модели токенизатора '{model}'...",
    "Tokenizer '{model}' loaded successfully!": "Токенизатор '{model}' успешно загружен!",
    "Error loading tokenizer: {error}": "Ошибка загрузки токенизатора: {error}",
    "Failed to load tokenizer: {error}": "Не удалось загрузить токенизатор: {error}",
    "Executing: {command}": "Выполнение: {command}",
    "Operation completed.": "Операция завершена.",
    "Tokens: {count}": "Токенов: {count}",
    "Characters: {count}": "Символов: {count}",
    "System Prompt": "Системный промпт",
    "Tool Calls": "Вызовы инструментов",

    "Export completed successfully.": "Экспорт успешно выполнен.",
    "Done": "Готово",
    "Building analysis tree...": "Построение дерева анализа...",
    "Building analysis tree for {count} {unit}": "Построение дерева анализа для {count} {unit}",
    "Failed to build analysis tree": "Не удалось построить дерево анализа",
    "Start time: {time}": "Время начала: {time}",
    "Created time intervals:": "Создано временных промежутков:",
    "Years: {count}": "Годы: {count}",
    "Months: {count}": "Месяцы: {count}",
    "Days: {count}": "Дни: {count}",
    "Year {year}: {count} {unit} ({percent:.1f}%)": "{year} год: {count} {unit} ({percent:.1f}%)",
    "Month {month} {year}: {count} {unit} ({percent:.1f}% of year)": "{month} {year}: {count} {unit} ({percent:.1f}% от года)",
    "Day {day} {month} {year}: {count} {unit} ({percent:.1f}% of month)": "{day} {month} {year}: {count} {unit} ({percent:.1f}% от месяца)",
    "Creating tree nodes...": "Создание дерева узлов...",
    "Analysis tree built successfully": "Дерево анализа построено успешно",
    "Final structure: {name} ({count} years)": "Итоговая структура: {name} ({count} лет)",
    "Execution time: {time:.3f} seconds": "Время выполнения: {time:.3f} секунд",
    "End time: {time}": "Время завершения: {time}",
    "Worker: Starting tree construction for {count} tokens": "Worker: Начало построения дерева для {count} токенов",
    "Worker: Start time: {time}": "Worker: Время начала: {time}",
    "Worker: Creating TokenAnalyzer...": "Worker: Создание TokenAnalyzer...",
    "Worker: Starting analysis tree construction...": "Worker: Запуск построения дерева анализа...",
    "Worker: Tree built successfully": "Worker: Дерево построено успешно",
    "Worker: Final structure: {name} with {count} child nodes": "Worker: Итоговая структура: {name} с {count} дочерними узлами",
    "Worker: Execution time: {time:.3f} seconds": "Worker: Время выполнения: {time:.3f} секунд",
    "Worker: End time: {time}": "Worker: Время завершения: {time}",
    "Worker: Sending analysis result...": "Worker: Отправка результата анализа...",
    "Using cached analysis tree.": "Используется кешированное дерево анализа.",
    "Message filtering: no disabled nodes, returning all messages": "Фильтрация сообщений: отключенных узлов нет, возвращаем все сообщения",
    "Starting message filtering by {count} disabled nodes": "Начало фильтрации сообщений по {count} отключенным узлам",
    "Disabled date: {date} (node: {name}, value: {value:.1f})": "Отключена дата: {date} (узел: {name}, значение: {value:.1f})",
    "Node '{name}' contains {count} aggregated subnodes:": "Узел '{name}' содержит {count} агрегированных подузлов:",
    "Child {index}: '{name}': {value:.1f} tokens": "Дочерний {index}: '{name}': {value:.1f} токенов",
    "Total disabled dates: {count}": "Всего отключено дат: {count}",
    "Disabled dates: {dates}": "Отключенные даты: {dates}",
    "Filtering completed: {original} → {filtered} messages (filtered: {count})": "Фильтрация завершена: {original} → {filtered} сообщений (отфильтровано: {count})",
    "Starting conversion context creation": "Начало создания контекста конверсии",

    "Total messages: {count}": "Всего сообщений: {count}",
    "Messages with ID: {count}": "Сообщений с ID: {count}",
    "Profile: {profile}": "Профиль: {profile}",
    "Processing personal profile...": "Обработка персонального профиля...",
    "Found authors: {count}": "Найдено авторов: {count}",
    "Author {name} ({id}): {count} messages": "Автор {name} ({id}): {count} сообщений",
    "My ID: {id} ({name})": "Мой ID: {id} ({name})",
    "Partner ID: {id} ({name})": "ID партнера: {id} ({name})",
    "Processing posts profile...": "Обработка профиля постов...",
    "Channel name: {name}": "Имя канала: {name}",
    "Main post ID: {id}": "ID главного поста: {id}",
    "Conversion context created successfully": "Контекст конверсии создан успешно",
    "Starting text generation for export": "Начало генерации текста для экспорта",
    "HTML mode: {mode}": "HTML режим: {mode}",
    "Applying filters: {yes_no}": "Применение фильтров: {yes_no}",
    "Disabled nodes: {count}": "Отключено узлов: {count}",
    "Disabled node: {name} (value: {value:.1f})": "Отключен узел: {name} (значение: {value:.1f})",
    "... and {count} more nodes": "... и еще {count} узлов",
    "Title: {title} - {name}": "Заголовок: {title} - {name}",
    "Participants: {my_name} ({my_full}), {partner_name} ({partner_full})": "Участники: {my_name} ({my_full}), {partner_name} ({partner_full})",
    "Total messages to process: {count}": "Всего сообщений для обработки: {count}",
    "Messages after filtering: {count}": "Сообщений после фильтрации: {count}",
    "First date: {date}": "Первая дата: {date}",
    "Processing completed: {count} messages processed": "Обработка завершена: {count} сообщений обработано",
    "Output text size: {size} characters": "Размер выходного текста: {size} символов",
    "Starting chart construction for node '{name}'": "Начало построения диаграммы для узла '{name}'",
    "Root node has no children": "Корневой узел не имеет дочерних элементов",
    "Chart built successfully": "Диаграмма построена успешно",
    "Right click on node: '{name}'": "Правый клик по узлу: '{name}'",
    "Enabled {count} days for '{name}'": "Включено {count} дней для '{name}'",
    "Disabled {count} days for '{name}'": "Выключено {count} дней для '{name}'",
    "Left click on node: '{name}'": "Левый клик по узлу: '{name}'",
    "Enabled {count} days for node '{name}'.": "Включено {count} дней для узла '{name}'.",
    "Disabled {count} days for node '{name}'.": "Выключено {count} дней для узла '{name}'.",
    "Node aggregation: '{name}' (Force full detail: {force})": "Агрегация узла '{name}' (Форсировать детализацию: {force})",
    "Node '{name}' has no children or value is 0": "Узел '{name}' не имеет дочерних элементов или значение равно 0",
    "Maximum detail: showing all {count} children": "Максимальная детализация: показываем всех {count} детей",
    "Smart limit: share {share:.2%}, child limit: {limit} (from {min} to {max})": "Умный лимит: доля {share:.2%}, лимит детей: {limit} (от {min} до {max})",
    "Smart limit: top level node, child limit: {limit}": "Умный лимит: узел верхнего уровня, лимит детей: {limit}",
    "Aggregation threshold: {threshold:.1f} tokens ({percent}% of {value:.1f})": "Порог агрегации: {threshold:.1f} токенов ({percent}% от {value:.1f})",
    "Analyzing {count} child nodes...": "Анализ {count} дочерних узлов...",
    "Showing '{name}': {value:.1f} tokens (>= threshold and in top {limit})": "Показываем '{name}': {value:.1f} токенов (>= порога и в топ-{limit})",
    "Hiding '{name}': {value:.1f} tokens (< threshold {threshold:.1f})": "Скрываем '{name}': {value:.1f} токенов (< порога {threshold:.1f})",
    "Hiding '{name}': {value:.1f} tokens (outside top {limit})": "Скрываем '{name}': {value:.1f} токенов (вне топ-{limit})",
    "Created '{name}' node with {count} hidden nodes (total value: {value:.1f})": "Создан узел '{name}' с {count} скрытыми узлами (общее значение: {value:.1f})",
    "Contents of '{name}' node:": "Содержимое узла '{name}':",
    "Total showing: {count} nodes + 1 aggregated": "Итого показываем: {count} узлов + 1 агрегированный",
    "Showing all {count} nodes (aggregation not needed)": "Показываем все {count} узлов (агрегация не требуется)",
    "Aggregated {count} subnodes": "Агрегировано {count} подузлов",
    "GEOMETRY: Constants: CENTER_HOLE_RADIUS={radius}, RING_WIDTH={width}, MAX_DEPTH={depth}": "ГЕОМЕТРИЯ: Константы: CENTER_HOLE_RADIUS={radius}, RING_WIDTH={width}, MAX_DEPTH={depth}",
    "--- [ Starting chart construction for node '{name}' ] ---": "--- [ Начало построения диаграммы для узла '{name}' ] ---",
    "--- [ ✅ Chart for '{name}' built successfully ] ---": "--- [ ✅ Диаграмма для '{name}' построена успешно ] ---",
    "AI Component Management": "Управление ИИ-компонентами",
    "Status:": "Статус:",
    "Loaded and active": "Загружено и активно",
    "Not available": "Недоступно",
    "Actions": "Действия",
    "Install / Update": "Установить / Обновить",
    "Remove": "Удалить",
    "Load AI components on startup": "Загружать ИИ при запуске",
    "Configuration": "Конфигурация",
    "Hugging Face Model:": "Модель Hugging Face:",
    "Reset to Default": "Сбросить",
    "Terminal Output": "Вывод терминала",
    "Installed. Please restart the application to use.": "Установлено. Пожалуйста, перезапустите приложение для использования.",
    "Please restart the application for the changes to take effect.": "Пожалуйста, перезапустите приложение, чтобы изменения вступили в силу.",
    "Close": "Закрыть",
    "Executing: {command}": "Выполняется: {command}",
    "Operation successful.": "Операция выполнена успешно.",
    "Operation failed with code: {code}": "Операция не удалась с кодом: {code}",
    "Installed (active)": "Установлено (активно)",
    "Installed (restart required)": "Установлено (требуется перезапуск)",
    "Installed (model not in cache)": "Установлено (модель не в кэше)",
    "Not installed": "Не установлено",
    "Loaded model: {model}": "Загруженная модель: {model}",
    "Remove Model from Cache": "Удалить модель из кэша",
    "Scanning cache for model...": "Сканирование кэша...",
    "Model not found in cache.": "Модель не найдена в кэше.",
    "Found model, preparing to delete...": "Модель найдена, подготовка к удалению...",
    "Will free: {size}": "Будет освобождено: {size}",
    "Deleting model from cache...": "Удаление модели из кэша...",
    "Model cache removed successfully.": "Кэш модели успешно удален.",
    "Refusing to install packages into the system Python. Please run this application from a virtual environment (venv).": "Отказ от установки пакетов в системный Python. Пожалуйста, запустите это приложение из виртуального окружения (venv).",
    "Preparing to launch": "Подготовка к запуску",
    "None": "Нет",
    "Error: Model name cannot be empty": "Ошибка: Имя модели не может быть пустым",
    "Load Model": "Загрузить модель",
    "Install/Update transformers library": "Установить/Обновить библиотеку transformers",
    "This action requires restart": "Это действие требует перезапуска",
    "Removes the model specified in the configuration from the local cache to free up disk space.": "Удаляет модель, указанную в конфигурации, из локального кэша для освобождения дискового пространства.",
    "Library Status:": "Статус библиотеки:",
    "Loaded Model:": "Загруженная модель:",
    "Installed (model not loaded)": "Установлено (модель не загружена)",
    "in cache": "в кэше",
    "Restart Required": "Требуется перезапуск",
    "Library installation completed successfully!": "Библиотека успешно установлена!",
    "Please restart the application for changes to take effect.": "Пожалуйста, перезапустите приложение для применения изменений.",
    "On": "Вкл",
    "Off": "Выкл",
    "Tokens reset": "Токены сброшены",
    "Characters reset": "Символы сброшены",

    "gifted": "подарил(а)",
    "star_form1": "звезду",
    "star_form2": "звезды",
    "star_form5": "звёзд",
    "won_prize_from": "выиграл(а) приз от «{actor}»: {count} ★ {stars_text}",
    "updated_tasks_in_list": "обновил(а) задачи в списке дел",
    "added_tasks": "добавил(а) задачи",

    "Tkonverter Help": "Справка по Tkonverter",
    "Help Section: Introduction": "Введение",
    "Help Section: File Management": "Управление файлами",
    "Help Section: Conversion Options": "Настройки конвертации",
    "Help Section: Analysis Tools": "Инструменты анализа",
    "Help Section: AI Features": "Функции ИИ",
    "Help Section: Exporting": "Экспорт",
    "help_intro_html": """
<body>
    <h2>Добро пожаловать в Tkonverter!</h2>
    <p>Это приложение предназначено для конвертации и анализа экспортированных чатов Telegram, в первую очередь для предварительной обработки данных для больших языковых моделей (LLM).</p>
    <p>Используйте навигацию слева, чтобы узнать о конкретных функциях.</p>
</body>
""",
    "help_files_html": """
<body>
    <h2>Управление файлами</h2>
    <p>Для начала работы <b>перетащите</b> ваш файл <code>result.json</code> из экспорта данных Telegram в главное окно приложения.</p>
</body>
""",
    "help_conversion_html": """
<body>
    <h2>Настройки конвертации</h2>
    <h3>Профили</h3>
    <p>Профиль влияет на форматирование сообщений. В большинстве случаев опция <b>Автоопределение профиля</b> (в Настройках) работает лучше всего.</p>
    <ul>
        <li><b>Групповой чат:</b> Стандартное форматирование для чатов с несколькими участниками.</li>
        <li><b>Личная переписка:</b> Форматирует диалог от лица "Я" и "Собеседник". Вы можете задать свои имена для этих ролей.</li>
        <li><b>Канал:</b> Упрощенный формат, подходящий для постов в канале.</li>
        <li><b>Посты и комментарии:</b> Специальный режим для каналов с включенными комментариями. Считает первое сообщение главным постом, а последующие — ответами на него.</li>
    </ul>
    <h3>Ключевые опции</h3>
    <ul>
        <li><b>Отображать реакции:</b> Включает в вывод реакции на сообщения (например, 👍 2).</li>
        <li><b>Оптимизация:</b> Режим для каналов, который группирует последовательные сообщения от одного автора для экономии токенов.</li>
    </ul>
</body>
""",
    "help_analysis_html": """
<body>
    <h2>Инструменты анализа</h2>
    <p>Перед использованием инструментов анализа необходимо загрузить чат и нажать <b>"Пересчитать"</b> для обработки данных.</p>
    <h3>Диаграмма анализа (Sunburst)</h3>
    <ul>
        <li><b>Левый клик:</b> Приблизить сегмент (например, нажмите на год, чтобы увидеть месяцы).</li>
        <li><b>Правый клик:</b> Переключить сегмент и все его дочерние элементы как <b>отключенные</b> для экспорта. Отключенные сегменты станут серыми. Это позволяет исключить определённые периоды из итогового файла.</li>
        <li><b>Клик по центру:</b> Вернуться на уровень выше.</li>
    </ul>
    <h3>Календарь</h3>
    <ul>
        <li><b>Левый клик по дню:</b> Посмотреть сообщения за этот день в панели справа.</li>
        <li><b>Левый клик по месяцу/году:</b> Приблизить этот месяц/год.</li>
        <li><b>Правый клик по дню/месяцу/году:</b> Переключить весь этот период как <b>отключенный</b> для экспорта.</li>
        <li><b>Клик по заголовку (напр., "Август 2025"):</b> Вернуться на уровень выше (напр., к просмотру года).</li>
    </ul>
</body>
""",
    "help_ai_html": """
<body>
    <h2>Функции ИИ и Токенизатор</h2>
    <p>Tkonverter может рассчитать точное количество токенов, которое займёт ваш чат для конкретной ИИ-модели. Для этого требуется библиотека <b>transformers</b>.</p>
    <ul>
        <li>Нажмите на иконку <b>Загрузки</b>, чтобы открыть <b>Менеджер установки</b>.</li>
        <li>Там вы можете установить необходимые библиотеки и скачать модели токенизаторов с Hugging Face.</li>
        <li>Как только токенизатор будет загружен, анализ переключится со счёта символов на счёт токенов.</li>
    </ul>
</body>
""",
    "help_export_html": """
<body>
    <h2>Экспорт</h2>
    <p>Нажмите <b>"Сохранить в файл..."</b>, чтобы открыть диалог экспорта.</p>
    <p>Итоговый файл <code>.txt</code> будет учитывать все выбранные вами опции форматирования и любые фильтры по датам, которые вы применили с помощью Диаграммы анализа или Календаря.</p>
</body>
""",
}

translations = {
    "en": en_translations,
    "ru": ru_translations,
}

def set_language(lang_code: str):
    global _current_language
    _current_language = lang_code if lang_code in translations else "en"

def get_language() -> str:
    return _current_language

def tr(key: str, **kwargs) -> str:
    lang_dict = translations.get(_current_language, en_translations)
    translated_text = lang_dict.get(key, key)
    if kwargs:
        try:
            return translated_text.format(**kwargs)
        except (KeyError, IndexError):
            return translated_text
    return translated_text


--- Файл: ./src/resources/styles/base.qss ---
/* --- File: ./resources/styles/base.qss --- */
QCheckBox {
    spacing: 6px;
}
QCheckBox::indicator { width: 0px; height: 0px; }

QLabel, QRadioButton, QCheckBox {
    color: @dialog.text;
}

/* Styles for group header (specific to tkonverter) */
QLabel#StyledGroupTitle {
    color: @dialog.text;
    background-color: @Window; /* Important for overlapping border */
    padding-left: 5px;
    padding-right: 5px;
    font-weight: bold;
    qproperty-alignment: 'AlignVCenter | AlignLeft';
}

/* Styles for group border (specific to tkonverter) */
QFrame#StyledGroupFrame {
    border: 1px solid @dialog.border;
    border-radius: 6px;
}

/* --- Styles for dialogs (Settings, Help, Export) --- */
QDialog#SettingsDialog,
QDialog#HelpDialog,
QDialog#ExportDialog {
    background-color: @dialog.background;
}

QDialog QLabel, 
QDialog QRadioButton, 
QDialog QCheckBox {
    color: @dialog.text;
}

QDialog QLineEdit,
QDialog QSpinBox, 
QDialog QComboBox {
    background-color: @dialog.input.background;
    color: @dialog.text;
    border: 1px solid @dialog.border;
    border-radius: 4px;
    padding: 4px;
}

QDialog QSpinBox::up-button, 
QDialog QSpinBox::down-button, 
QDialog QComboBox::drop-down {
    border: none;
    background-color: transparent;
}

QDialog QPushButton {
    background-color: @dialog.button.background;
    color: @dialog.text;
    border: 1px solid @dialog.border;
    border-radius: 4px;
    padding: 5px 15px;
}

QDialog QPushButton:hover {
    background-color: @dialog.button.hover;
}

/* --- Styles for custom widgets --- */
/* Base style for all icon-button */
QWidget[class="icon-button"] {
    background-color: @button.default.background;
    border: 1px solid @button.default.border;
    border-radius: 6px;
}

QWidget[class="icon-button"]:hover,
QWidget[class="icon-button"][state="hover"] {
    background-color: @button.default.background.hover;
}

QWidget[class="icon-button"]:pressed,
QWidget[class="icon-button"][state="pressed"] {
    background-color: @button.default.background.pressed;
}

/* --- Styles for CustomButton --- */
/* Default style */
QWidget[class="custom-button"] {
    background-color: @button.default.background;
    border: 1px solid @button.default.border;
    border-radius: 6px;
    color: @dialog.text;
}
QWidget[class="custom-button"] QLabel {
    color: @dialog.text;
    background: transparent;
}
QWidget[class="custom-button"]:hover,
QWidget[class="custom-button"][state="hover"] {
    background-color: @button.default.background.hover;
}
QWidget[class="custom-button"]:pressed,
QWidget[class="custom-button"][state="pressed"] {
    background-color: @button.default.background.pressed;
}

/* "Primary" style */
QWidget[class="custom-button"][class~="primary"] {
    background-color: @button.primary.background;
    border: 1px solid @button.primary.border;
    color: @button.primary.text;
}
QWidget[class="custom-button"][class~="primary"] QLabel {
    color: @button.primary.text;
    background: transparent;
}
QWidget[class="custom-button"][class~="primary"]:hover,
QWidget[class="custom-button"][class~="primary"][state="hover"] {
    background-color: @button.primary.background.hover;
}
QWidget[class="custom-button"][class~="primary"]:pressed,
QWidget[class="custom-button"][class~="primary"][state="pressed"] {
    background-color: @button.primary.background.pressed;
}

/* Style for CustomLineEdit */
QLineEdit[custom-line-edit="true"] {
    background-color: @dialog.input.background;
    color: @dialog.text;
    border: none;
    border-radius: 6px;
    padding: 6px 10px;
}
QLineEdit[custom-line-edit="true"]:focus {
    border: none;
}

/* --- NEW BLOCK: Styles for log terminal --- */
QTextEdit#logOutput {
    border: 1px solid @dialog.border;
    border-radius: 6px;
    background-color: @dialog.input.background;
    color: @dialog.text;
    padding: 5px;
}

/* --- Styles for preview widget --- */
QTextEdit#previewTextEdit {
    border: 1px solid @dialog.border;
    border-radius: 6px;
    background-color: @dialog.input.background;
    color: @dialog.text;
    padding: 5px;
}

/* --- Styles for HelpDialog --- */
QDialog#HelpDialog QListWidget {
    background-color: @help.nav.background;
    border-right: 1px solid @help.nav.border;
    font-size: 14px;
    padding-top: 5px;
    outline: none;
    alternate-background-color: transparent;
    selection-background-color: transparent;
}

QDialog#HelpDialog QListWidget::item {
    background-color: transparent;
    color: @dialog.text;
    padding: 8px 15px;
    border: none;
    outline: none;
    border-radius: 4px;
}

QDialog#HelpDialog QListWidget::item:hover {
    background-color: @help.nav.hover;
    border-radius: 4px;
}

QDialog#HelpDialog QListWidget::item:selected {
    background-color: @help.nav.selected;
    color: @help.nav.selected.text;
    border-radius: 4px;
}

/* Force same style for all selection states to prevent double borders */
QDialog#HelpDialog QListWidget::item:selected:active,
QDialog#HelpDialog QListWidget::item:selected:!active,
QDialog#HelpDialog QListWidget::item:selected:focus,
QDialog#HelpDialog QListWidget::item:selected:!focus {
    background-color: @help.nav.selected;
    color: @help.nav.selected.text;
    border: none;
    outline: none;
    border-radius: 4px;
}



--- Файл: ./src/ui/tkonverter_main_window_ui.py ---
import logging

from PyQt6.QtCore import Qt
from PyQt6.QtWidgets import (
    QGridLayout,
    QHBoxLayout,
    QSizePolicy,
    QSplitter,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

from resources.translations import tr
from ui.icon_manager import AppIcon
from ui.widgets.atomic.adaptive_label import AdaptiveLabel, CompactLabel
from ui.widgets.atomic.drop_zone_label import DropZoneLabel
from ui.widgets.atomic.custom_button import CustomButton
from ui.widgets.atomic.custom_group_widget import CustomGroupBuilder
from ui.widgets.atomic.custom_line_edit import CustomLineEdit
from ui.widgets.atomic.fluent_radio import FluentRadioButton
from ui.widgets.atomic.fluent_switch import FluentSwitch
from ui.widgets.atomic.time_line_edit import TimeLineEdit

ui_logger = logging.getLogger("UI")
ui_logger.setLevel(logging.WARNING)

class Ui_TkonverterMainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("TkonverterMainWindow")

        main_layout = QHBoxLayout(MainWindow)
        main_layout.setSpacing(10)
        main_layout.setContentsMargins(10, 10, 10, 10)

        self.main_splitter = QSplitter(Qt.Orientation.Horizontal)

        self.left_column = QWidget()
        left_layout = QVBoxLayout(self.left_column)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.setSpacing(10)

        self.middle_column = QWidget()
        middle_layout = QVBoxLayout(self.middle_column)
        middle_layout.setContentsMargins(0, 0, 0, 0)
        middle_layout.setSpacing(10)

        self.right_column = QWidget()
        right_layout = QVBoxLayout(self.right_column)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(10)

        self.profile_group, profile_layout, self.profile_group_title = (
            CustomGroupBuilder.create_styled_group(tr("Profile"))
        )
        self.radio_group = FluentRadioButton(tr("Group Chat"))
        self.radio_group.setChecked(True)
        self.radio_channel = FluentRadioButton(tr("Channel"))
        self.radio_posts = FluentRadioButton(tr("Posts and Comments"))
        self.radio_personal = FluentRadioButton(tr("Personal Chat"))
        profile_layout.addWidget(self.radio_group)
        profile_layout.addWidget(self.radio_channel)
        profile_layout.addWidget(self.radio_posts)
        profile_layout.addWidget(self.radio_personal)

        self.personal_names_group, names_layout, self.personal_names_title = (
            CustomGroupBuilder.create_styled_group(tr("Names for Personal Chat"))
        )
        names_layout.setSpacing(6)
        self.my_name_label = CompactLabel(tr("Your name (in chat):"))
        self.line_edit_my_name = CustomLineEdit(tr("Me"))
        self.partner_name_label = CompactLabel(tr("Partner's name:"))
        self.line_edit_partner_name = CustomLineEdit(tr("Partner"))
        names_layout.addWidget(self.my_name_label)
        names_layout.addWidget(self.line_edit_my_name)
        names_layout.addWidget(self.partner_name_label)
        names_layout.addWidget(self.line_edit_partner_name)
        profile_layout.addWidget(self.personal_names_group)

        left_layout.addWidget(self.profile_group)

        left_layout.addStretch(1)

        self.options_group, options_layout, self.options_group_title = (
            CustomGroupBuilder.create_styled_group(tr("Options"))
        )
        options_layout.setSpacing(8)

        h_layout_time = QHBoxLayout()
        self.label_show_time = CompactLabel(tr("Show message time"))
        self.switch_show_time = FluentSwitch()
        self.switch_show_time.setChecked(True)

        h_layout_reactions = QHBoxLayout()
        self.label_show_reactions = CompactLabel(tr("Show reactions"))
        self.switch_show_reactions = FluentSwitch()
        self.switch_show_reactions.setChecked(True)

        h_layout_react_authors = QHBoxLayout()
        self.label_reaction_authors = CompactLabel(tr("Show reaction authors"))
        self.switch_reaction_authors = FluentSwitch()
        self.switch_reaction_authors.setChecked(False)

        h_layout_optimization = QHBoxLayout()
        self.label_show_optimization = CompactLabel(tr("Optimization"))
        self.switch_show_optimization = FluentSwitch()
        self.switch_show_optimization.setChecked(False)

        self.streak_time_container = QWidget()
        h_layout_streak_time = QHBoxLayout(self.streak_time_container)
        h_layout_streak_time.setContentsMargins(0, 0, 0, 0)
        self.label_streak_break_time = CompactLabel(tr("Streak break time:"))
        self.line_edit_streak_break_time = TimeLineEdit("20:00")

        h_layout_markdown = QHBoxLayout()
        self.label_show_markdown = CompactLabel(tr("Show Markdown"))
        self.switch_show_markdown = FluentSwitch()
        self.switch_show_markdown.setChecked(True)

        self.links_container = QWidget()
        h_layout_links = QHBoxLayout(self.links_container)
        h_layout_links.setContentsMargins(0, 0, 0, 0)
        self.label_show_links = CompactLabel(tr("Show links"))
        self.switch_show_links = FluentSwitch()
        self.switch_show_links.setChecked(True)

        h_layout_tech_info = QHBoxLayout()
        self.label_show_tech_info = CompactLabel(tr("Show technical information"))
        self.switch_show_tech_info = FluentSwitch()
        self.switch_show_tech_info.setChecked(True)

        h_layout_service = QHBoxLayout()
        self.label_show_service_notifications = CompactLabel(
            tr("Show service notifications")
        )
        self.switch_show_service_notifications = FluentSwitch()
        self.switch_show_service_notifications.setChecked(True)

        h_layout_time.addWidget(self.label_show_time)
        h_layout_time.addStretch()
        h_layout_time.addWidget(self.switch_show_time)

        h_layout_reactions.addWidget(self.label_show_reactions)
        h_layout_reactions.addStretch()
        h_layout_reactions.addWidget(self.switch_show_reactions)

        h_layout_react_authors.addWidget(self.label_reaction_authors)
        h_layout_react_authors.addStretch()
        h_layout_react_authors.addWidget(self.switch_reaction_authors)

        h_layout_optimization.addWidget(self.label_show_optimization)
        h_layout_optimization.addStretch()
        h_layout_optimization.addWidget(self.switch_show_optimization)

        self.right_part_container = QWidget()

        ref_switch = self.switch_show_markdown

        self.right_part_container.setFixedWidth(ref_switch.sizeHint().width())

        right_part_layout = QHBoxLayout(self.right_part_container)
        right_part_layout.setContentsMargins(0, 0, 0, 0)
        right_part_layout.setSpacing(0)

        self.line_edit_streak_break_time.setFixedWidth(ref_switch.TRACK_WIDTH)

        right_part_layout.addWidget(self.line_edit_streak_break_time)
        right_part_layout.addStretch(1)

        h_layout_streak_time.addWidget(self.label_streak_break_time)
        h_layout_streak_time.addStretch(1)

        h_layout_streak_time.addWidget(self.right_part_container)

        h_layout_markdown.addWidget(self.label_show_markdown)
        h_layout_markdown.addStretch()
        h_layout_markdown.addWidget(self.switch_show_markdown)

        h_layout_links.addWidget(self.label_show_links)
        h_layout_links.addStretch()
        h_layout_links.addWidget(self.switch_show_links)

        h_layout_tech_info.addWidget(self.label_show_tech_info)
        h_layout_tech_info.addStretch()
        h_layout_tech_info.addWidget(self.switch_show_tech_info)

        h_layout_service.addWidget(self.label_show_service_notifications)
        h_layout_service.addStretch()
        h_layout_service.addWidget(self.switch_show_service_notifications)

        options_layout.addLayout(h_layout_time)
        options_layout.addLayout(h_layout_reactions)
        options_layout.addLayout(h_layout_react_authors)
        options_layout.addLayout(h_layout_optimization)
        options_layout.addWidget(self.streak_time_container)
        options_layout.addLayout(h_layout_markdown)
        options_layout.addWidget(self.links_container)
        options_layout.addLayout(h_layout_tech_info)
        options_layout.addLayout(h_layout_service)

        middle_layout.addWidget(self.options_group)

        self.ai_group, ai_layout, self.ai_group_title = (
            CustomGroupBuilder.create_styled_group(tr("Analysis"))
        )
        ai_layout.setSpacing(6)

        tokens_layout = QHBoxLayout()
        self.tokens_label = CompactLabel(tr("Tokens:"))

        token_values_layout = QVBoxLayout()
        token_values_layout.setSpacing(0)
        self.token_count_label = AdaptiveLabel(tr("N/A"))
        self.token_count_label.setStyleSheet("font-weight: bold;")
        self.filtered_token_count_label = AdaptiveLabel("")
        self.filtered_token_count_label.setStyleSheet("font-weight: bold; color: #888;")
        token_values_layout.addWidget(self.token_count_label)
        token_values_layout.addWidget(self.filtered_token_count_label)
        tokens_layout.addWidget(self.tokens_label)
        tokens_layout.addLayout(token_values_layout)
        tokens_layout.addStretch()
        ai_layout.addLayout(tokens_layout)

        ai_buttons_layout = QHBoxLayout()
        self.recalculate_button = CustomButton(None, tr("Calculate"))
        self.calendar_button = CustomButton(AppIcon.CALENDAR, "")
        self.calendar_button.setToolTip(tr("Calendar View"))
        self.diagram_button = CustomButton(AppIcon.CHART, "")
        self.diagram_button.setToolTip(tr("Token Analysis"))
        ai_buttons_layout.addStretch()
        ai_buttons_layout.addWidget(self.recalculate_button)
        ai_buttons_layout.addWidget(self.calendar_button)
        ai_buttons_layout.addWidget(self.diagram_button)
        ai_layout.addLayout(ai_buttons_layout)

        middle_layout.addWidget(self.ai_group)

        self.left_part = QWidget()
        left_part_layout = QVBoxLayout(self.left_part)
        left_part_layout.setContentsMargins(0, 0, 0, 0)
        left_part_layout.setSpacing(10)

        columns_container = QWidget()
        columns_layout = QHBoxLayout(columns_container)
        columns_layout.setContentsMargins(0, 0, 0, 0)
        columns_layout.setSpacing(10)
        columns_layout.addWidget(self.left_column)
        columns_layout.addWidget(self.middle_column)

        left_part_layout.addWidget(columns_container)

        self.drop_zone = DropZoneLabel(tr("Drag and drop result.json file here"))
        self.drop_zone.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.drop_zone.setStyleSheet(
            "border: 2px dashed #aaa; border-radius: 10px; padding: 15px; font-size: 14px;"
        )
        self.drop_zone.setMinimumHeight(80)
        self.drop_zone.setSizePolicy(
            QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding
        )
        left_part_layout.addWidget(self.drop_zone, 1)

        (
            self.preview_group,
            preview_layout,
            self.preview_group_title_label,
        ) = CustomGroupBuilder.create_styled_group(tr("Preview"))

        self.preview_group.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

        self.preview_text_edit = QTextEdit()
        self.preview_text_edit.setObjectName("previewTextEdit")
        self.preview_text_edit.setReadOnly(True)

        self.preview_text_edit.setTextInteractionFlags(Qt.TextInteractionFlag.NoTextInteraction)
        self.preview_text_edit.viewport().setCursor(Qt.CursorShape.ArrowCursor)

        preview_layout.addWidget(self.preview_text_edit)

        self.terminal_group, terminal_layout, self.terminal_group_title = (
            CustomGroupBuilder.create_styled_group(tr("Terminal"))
        )

        self.log_output = QTextEdit()
        self.log_output.setObjectName("logOutput")
        self.log_output.setReadOnly(True)
        self.log_output.setTextInteractionFlags(
            Qt.TextInteractionFlag.NoTextInteraction
        )
        self.log_output.viewport().setCursor(Qt.CursorShape.ArrowCursor)
        terminal_layout.addWidget(self.log_output)
        self.terminal_group.setFixedHeight(90)

        bottom_layout = QHBoxLayout()

        button_container = QWidget()
        button_container_layout = QHBoxLayout(button_container)
        button_container_layout.setContentsMargins(0, 0, 0, 0)
        button_container_layout.setSpacing(6)

        self.install_manager_button = CustomButton(AppIcon.DOWNLOAD, "")
        self.install_manager_button.setToolTip(tr("Installation Manager"))
        self.settings_button = CustomButton(AppIcon.SETTINGS, "")
        self.settings_button.setToolTip(tr("Settings"))
        self.help_button = CustomButton(AppIcon.HELP, "")
        self.help_button.setToolTip(tr("Help"))
        self.save_button = CustomButton(AppIcon.SAVE, tr("Save to file..."))
        self.save_button.setProperty("class", "primary")

        button_container_layout.addWidget(self.install_manager_button)
        button_container_layout.addWidget(self.settings_button)
        button_container_layout.addWidget(self.help_button)
        button_container_layout.addWidget(self.save_button)

        bottom_layout.addStretch()
        bottom_layout.addWidget(button_container)

        right_layout.addWidget(self.preview_group)

        right_layout.addWidget(self.terminal_group)

        right_layout.addLayout(bottom_layout)

        self.main_splitter.addWidget(self.left_part)
        self.main_splitter.addWidget(self.right_column)

        self.main_splitter.setSizes([450, 900])

        self.main_splitter.setStretchFactor(0, 0)
        self.main_splitter.setStretchFactor(1, 1)

        self.main_splitter.setCollapsible(0, False)
        self.main_splitter.setCollapsible(1, True)

        main_layout.addWidget(self.main_splitter)

    def set_preview_title(self, title: str):
        """Sets preview title and updates sizes."""
        if self.preview_group_title_label:
            self.preview_group_title_label.setText(title)

    def update_group_titles_on_language_change(self):
        """Updates sizes of all groups when language changes."""

        pass

    def retranslate_ui(self):
        """Updates all translatable strings in UI."""

        if hasattr(self, "profile_group_title") and self.profile_group_title:
            self.profile_group_title.setText(tr("Profile"))
        if hasattr(self, "personal_names_title") and self.personal_names_title:
            self.personal_names_title.setText(tr("Names for Personal Chat"))
        if hasattr(self, "options_group_title") and self.options_group_title:
            self.options_group_title.setText(tr("Options"))
        if hasattr(self, "ai_group_title") and self.ai_group_title:
            self.ai_group_title.setText(tr("Analysis"))
        if hasattr(self, "terminal_group_title") and self.terminal_group_title:
            self.terminal_group_title.setText(tr("Terminal"))
        if (
            hasattr(self, "preview_group_title_label")
            and self.preview_group_title_label
        ):
            self.preview_group_title_label.setText(tr("Preview"))

        if hasattr(self, "my_name_label"):
            self.my_name_label.setText(tr("Your name (in chat):"))
        if hasattr(self, "partner_name_label"):
            self.partner_name_label.setText(tr("Partner's name:"))
        if hasattr(self, "label_show_time"):
            self.label_show_time.setText(tr("Show message time"))
        if hasattr(self, "label_show_reactions"):
            self.label_show_reactions.setText(tr("Show reactions"))
        if hasattr(self, "label_reaction_authors"):
            self.label_reaction_authors.setText(tr("Show reaction authors"))
        if hasattr(self, "label_show_optimization"):
            self.label_show_optimization.setText(tr("Optimization"))
        if hasattr(self, "label_streak_break_time"):
            self.label_streak_break_time.setText(tr("Streak break time:"))
        if hasattr(self, "label_show_markdown"):
            self.label_show_markdown.setText(tr("Show Markdown"))
        if hasattr(self, "label_show_links"):
            self.label_show_links.setText(tr("Show links"))
        if hasattr(self, "label_show_tech_info"):
            self.label_show_tech_info.setText(tr("Show technical information"))
        if hasattr(self, "label_show_service_notifications"):
            self.label_show_service_notifications.setText(
                tr("Show service notifications")
            )
        if hasattr(self, "drop_zone"):
            self.drop_zone.setText(tr("Drag and drop result.json file here"))

        if hasattr(self, "radio_group"):
            self.radio_group.setText(tr("Group Chat"))
        if hasattr(self, "radio_channel"):
            self.radio_channel.setText(tr("Channel"))
        if hasattr(self, "radio_posts"):
            self.radio_posts.setText(tr("Posts and Comments"))
        if hasattr(self, "radio_personal"):
            self.radio_personal.setText(tr("Personal Chat"))

        if hasattr(self, "recalculate_button"):
            self.recalculate_button.setText(tr("Calculate"))
        if hasattr(self, "save_button"):
            self.save_button.setText(tr("Save to file..."))

        if hasattr(self, "calendar_button"):
            self.calendar_button.setToolTip(tr("Calendar View"))
        if hasattr(self, "diagram_button"):
            self.diagram_button.setToolTip(tr("Token Analysis"))
        if hasattr(self, "install_manager_button"):
            self.install_manager_button.setToolTip(tr("Installation Manager"))
        if hasattr(self, "settings_button"):
            self.settings_button.setToolTip(tr("Settings"))

        self.update_group_titles_on_language_change()


--- Файл: ./src/ui/__init__.py ---



--- Файл: ./src/ui/tkonverter_main_window.py ---
import logging
import os
import re

from PyQt6.QtCore import Qt, QTimer, pyqtSignal
from PyQt6.QtGui import QIcon, QMouseEvent
from PyQt6.QtWidgets import QApplication, QDialog, QLabel, QMessageBox, QWidget

from core.dependency_injection import setup_container
from core.conversion.utils import markdown_to_html_for_preview
from core.settings import SettingsManager
from presenters.modern_presenter import ModernTkonverterPresenter
from resources.translations import set_language, tr
from ui.font_manager import FontManager
from ui.layout_manager import LayoutManager
from ui.theme import ThemeManager
from ui.tkonverter_main_window_ui import Ui_TkonverterMainWindow
from ui.widgets.atomic.minimalist_scrollbar import MinimalistScrollBar
from utils.paths import resource_path

main_window_logger = logging.getLogger("MainWindow")
main_window_logger.setLevel(logging.ERROR)

MAX_LOG_MESSAGES = 200

class TkonverterMainWindow(QWidget):
    config_changed = pyqtSignal(str, object)
    save_button_clicked = pyqtSignal()
    settings_button_clicked = pyqtSignal()
    install_manager_button_clicked = pyqtSignal()
    recalculate_clicked = pyqtSignal()
    calendar_button_clicked = pyqtSignal()
    diagram_button_clicked = pyqtSignal()
    help_button_clicked = pyqtSignal()

    def __init__(self, initial_theme: str, parent=None):
        super().__init__(parent)
        self.setAutoFillBackground(True)
        self._log_messages: list[tuple[str, str, dict]] = []
        self._initial_sizing_done = False

        self.settings_manager = SettingsManager("tkonverter", "tkonverter")

        ui_settings = self.settings_manager.load_ui_settings()

        if not ui_settings.get("my_name"):
            ui_settings["my_name"] = tr("Me")
        if not ui_settings.get("partner_name"):
            ui_settings["partner_name"] = tr("Partner")

        ui_settings.setdefault("profile", "group")
        ui_settings.setdefault("auto_detect_profile", True)
        ui_settings.setdefault("auto_recalc", False)

        self.settings_manager.save_ui_settings(ui_settings)

        set_language(self.settings_manager.load_language())

        self.theme_manager = ThemeManager.get_instance()

        self.font_manager = FontManager.get_instance()
        self.font_manager.font_changed.connect(self._on_font_changed)

        self.font_manager.apply_from_settings(self.settings_manager)

        self.ui = Ui_TkonverterMainWindow()
        self.ui.setupUi(self)

        log_scrollbar = MinimalistScrollBar(self.ui.log_output)
        self.ui.log_output.setVerticalScrollBar(log_scrollbar)
        self.ui.log_output.setVerticalScrollBarPolicy(
            Qt.ScrollBarPolicy.ScrollBarAsNeeded
        )

        preview_scrollbar = MinimalistScrollBar(self.ui.preview_text_edit)
        self.ui.preview_text_edit.setVerticalScrollBar(preview_scrollbar)
        self.ui.preview_text_edit.setVerticalScrollBarPolicy(
            Qt.ScrollBarPolicy.ScrollBarAsNeeded
        )

        self.setWindowTitle(tr("Tkonverter"))

        icon_path = resource_path("resources/icons/icon.png")
        if os.path.exists(icon_path):
            self.setWindowIcon(QIcon(icon_path))

        di_container = setup_container()

        self.presenter = ModernTkonverterPresenter(
            view=self,
            settings_manager=self.settings_manager,
            theme_manager=self.theme_manager,
            app_instance=QApplication.instance(),
            di_container=di_container,
            initial_theme=initial_theme,
            initial_config=ui_settings,
        )

        self._connect_presenter_signals()

        self.theme_manager.theme_changed.connect(self._on_app_theme_changed)

        self.layout_manager = LayoutManager(self)

        left_min = int(self.layout_manager.calculate_left_column_width())
        middle_min = int(self.layout_manager.calculate_middle_column_width())
        right_min = int(self.layout_manager.calculate_right_column_width())

        self.ui.left_column.setMinimumWidth(left_min)
        self.ui.middle_column.setMinimumWidth(middle_min)
        self.ui.right_column.setMinimumWidth(right_min)

        self._update_ui_from_model()
        self._connect_ui_signals()
        self._initial_ui_setup()
        self._update_terminal_styles()
        self._update_preview_styles()

    def _on_font_changed(self):
        """Handles font change."""
        try:
            if hasattr(self, 'layout_manager'):
                self.layout_manager.handle_language_change()

            self._invalidate_adaptive_widgets_cache()
            self.update()
            self.updateGeometry()

        except Exception as e:
            main_window_logger.error(f"Error updating font: {e}")

    def _rebuild_terminal_content(self):
        """Rebuilds terminal content with current styles."""

        self.ui.log_output.blockSignals(True)
        self.ui.log_output.clear()
        for css_class, message, format_args in self._log_messages:
            display_message = self._translate_log_message(message, format_args)
            self.ui.log_output.append(f'<span class="{css_class}">{display_message}</span>')
        self.ui.log_output.ensureCursorVisible()
        self.ui.log_output.blockSignals(False)

    def _translate_log_message(self, message_or_key: str, format_args: dict) -> str:
        """Translates and formats log message with argument translation support."""

        TRANSLATABLE_ARG_KEYS = {"unit"}

        display_message = ""
        try:
            translated_text = tr(message_or_key)

            if format_args:
                translated_args = format_args.copy()

                for key, value in translated_args.items():
                    if key in TRANSLATABLE_ARG_KEYS and isinstance(value, str):

                        translated_value = tr(value.capitalize())
                        translated_args[key] = translated_value

                display_message = translated_text.format(**translated_args)
            else:
                display_message = translated_text
        except (KeyError, ValueError, IndexError) as e:
            main_window_logger.error(f"Error translating/formatting log: {e}. Key: '{message_or_key}', Arguments: {format_args}")
            display_message = message_or_key
        return display_message

    def _update_terminal_styles(self):
        """Updates terminal styles and rebuilds its content."""
        info_color = self.theme_manager.get_color("dialog.text").name()
        error_color = "#D70000" if self.theme_manager.is_dark() else "#FF0000"
        status_color = "#9E9E9E"

        stylesheet = f"""
        body {{ color: {info_color}; }}
        .info {{ color: {info_color}; }}
        .error {{ color: {error_color}; font-weight: bold; }}
        .status {{ color: {status_color}; }}
        """
        self.ui.log_output.document().setDefaultStyleSheet(stylesheet)

        self._rebuild_terminal_content()

    def _on_app_theme_changed(self):
        """Handles application theme change."""
        self._update_terminal_styles()
        self._update_preview_styles()

    def closeEvent(self, event):
        self._save_state()
        super().closeEvent(event)

    def _save_state(self):

        current_config = self.presenter.get_config()

        existing_ui_settings = self.settings_manager.load_ui_settings()

        existing_ui_settings.update(current_config)

        self.settings_manager.save_ui_settings(existing_ui_settings)

    def _update_ui_from_model(self):
        config = self.presenter.get_config()

        profile = config.get("profile")

        if profile == "group":
            self.ui.radio_group.setChecked(True)
        elif profile == "channel":
            self.ui.radio_channel.setChecked(True)
        elif profile == "posts":
            self.ui.radio_posts.setChecked(True)
        elif profile == "personal":
            self.ui.radio_personal.setChecked(True)

        self.ui.switch_show_time.setChecked(config.get("show_time", True))
        self.ui.switch_show_reactions.setChecked(config.get("show_reactions", True))
        self.ui.switch_reaction_authors.setChecked(
            config.get("show_reaction_authors", False)
        )
        self.ui.line_edit_my_name.setText(config.get("my_name", tr("Me")))
        self.ui.line_edit_partner_name.setText(
            config.get("partner_name", tr("Partner"))
        )
        self.ui.switch_show_optimization.setChecked(
            config.get("show_optimization", False)
        )
        self.ui.line_edit_streak_break_time.setText(
            config.get("streak_break_time", "20:00")
        )

        self.ui.switch_show_markdown.setChecked(config.get("show_markdown", True))
        self.ui.switch_show_links.setChecked(config.get("show_links", True))
        self.ui.switch_show_tech_info.setChecked(config.get("show_tech_info", True))
        self.ui.switch_show_service_notifications.setChecked(
            config.get("show_service_notifications", True)
        )
        self.ui.personal_names_group.setVisible(profile == "personal")

    def set_profile_in_ui(self, profile: str):
        self.ui.radio_group.blockSignals(True)
        self.ui.radio_channel.blockSignals(True)
        self.ui.radio_posts.blockSignals(True)
        self.ui.radio_personal.blockSignals(True)

        if profile == "group":
            self.ui.radio_group.setChecked(True)
        elif profile == "channel":
            self.ui.radio_channel.setChecked(True)
        elif profile == "posts":
            self.ui.radio_posts.setChecked(True)
        elif profile == "personal":
            self.ui.radio_personal.setChecked(True)

        is_personal = profile == "personal"
        self.ui.personal_names_group.setVisible(is_personal)

        self.ui.radio_group.blockSignals(False)
        self.ui.radio_channel.blockSignals(False)
        self.ui.radio_posts.blockSignals(False)
        self.ui.radio_personal.blockSignals(False)

    def set_analysis_unit(self, unit: str):
        if unit == "tokens":
            self.ui.recalculate_button.setText(tr("Recalculate"))
        else:
            self.ui.recalculate_button.setText(tr("Calculate"))

        self._update_analysis_display()

    def _on_language_changed(self):
        """
        Handles language change.
        This method should be the only point for UI updates after language change.
        """
        self.setWindowTitle(tr("Tkonverter"))

        if hasattr(self.ui, "retranslate_ui"):
            self.ui.retranslate_ui()

        from .widgets.atomic.fluent_switch import FluentSwitch
        for switch in self.findChildren(FluentSwitch):
            switch.retranslate_ui()

        self._rebuild_terminal_content()

        self._invalidate_adaptive_widgets_cache()

        self.presenter._generate_preview()

        self.retranslate_dynamic_ui()

        self._update_control_alignment()
        self.layout_manager.handle_language_change()

        self.updateGeometry()
        self.update()

    def _update_control_alignment(self):
        """Recalculates and sets the fixed width for the TimeLineEdit container to align it."""
        ref_switch = self.ui.switch_show_markdown
        self.ui.right_part_container.setFixedWidth(ref_switch.sizeHint().width())

    def _initial_ui_setup(self):

        self.ui.personal_names_group.hide()

        self._update_ui_from_model()

        self.ui.token_count_label.hide()
        self.ui.filtered_token_count_label.hide()

        app_state = self.presenter.get_app_state()
        self.set_analysis_unit(app_state.last_analysis_unit)

        self._update_analysis_display()

        self._handle_reactions_visibility_change(
            self.ui.switch_show_reactions.isChecked()
        )
        self._handle_optimization_visibility_change(
            self.ui.switch_show_optimization.isChecked()
        )

        self.presenter._generate_preview()

    def _connect_ui_signals(self):

        self.ui.radio_group.toggled.connect(self._handle_profile_change)
        self.ui.radio_channel.toggled.connect(self._handle_profile_change)
        self.ui.radio_posts.toggled.connect(self._handle_profile_change)
        self.ui.radio_personal.toggled.connect(self._handle_profile_change)

        self.ui.switch_show_time.checkedChanged.connect(
            self._handle_show_time_change
        )

        self.ui.switch_show_markdown.checkedChanged.connect(
            self._handle_show_markdown_change
        )
        self.ui.switch_show_reactions.checkedChanged.connect(
            self._handle_reactions_switch_change
        )

        self.ui.switch_reaction_authors.checkedChanged.connect(
            self._handle_show_reaction_authors_change
        )
        self.ui.line_edit_my_name.textChanged.connect(
            self._handle_my_name_change
        )
        self.ui.line_edit_partner_name.textChanged.connect(
            self._handle_partner_name_change
        )
        self.ui.switch_show_optimization.checkedChanged.connect(
            self._handle_optimization_switch_change
        )
        self.ui.line_edit_streak_break_time.textChanged.connect(
            self._handle_streak_break_time_change
        )
        self.ui.save_button.clicked.connect(self.save_button_clicked)
        self.ui.settings_button.clicked.connect(self.settings_button_clicked)
        self.ui.install_manager_button.clicked.connect(
            self.install_manager_button_clicked
        )
        self.ui.switch_show_links.checkedChanged.connect(
            self._handle_show_links_change
        )
        self.ui.switch_show_tech_info.checkedChanged.connect(
            self._handle_show_tech_info_change
        )
        self.ui.switch_show_service_notifications.checkedChanged.connect(
            self._handle_show_service_notifications_change
        )

        self.ui.recalculate_button.clicked.connect(self.recalculate_clicked)

        self.ui.calendar_button.clicked.connect(self.calendar_button_clicked)
        self.ui.diagram_button.clicked.connect(self.diagram_button_clicked)
        self.ui.help_button.clicked.connect(self.help_button_clicked)

    def _connect_presenter_signals(self):
        """Connects signals from presenter to view."""

        self.presenter.chat_loaded.connect(self.on_chat_loaded)
        self.presenter.profile_auto_detected.connect(self.set_profile_in_ui)
        self.presenter.preview_updated.connect(self.on_preview_updated)
        self.presenter.analysis_unit_changed.connect(self.set_analysis_unit)
        self.presenter.save_completed.connect(self.on_save_completed)
        self.presenter.analysis_count_updated.connect(self.on_analysis_count_updated)
        self.presenter.disabled_nodes_changed.connect(self._update_analysis_display)

        self.presenter.language_changed.connect(self._on_language_changed)

        self.ui.drop_zone.file_dropped.connect(self.presenter.on_file_dropped)
        self.ui.drop_zone.drop_zone_hover_state_changed.connect(self.presenter.on_drop_zone_hover_state_changed)
        self.ui.drop_zone.drop_zone_drag_active.connect(self.presenter.on_drop_zone_drag_active)

        self.presenter.set_drop_zone_style_command.connect(self.set_drop_zone_style)

    def on_chat_loaded(self, success: bool, message: str, chat_name: str):
        """Handles chat loading."""

        if success:
            file_path = self.presenter.get_current_file_path()
            if file_path:
                filename = os.path.basename(file_path)
                self.show_status(
                    tr("File loaded: {filename}").format(filename=filename),
                    is_error=False,
                    message_key="File loaded: {filename}",
                    format_args={"filename": filename}
                )

            if chat_name:
                self.show_status(
                    tr("Chat name: {name}").format(name=chat_name),
                    is_error=False,
                    message_key="Chat name: {name}",
                    format_args={"name": chat_name}
                )
        else:
            main_window_logger.error(f"Chat loading error: {message}")
            self.show_status(message, is_error=True)

    def on_preview_updated(self, raw_text: str, title: str):
        """Handles preview update, converting raw_text to HTML."""

        self.ui.set_preview_title(title)

        html_text = self._markdown_to_html(raw_text)

        self.ui.preview_text_edit.setHtml(html_text)

        QTimer.singleShot(100, lambda: self.ui.preview_text_edit.verticalScrollBar().setValue(0))

    def on_save_completed(self, success: bool, path_or_error: str):
        """Handles saving completion."""
        self.set_processing_state(False)
        if success:
            self.show_status(
                tr("File saved: {path}").format(path=path_or_error),
                message_key="File saved: {path}",
                format_args={"path": path_or_error},
            )
        else:
            self.show_status(
                tr("Error saving file: {error}").format(error=path_or_error),
                True,
                message_key="Error saving file: {error}",
                format_args={"error": path_or_error},
            )

    def on_analysis_count_updated(self, count: int, unit: str):
        """Handles analysis count update."""
        self._update_analysis_display()

        if count > 0:

            if unit == "tokens":
                message_key = "Tokens calculated: {count}"
            else:
                message_key = "Characters calculated: {count}"

            self.show_status(
                tr(message_key).format(count=f"{count:,}"),
                message_key=message_key,
                format_args={"count": f"{count:,}"}
            )

    def _show_diagram_placeholder(self):
        QMessageBox.information(
            self,
            tr("Token Analysis"),
            tr("Token analysis feature is under development."),
        )

    def _handle_reactions_switch_change(self, is_checked: bool):
        self.config_changed.emit("show_reactions", is_checked)
        self._handle_reactions_visibility_change(is_checked)

    def _handle_reactions_visibility_change(self, is_reactions_visible: bool):
        self.ui.label_reaction_authors.setVisible(is_reactions_visible)
        self.ui.switch_reaction_authors.setVisible(is_reactions_visible)

        self.layout_manager.handle_visibility_change(
            "reaction_authors", is_reactions_visible
        )

    def _handle_optimization_switch_change(self, is_checked: bool):
        self.config_changed.emit("show_optimization", is_checked)
        self._handle_optimization_visibility_change(is_checked)

    def _handle_optimization_visibility_change(self, is_optimization_visible: bool):
        self.ui.streak_time_container.setVisible(is_optimization_visible)

        self.layout_manager.handle_visibility_change(
            "streak_time_container", is_optimization_visible
        )

    def _handle_profile_change(self):

        is_personal = self.ui.radio_personal.isChecked()

        self.ui.personal_names_group.setVisible(is_personal)

        self.layout_manager.handle_visibility_change(
            "personal_names_group", is_personal
        )

        if self.ui.radio_group.isChecked():
            profile = "group"
        elif self.ui.radio_channel.isChecked():
            profile = "channel"
        elif self.ui.radio_posts.isChecked():
            profile = "posts"
        else:
            profile = "personal"

        self.config_changed.emit("profile", profile)

    def set_drop_zone_style(self, style_sheet_str: str):
        """Sets style for the drop zone (command from Presenter)."""
        self.ui.drop_zone.setStyleSheet(style_sheet_str)

    def update_example_preview(self, text: str):
        self.ui.preview_text_edit.setHtml(text)

        QTimer.singleShot(100, lambda: self.ui.preview_text_edit.verticalScrollBar().setValue(0))

    def _update_analysis_display(self):
        """Updates all widgets related to analysis based on current state."""
        app_state = self.presenter.get_app_state()
        unit = app_state.last_analysis_unit

        label_key = "Tokens:" if unit == "tokens" else "Characters:"
        self.ui.tokens_label.setText(tr(label_key))

        if not app_state.has_analysis_data():
            self.ui.token_count_label.setText(tr("N/A"))
            self.ui.token_count_label.show()
            self.ui.filtered_token_count_label.hide()
            return

        total_count = app_state.analysis_result.total_count
        stats = self.presenter.get_analysis_stats()
        filtered_count = stats.get("filtered_count", total_count) if stats else total_count

        has_filter = app_state.has_disabled_nodes() and int(filtered_count) != total_count

        if has_filter:
            self.ui.token_count_label.setText(f"<s>{total_count:,}</s>")
            self.ui.filtered_token_count_label.setText(f"→ {filtered_count:,.0f}")
            self.ui.filtered_token_count_label.show()
        else:
            self.ui.token_count_label.setText(f"{total_count:,}")
            self.ui.filtered_token_count_label.hide()

        self.ui.token_count_label.show()

    def _handle_show_time_change(self, is_checked: bool):
        """Handles show time option change."""
        self.config_changed.emit("show_time", is_checked)

    def _handle_show_markdown_change(self, is_checked: bool):
        """Handles show markdown option change."""
        self.config_changed.emit("show_markdown", is_checked)

    def _handle_show_reaction_authors_change(self, is_checked: bool):
        """Handles show reaction authors option change."""
        self.config_changed.emit("show_reaction_authors", is_checked)

    def _handle_my_name_change(self, text: str):
        """Handles my name change."""
        self.config_changed.emit("my_name", text)

    def _handle_partner_name_change(self, text: str):
        """Handles partner name change."""
        self.config_changed.emit("partner_name", text)

    def _handle_streak_break_time_change(self, text: str):
        """Handles streak break time change."""
        self.config_changed.emit("streak_break_time", text)

    def _handle_show_links_change(self, is_checked: bool):
        """Handles show links option change."""
        self.config_changed.emit("show_links", is_checked)

    def _handle_show_tech_info_change(self, is_checked: bool):
        """Handles show tech info option change."""
        self.config_changed.emit("show_tech_info", is_checked)

    def _handle_show_service_notifications_change(self, is_checked: bool):
        """Handles show service notifications option change."""
        self.config_changed.emit("show_service_notifications", is_checked)

    def retranslate_dynamic_ui(self):
        """Translates dynamic parts of UI that are not handled by retranslate_ui."""
        self._update_analysis_display()

    def show_status(
        self,
        message: str = "",
        is_error: bool = False,
        message_key: str = None,
        format_args: dict = None,
        is_status: bool = False,
    ):
        """Shows message in terminal, performing translation manually."""
        if is_status:
            css_class = "status"
        else:
            css_class = "error" if is_error else "info"

        if message_key:
            self._log_messages.append((css_class, message_key, format_args or {}))
        else:

            self._log_messages.append((css_class, message, {}))

        self._log_messages = self._log_messages[-MAX_LOG_MESSAGES:]

        display_message = self._translate_log_message(message_key or message, format_args or {})

        self.ui.log_output.append(f'<span class="{css_class}">{display_message}</span>')
        self.ui.log_output.ensureCursorVisible()

    def set_processing_state(self, is_processing: bool, message: str | None = None, message_key: str = None, format_args: dict = None):
        """Sets processing state with translation key support."""

        if is_processing and (message or message_key):
            css_class = "status"

            if message_key:
                self._log_messages.append((css_class, message_key, format_args or {}))
            else:
                self._log_messages.append((css_class, message, {}))
            self._log_messages = self._log_messages[-MAX_LOG_MESSAGES:]

            display_message = self._translate_log_message(message_key or message, format_args or {})

            if display_message:
                self.ui.log_output.append(f'<span class="{css_class}">{display_message}</span>')
                self.ui.log_output.ensureCursorVisible()

    def _setup_automatic_sizing(self):
        """Sets up automatic window sizing."""
        try:
            min_size = self.layout_manager.calculate_minimum_window_size()
            self.setMinimumSize(min_size)

            initial_width = max(min_size.width(), 1000)
            initial_height = max(min_size.height(), 600)
            self.resize(initial_width, initial_height)

        except Exception as e:
            main_window_logger.error(f"Error setting up automatic sizes: {e}")
            import traceback
            main_window_logger.error(f"Traceback: {traceback.format_exc()}")
            self.resize(1000, 600)

    def _invalidate_adaptive_widgets_cache(self):
        """Resets sizes of all adaptive widgets."""
        try:
            from ui.widgets.atomic.adaptive_label import AdaptiveLabel, CompactLabel

            for widget in self.findChildren(AdaptiveLabel):
                if hasattr(widget, "invalidate_size_cache"):
                    widget.invalidate_size_cache()

            for widget in self.findChildren(CompactLabel):
                if hasattr(widget, "invalidate_size_cache"):
                    widget.invalidate_size_cache()

        except Exception as e:
            main_window_logger.error(f"Error resetting adaptive widget caches: {e}")

    def _update_preview_styles(self):
        """Updates CSS styles for the preview QTextEdit."""
        theme = self.theme_manager
        text_color = theme.get_color("dialog.text").name()
        link_color = theme.get_color("accent").name()
        spoiler_bg = theme.get_color("dialog.button.hover").name()
        code_bg = theme.get_color("dialog.button.hover").name()

        stylesheet = f"""
        body {{ color: {text_color}; }}
        a {{ color: {link_color}; text-decoration: none; }}
        .spoiler {{
            background-color: {spoiler_bg};
            color: {spoiler_bg};
            border-radius: 3px;
            padding: 1px 3px;
        }}
        .spoiler:hover {{
            color: {text_color};
        }}
        code {{
            background-color: {code_bg};
            border-radius: 3px;
            font-family: monospace;
            padding: 1px 3px;
        }}
        """
        self.ui.preview_text_edit.document().setDefaultStyleSheet(stylesheet)
        self.ui.preview_text_edit.setHtml(self.ui.preview_text_edit.toHtml())

    def _markdown_to_html(self, text: str) -> str:
        """Converts simple markdown-like text to basic HTML for preview."""
        html_result = markdown_to_html_for_preview(text)
        return html_result

    def retranslate_ui(self):
        """Updates translations in UI."""
        try:
            self.setWindowTitle(tr("Tkonverter"))

            if hasattr(self.ui, "retranslate_ui"):
                self.ui.retranslate_ui()
        except Exception as e:
            main_window_logger.error(f"Error updating translations: {e}")

    def refresh_theme_styles(self):
        """Forces main window styles to update."""
        try:
            self.style().unpolish(self)
            self.style().polish(self)
            self._update_terminal_styles()
            self.update()
            self.updateGeometry()
        except Exception as e:
            main_window_logger.error(f"Error refreshing main window styles: {e}")

    def show_message_box(self, title: str, text: str, icon_type: QMessageBox.Icon = QMessageBox.Icon.Information):
        """Shows message box."""
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle(title)
        msg_box.setText(text)
        msg_box.setIcon(icon_type)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Ok)
        self.theme_manager.apply_theme_to_dialog(msg_box)
        msg_box.exec()

    def bring_dialog_to_front(self, dialog: QDialog, dialog_name: str):
        """Reliably brings dialog to the front (delegating to Presenter)."""
        from PyQt6.QtCore import QTimer

        try:
            if dialog.isMinimized():
                dialog.setWindowState(dialog.windowState() & ~Qt.WindowState.WindowMinimized | Qt.WindowState.WindowActive)

            if not dialog.isVisible():
                dialog.show()

            dialog.raise_()
            dialog.activateWindow()

            QTimer.singleShot(50, lambda: self._force_dialog_focus(dialog, dialog_name))

        except Exception as e:
            main_window_logger.error(f"Error bringing up {dialog_name} dialog: {e}")

    def _force_dialog_focus(self, dialog: QDialog, dialog_name: str):
        """Forcibly sets focus on dialog."""
        try:
            if dialog and not dialog.isActiveWindow():
                dialog.setFocus()
                dialog.repaint()

                if not dialog.isActiveWindow():
                    dialog.show()
                    dialog.raise_()
                    dialog.activateWindow()

        except Exception as e:
            main_window_logger.error(f"Error forcing {dialog_name} dialog activation: {e}")

    def showEvent(self, event):
        """Called before the window is shown for the first time."""
        super().showEvent(event)

        if not self._initial_sizing_done:

            try:
                longest_preview_html = self.presenter.get_longest_preview_html()

                if longest_preview_html:
                    self.layout_manager.calculate_and_set_preview_height(longest_preview_html)
                else:
                    main_window_logger.warning("HTML not received, skipping preview height calculation.")

                self._initial_sizing_done = True

                self.presenter._generate_preview()

            except Exception as e:
                main_window_logger.error(f"Error during initial size setup: {e}")
                import traceback
                main_window_logger.error(f"Traceback: {traceback.format_exc()}")
                main_window_logger.warning("Continuing without preview size setup")

    def mousePressEvent(self, event: QMouseEvent):
        """Removes focus from input fields when clicking on empty area."""
        self.clear_input_focus()
        super().mousePressEvent(event)

    def clear_input_focus(self):
        """Removes focus if it's set on QLineEdit or TimeLineEdit."""
        focused_widget = self.focusWidget()
        if not focused_widget:
            return

        is_my_name = focused_widget == self.ui.line_edit_my_name
        is_partner_name = focused_widget == self.ui.line_edit_partner_name
        is_streak_time = (focused_widget == self.ui.line_edit_streak_break_time or
                          focused_widget.parent() == self.ui.line_edit_streak_break_time)

        if is_my_name or is_partner_name or is_streak_time:
            focused_widget.clearFocus()


--- Файл: ./src/ui/icon_manager.py ---
import os
from enum import Enum
from functools import lru_cache

from PyQt6.QtCore import QSize, Qt
from PyQt6.QtGui import QColor, QIcon, QPainter, QPixmap

from ui.theme import ThemeManager
from utils.paths import resource_path

class AppIcon(Enum):
    SETTINGS = "settings.svg"
    SAVE = "save.svg"
    FOLDER_OPEN = "folder_open.svg"
    CHART = "chart.svg"
    DOWNLOAD = "download.svg"
    CALENDAR = "calendar.svg"
    HELP = "help.svg"

@lru_cache(maxsize=32)
def _get_cached_icon(icon: AppIcon, is_dark: bool) -> QIcon:
    if not isinstance(icon, AppIcon):
        return QIcon()

    relative_path = os.path.join("resources", "assets", "icons", icon.value)
    full_path = resource_path(relative_path)

    if not os.path.exists(full_path):

        return QIcon()

    source_icon = QIcon(full_path)

    if not is_dark:
        return source_icon

    base_size = source_icon.actualSize(QSize(256, 256))
    if not base_size.isValid():
        base_size = QSize(256, 256)

    source_pixmap = source_icon.pixmap(base_size)
    if source_pixmap.isNull():
        return source_icon

    result_pixmap = QPixmap(source_pixmap.size())
    result_pixmap.fill(Qt.GlobalColor.transparent)
    painter = QPainter(result_pixmap)
    painter.drawPixmap(0, 0, source_pixmap)
    painter.setCompositionMode(QPainter.CompositionMode.CompositionMode_SourceIn)
    painter.fillRect(result_pixmap.rect(), QColor("white"))
    painter.end()

    return QIcon(result_pixmap)

def get_icon(icon: AppIcon) -> QIcon:
    theme_manager = ThemeManager.get_instance()
    return _get_cached_icon(icon, theme_manager.is_dark())


--- Файл: ./src/ui/layout_manager.py ---
"""
Layout manager for automatic window size calculation.

Provides adaptive layout functionality including:
- Dynamic minimum window size calculation
- Interface language adaptation
- Content overflow prevention
"""

import logging
from typing import Dict, Optional

from PyQt6.QtCore import QSize, QTimer
from PyQt6.QtGui import QFontMetrics
from PyQt6.QtWidgets import QApplication

from resources.translations import tr

logger = logging.getLogger(__name__)

class LayoutManager:
    """Layout manager for automatic size calculation."""

    MIN_WINDOW_WIDTH = 800
    MIN_WINDOW_HEIGHT = 500

    MAIN_MARGIN = 10
    SPACING = 10
    GROUP_PADDING = 20

    BUTTON_HEIGHT = 30
    ICON_BUTTON_SIZE = 33
    TERMINAL_HEIGHT = 90
    DROP_ZONE_MIN_HEIGHT = 80

    LEFT_COLUMN_MIN = 240
    MIDDLE_COLUMN_MIN = 310
    RIGHT_COLUMN_MIN = 390

    def __init__(self, main_window):
        """Initialize layout manager."""
        self.main_window = main_window
        self._cached_sizes: Dict[str, QSize] = {}
        self._size_timer = QTimer()
        self._size_timer.setSingleShot(True)
        self._size_timer.timeout.connect(self._recalculate_window_size)
        self._calculated_preview_height = 200

    def calculate_minimum_window_size(self) -> QSize:
        """Calculates minimum window size based on content."""
        try:
            left_width = self.calculate_left_column_width()
            middle_width = self.calculate_middle_column_width()
            right_width = self.calculate_right_column_width()

            total_content_width = max(
                left_width + middle_width, self.LEFT_COLUMN_MIN + self.MIDDLE_COLUMN_MIN
            )
            right_content_width = max(right_width, self.RIGHT_COLUMN_MIN)

            min_width = max(
                total_content_width
                + right_content_width
                + self.MAIN_MARGIN * 3
                + self.SPACING,
                self.MIN_WINDOW_WIDTH,
            )

            min_height = self._calculate_window_height()

            calculated_size = QSize(int(min_width), int(min_height))

            return calculated_size

        except Exception as e:
            logger.error(f"Error calculating window size: {e}")
            return QSize(self.MIN_WINDOW_WIDTH, self.MIN_WINDOW_HEIGHT)

    def calculate_left_column_width(self) -> float:
        """Calculates minimum width of left column (Profile group)."""
        try:
            ui = self.main_window.ui
            width = self.LEFT_COLUMN_MIN

            if hasattr(ui, "profile_group"):
                profile_width = self._calculate_group_width(
                    tr("Profile"),
                    [
                        tr("Group Chat"),
                        tr("Channel"),
                        tr("Posts and Comments"),
                        tr("Personal Chat"),
                    ],
                )
                width = max(width, profile_width)

            if hasattr(ui, "personal_names_group"):
                names_width = self._calculate_group_width(
                    tr("Names for Personal Chat"),
                    [tr("Your name (in chat):"), tr("Partner's name:")],
                )
                width = max(width, names_width)

            return width

        except Exception as e:
            logger.error(f"Error calculating left column width: {e}")
            return self.LEFT_COLUMN_MIN

    def calculate_middle_column_width(self) -> float:
        """Calculates minimum width of middle column (Options + AI)."""
        try:
            ui = self.main_window.ui
            width = self.MIDDLE_COLUMN_MIN

            option_labels = [
                tr("Show message time"),
                tr("Show reactions"),
                tr("Show reaction authors"),
                tr("Optimization"),
                tr("Streak break time:"),
                tr("Show Markdown"),
                tr("Show links"),
                tr("Show technical information"),
                tr("Show service notifications"),
            ]
            options_width = self._calculate_group_width(tr("Options"), option_labels)
            width = max(width, options_width)

            ai_width = self._calculate_group_width(
                tr("Analysis"), [tr("Tokens:"), tr("Calculate")]
            )
            width = max(width, ai_width)

            return width

        except Exception as e:
            logger.error(f"Error calculating middle column width: {e}")
            return self.MIDDLE_COLUMN_MIN

    def calculate_right_column_width(self) -> float:
        """Calculates minimum width of right column (Preview + Terminal)."""
        try:
            width = self.RIGHT_COLUMN_MIN

            preview_width = self._calculate_group_width(tr("Preview"), [])
            terminal_width = self._calculate_group_width(tr("Terminal"), [])

            buttons = [
                self.main_window.ui.install_manager_button,
                self.main_window.ui.settings_button,
                self.main_window.ui.save_button,
            ]
            buttons_width = self._calculate_buttons_width(buttons)

            width = max(width, preview_width, terminal_width, buttons_width)

            return width

        except Exception as e:
            logger.error(f"Error calculating right column width: {e}")
            return self.RIGHT_COLUMN_MIN

    def _calculate_window_height(self) -> float:
        """Calculates minimum window height."""
        try:
            group_title_height = 20
            control_height = 25

            left_height = (
                group_title_height + 4 * control_height + self.GROUP_PADDING
            ) + (group_title_height + 2 * control_height + self.GROUP_PADDING)

            middle_height = (
                group_title_height + 9 * control_height + self.GROUP_PADDING
            ) + (
                group_title_height
                + 2 * control_height
                + self.BUTTON_HEIGHT
                + self.GROUP_PADDING
            )
            right_height = self._calculated_preview_height + self.TERMINAL_HEIGHT + self.BUTTON_HEIGHT

            drop_zone_height = self.DROP_ZONE_MIN_HEIGHT

            content_height = max(left_height, middle_height) + drop_zone_height
            total_height = max(content_height, right_height, self.MIN_WINDOW_HEIGHT)

            final_height = total_height + self.MAIN_MARGIN * 2

            return final_height

        except Exception as e:
            logger.error(f"Error calculating window height: {e}")
            return self.MIN_WINDOW_HEIGHT

    def _calculate_group_width(self, title: str, content_labels: list) -> float:
        """Calculates minimum width of a group."""
        try:
            font_metrics = QFontMetrics(QApplication.instance().font())

            title_width = font_metrics.horizontalAdvance(title)

            content_width = 0
            for label in content_labels:
                label_width = font_metrics.horizontalAdvance(label)
                content_width = max(content_width, label_width)

            group_width = max(title_width + 40, content_width + 100)

            return group_width

        except Exception as e:
            logger.error(f"Error calculating group width: {e}")
            return 200

    def _calculate_buttons_width(self, buttons: list) -> float:
        """Calculates minimum width for buttons."""
        try:
            total_width = 0
            if not buttons:
                return 200

            for button in buttons:
                total_width += button.sizeHint().width()
            total_width += self.SPACING * (len(buttons) - 1)

            return total_width

        except Exception as e:
            logger.error(f"Error calculating buttons width: {e}")
            return 200

    def schedule_size_recalculation(self, delay_ms: int = 100):
        """Schedules window size recalculation with delay."""
        self._size_timer.start(delay_ms)

    def _recalculate_window_size(self):
        """Recalculates and applies new window sizes."""
        try:
            new_min_size = self.calculate_minimum_window_size()

            self.main_window.setMinimumSize(new_min_size)

            current_size = self.main_window.size()

            if (
                current_size.width() < new_min_size.width()
                or current_size.height() < new_min_size.height()
            ):
                new_width = max(current_size.width(), new_min_size.width())
                new_height = max(current_size.height(), new_min_size.height())

                self.main_window.resize(new_width, new_height)

        except Exception as e:
            logger.error(f"Error recalculating window size: {e}")

    def handle_language_change(self):
        """Handles language change and recalculates sizes."""
        self._cached_sizes.clear()
        self.schedule_size_recalculation(200)

    def handle_visibility_change(self, widget_name: str, is_visible: bool):
        """Handles widget visibility changes."""
        self.schedule_size_recalculation(50)

    def get_cached_size(self, key: str) -> Optional[QSize]:
        """Gets cached size."""
        return self._cached_sizes.get(key)

    def cache_size(self, key: str, size: QSize):
        """Caches size."""
        self._cached_sizes[key] = size

    def calculate_and_set_preview_height(self, html_content: str):
        """
        Calculates and saves preview widget height based on HTML content.
        """
        try:
            preview_widget = self.main_window.ui.preview_text_edit

            preview_widget.setHtml(html_content)

            import time
            time.sleep(0.1)

            doc_size = preview_widget.document().size()

            raw_height = doc_size.height()
            adjusted_height = raw_height + 40

            self._calculated_preview_height = max(200, min(int(adjusted_height), 500))

        except Exception as e:
            logger.error(f"=== PREVIEW HEIGHT CALCULATION ERROR ===")
            logger.error(f"Error type: {type(e).__name__}")
            logger.error(f"Error message: {e}")
            import traceback
            logger.error(f"Traceback: {traceback.format_exc()}")

            logger.warning("Setting default preview height: 200")
            self._calculated_preview_height = 200



--- Файл: ./src/ui/splash_screen.py ---
from PyQt6.QtCore import QRectF, Qt
from PyQt6.QtGui import QBrush, QPainter, QPen
from PyQt6.QtWidgets import QApplication, QLabel, QVBoxLayout, QWidget

from resources.translations import tr
from ui.theme import ThemeManager
from ui.widgets.atomic.loading_spinner import LoadingSpinner

class SplashScreen(QWidget):
    def __init__(self):
        super().__init__()

        self.setObjectName("SplashScreen")

        self.setWindowFlags(
            Qt.WindowType.SplashScreen
            | Qt.WindowType.FramelessWindowHint
            | Qt.WindowType.WindowStaysOnTopHint
        )
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)

        self.setMinimumSize(300, 200)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        self.logo_placeholder = QLabel("Tkonverter")
        self.logo_placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.logo_placeholder.setStyleSheet("font-size: 24px; font-weight: bold;")

        self.spinner = LoadingSpinner(self)

        self.status_label = QLabel(tr("Preparing to launch"), self)
        self.status_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.status_label.setWordWrap(True)

        layout.addStretch()
        layout.addWidget(self.logo_placeholder)
        layout.addWidget(self.spinner, 0, Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.status_label)
        layout.addStretch()

        self.spinner.start()

        screen_geometry = QApplication.primaryScreen().geometry()
        self.move(screen_geometry.center() - self.rect().center())

    def update_status(self, text: str):
        self.status_label.setText(text)
        QApplication.processEvents()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)

        theme_manager = ThemeManager.get_instance()
        bg_color = theme_manager.get_color("dialog.background")
        border_color = theme_manager.get_color("dialog.border")

        painter.setBrush(QBrush(bg_color))

        painter.setPen(QPen(border_color, 1))

        rect = QRectF(self.rect()).adjusted(0.5, 0.5, -0.5, -0.5)
        painter.drawRoundedRect(rect, 8.0, 8.0)

        super().paintEvent(event)


--- Файл: ./src/ui/theme.py ---
import logging
import os
import copy

from PyQt6.QtCore import QObject, pyqtSignal
from PyQt6.QtGui import QColor, QPalette
from PyQt6.QtWidgets import QApplication

theme_logger = logging.getLogger("ThemeManager")

LIGHT_THEME_PALETTE = {
    "Window": QColor("#ffffff"),
    "WindowText": QColor("#1f1f1f"),
    "Base": QColor("#ffffff"),
    "AlternateBase": QColor("#e1e1e1"),
    "ToolTipBase": QColor("#ffffff"),
    "ToolTipText": QColor("#1f1f1f"),
    "Text": QColor("#1f1f1f"),
    "Button": QColor("#e1e1e1"),
    "ButtonText": QColor("#1f1f1f"),
    "BrightText": QColor("#ff0000"),
    "Highlight": QColor("#0078D4"),
    "HighlightedText": QColor("#ffffff"),
    "accent": QColor("#0078D4"),
    "button.default.background": QColor("#ffffff"),
    "button.default.background.hover": QColor("#f8f8f8"),
    "button.default.background.pressed": QColor("#e9e9e9"),
    "button.default.border": QColor("#1E000000"),
    "button.default.bottom.edge": QColor("#32000000"),
    "button.delete.background": QColor("#26D93025"),
    "button.delete.background.hover": QColor("#4CD93025"),
    "button.delete.background.pressed": QColor("#4CD93025"),
    "button.delete.border": QColor("#66D93025"),
    "button.primary.background": QColor("#ffffff"),
    "button.primary.background.hover": QColor("#f8f8f8"),
    "button.primary.background.pressed": QColor("#e9e9e9"),
    "button.primary.border": QColor("#1E000000"),
    "button.primary.bottom.edge": QColor("#32000000"),
    "button.primary.text": QColor("#000000"),
    "input.border.thin": QColor("#2D000000"),
    "dialog.background": QColor("#ffffff"),
    "dialog.text": QColor("#1f1f1f"),
    "dialog.border": QColor("#c0c0c0"),
    "dialog.input.background": QColor("#ffffff"),
    "dialog.button.background": QColor("#e1e1e1"),
    "dialog.button.hover": QColor("#d8d8d8"),
    "dialog.button.ok.background": QColor("#0078D4"),
    "calendar.disabled.background": QColor("#fbe5e5"),

    "calendar.weekend.background": QColor("#f0f8ff"),

    "switch.track.off.border": QColor("#6E000000"),
    "switch.knob.off": QColor("#646464"),
    "switch.knob.on": QColor("#ffffff"),
    "switch.knob.border": QColor("#23000000"),
    "switch.text": QColor("#1f1f1f"),

    "help.nav.background": QColor("#f0f0f0"),
    "help.nav.border": QColor("#e0e0e0"),
    "help.nav.hover": QColor("#e8e8e8"),
    "help.nav.selected": QColor("#0078D4"),
    "help.nav.selected.text": QColor("#ffffff"),
}

DARK_THEME_PALETTE = {
    "Window": QColor("#2b2b2b"),
    "WindowText": QColor("#ffffff"),
    "Base": QColor("#3c3c3c"),
    "AlternateBase": QColor("#313131"),
    "ToolTipBase": QColor("#3c3c3c"),
    "ToolTipText": QColor("#ffffff"),
    "Text": QColor("#ffffff"),
    "Button": QColor("#3c3c3c"),
    "ButtonText": QColor("#ffffff"),
    "BrightText": QColor("#ff0000"),
    "Highlight": QColor("#0096FF"),
    "HighlightedText": QColor("#ffffff"),
    "accent": QColor("#0096FF"),
    "button.default.background": QColor("#3c3c3c"),
    "button.default.background.hover": QColor("#4a4a4a"),
    "button.default.background.pressed": QColor("#555555"),
    "button.default.border": QColor("#26FFFFFF"),
    "button.default.bottom.edge": QColor("#1EFFFFFF"),
    "button.delete.background": QColor("#33D93025"),
    "button.delete.background.hover": QColor("#66D93025"),
    "button.delete.background.pressed": QColor("#66D93025"),
    "button.delete.border": QColor("#80D93025"),
    "button.primary.background": QColor("#3c3c3c"),
    "button.primary.background.hover": QColor("#4a4a4a"),
    "button.primary.background.pressed": QColor("#555555"),
    "button.primary.border": QColor("#26FFFFFF"),
    "button.primary.bottom.edge": QColor("#1EFFFFFF"),
    "button.primary.text": QColor("#dfdfdf"),
    "input.border.thin": QColor("#3CFFFFFF"),
    "dialog.background": QColor("#2b2b2b"),
    "dialog.text": QColor("#ffffff"),
    "dialog.border": QColor("#888888"),
    "dialog.input.background": QColor("#3c3c3c"),
    "dialog.button.background": QColor("#3c3c3c"),
    "dialog.button.hover": QColor("#4f4f4f"),
    "dialog.button.ok.background": QColor("#0096FF"),
    "calendar.disabled.background": QColor("#5a3e3e"),

    "calendar.weekend.background": QColor("#353535"),

    "switch.track.off.border": QColor("#78FFFFFF"),
    "switch.knob.off": QColor("#B4B4B4"),
    "switch.knob.on": QColor("#ffffff"),
    "switch.knob.border": QColor("#5A000000"),
    "switch.text": QColor("#ffffff"),

    "help.nav.background": QColor("#313131"),
    "help.nav.border": QColor("#444"),
    "help.nav.hover": QColor("#404040"),
    "help.nav.selected": QColor("#0096FF"),
    "help.nav.selected.text": QColor("#ffffff"),
}

class ThemeManager(QObject):
    _instance = None
    theme_changed = pyqtSignal()

    @classmethod
    def get_instance(cls):
        if cls._instance is None:
            cls._instance = ThemeManager()
        return cls._instance

    def __init__(self):
        if ThemeManager._instance is not None:
            raise RuntimeError("ThemeManager is a singleton, use get_instance()")
        super().__init__()
        self._current_theme = None
        self._qss_template = ""
        self._load_qss_template()

    def _load_qss_template(self):
        from utils.paths import resource_path

        try:
            qss_path = resource_path("resources/styles/base.qss")
            if os.path.exists(qss_path):
                with open(qss_path, "r", encoding="utf-8") as f:
                    self._qss_template = f.read()
            else:
                self._qss_template = ""
        except Exception as e:
            self._qss_template = ""

    def set_theme(self, theme_name: str, app=None):
        from PyQt6.QtCore import Qt
        from PyQt6.QtGui import QGuiApplication

        app_instance = app or QApplication.instance()

        effective_theme = theme_name
        if effective_theme == "auto":
            try:
                style_hints = QGuiApplication.styleHints()
                color_scheme = style_hints.colorScheme()
                effective_theme = (
                    "dark" if color_scheme == Qt.ColorScheme.Dark else "light"
                )
            except Exception as e:
                effective_theme = "light"

        new_theme = "dark" if effective_theme == "dark" else "light"

        if self._current_theme != new_theme:
            self._current_theme = new_theme
            if app_instance:
                self.apply_theme_to_app(app_instance)
            self.theme_changed.emit()
        elif not app_instance.styleSheet():
            self.apply_theme_to_app(app_instance)

    def apply_theme_to_app(self, app):
        """Applies theme to application."""

        palette_source = DARK_THEME_PALETTE if self.is_dark() else LIGHT_THEME_PALETTE
        palette_data = copy.deepcopy(palette_source)

        q_palette = QPalette()
        color_roles = {
            "Window": QPalette.ColorRole.Window,
            "WindowText": QPalette.ColorRole.WindowText,
            "Base": QPalette.ColorRole.Base,
            "AlternateBase": QPalette.ColorRole.AlternateBase,
            "ToolTipBase": QPalette.ColorRole.ToolTipBase,
            "ToolTipText": QPalette.ColorRole.ToolTipText,
            "Text": QPalette.ColorRole.Text,
            "Button": QPalette.ColorRole.Button,
            "ButtonText": QPalette.ColorRole.ButtonText,
            "BrightText": QPalette.ColorRole.BrightText,
            "Highlight": QPalette.ColorRole.Highlight,
            "HighlightedText": QPalette.ColorRole.HighlightedText,
        }

        for name, role in color_roles.items():
            if name in palette_data:

                color = QColor(palette_data[name])
                q_palette.setColor(role, color)

        app.setPalette(q_palette)

        processed_palette = {
            key: QColor(value) if isinstance(value, QColor) else value
            for key, value in palette_data.items()
        }

        if "accent" in processed_palette:
            accent_color = QColor(processed_palette["accent"])
            hover_color = (
                accent_color.lighter(115)
                if self.is_dark()
                else accent_color.darker(115)
            )
            processed_palette["accent.hover"] = hover_color

        current_qss = self._qss_template

        sorted_keys = sorted(processed_palette.keys(), key=len, reverse=True)

        for key in sorted_keys:
            color = processed_palette.get(key)
            if isinstance(color, QColor):
                placeholder = f"@{key}"
                if placeholder in current_qss:
                    color_hex = color.name(QColor.NameFormat.HexArgb)
                    current_qss = current_qss.replace(placeholder, color_hex)

        app.setStyleSheet(current_qss)

    def is_dark(self) -> bool:
        return self._current_theme == "dark"

    def apply_theme_to_dialog(self, dialog):

        dialog.style().unpolish(dialog)

        dialog.style().polish(dialog)

        dialog.updateGeometry()
        dialog.update()

    def get_color(self, key: str) -> QColor:
        palette = DARK_THEME_PALETTE if self.is_dark() else LIGHT_THEME_PALETTE

        color = QColor(palette.get(key, QColor("magenta")))
        return color


--- Файл: ./src/ui/dialogs/__init__.py ---
from ui.dialogs.analysis import AnalysisDialog
from ui.dialogs.calendar import CalendarDialog
from ui.dialogs.export_dialog import ExportDialog
from ui.dialogs.installation_manager_dialog import InstallationManagerDialog
from ui.dialogs.settings_dialog import SettingsDialog
from ui.dialogs.help_dialog import HelpDialog

__all__ = [
    "AnalysisDialog",
    "CalendarDialog",
    "ExportDialog",
    "InstallationManagerDialog",
    "SettingsDialog",
    "HelpDialog",
]


--- Файл: ./src/ui/dialogs/analysis/__init__.py ---
"""Analysis dialog module."""

from ui.dialogs.analysis.analysis_dialog import AnalysisDialog

__all__ = ["AnalysisDialog"]


--- Файл: ./src/ui/dialogs/analysis/analysis_dialog.py ---


import logging
import math
from typing import Optional, Set, Tuple

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.colors import to_rgb
from matplotlib.patches import Wedge
from PyQt6.QtCore import QPoint, Qt, QTimer, pyqtSignal, QRectF
from PyQt6.QtGui import QShowEvent, QResizeEvent
from PyQt6.QtWidgets import (
    QDialog,
    QLabel,
    QSizePolicy,
    QVBoxLayout,
    QWidget,
)
from datetime import datetime

from core.analysis.tree_analyzer import TreeNode, aggregate_children_for_view
from core.application.chart_service import ChartService
from core.view_models import SunburstSegment
from resources.translations import tr
from ui.dialogs.dialog_builder import auto_size_dialog, setup_dialog_scaffold, setup_dialog_icon
from ui.theme import ThemeManager
from ui.widgets.atomic.loading_spinner import LoadingSpinner

logger = logging.getLogger(__name__)

CENTER_HOLE_PROPORTION = 0.30
RING_WIDTH_PROPORTION = 0.22
MAX_DEPTH = 3
RESIZE_DEBOUNCE_MS = 30

class AnalysisDialog(QDialog):
    filter_accepted = pyqtSignal(set)

    def __init__(self, presenter, theme_manager: ThemeManager, parent=None):
        super().__init__(parent)
        self.presenter = presenter
        self.root_node: Optional[TreeNode] = None
        self.current_root: Optional[TreeNode] = None
        self.unit = "chars"
        self.disabled_nodes: Set[TreeNode] = set()
        self.theme_manager = theme_manager
        self._needs_plot_after_show = False
        self.chart_service = ChartService()
        self.segments: list[SunburstSegment] = []
        self.last_hovered_segment: Optional[SunburstSegment] = None
        self.center_text_artist = None

        self.setWindowTitle(tr("Token Analysis by Date"))
        setup_dialog_icon(self)
        self.setMinimumSize(600, 650)
        self.setWindowFlags(self.windowFlags() | Qt.WindowType.WindowMinMaxButtonsHint)

        self._setup_ui()
        self._connect_signals()

    def load_data_and_show(self, root_node: TreeNode, initial_disabled_nodes: set, unit: str):
        self.root_node = root_node
        self.current_root = root_node
        self.disabled_nodes = initial_disabled_nodes.copy()
        self.unit = unit
        self.spinner.stop()
        self.loading_widget.hide()
        self.canvas.show()
        self.ok_button.setEnabled(True)
        self._needs_plot_after_show = True
        self.show()

    def showEvent(self, event: QShowEvent):
        super().showEvent(event)
        if self._needs_plot_after_show:
            QTimer.singleShot(50, self.plot)
            self._needs_plot_after_show = False

    def resizeEvent(self, event: QResizeEvent):
        super().resizeEvent(event)
        self.resize_timer.start(RESIZE_DEBOUNCE_MS)

    def plot(self):
        if not self.current_root or not self.isVisible() or self.canvas.width() <= 1:
            return

        self.ax.clear()
        self.ax.axis("off")

        canvas_width = self.canvas.width()
        canvas_height = self.canvas.height()
        center_x, center_y = canvas_width / 2, canvas_height / 2
        working_radius = min(canvas_width, canvas_height) * 0.45

        self.ax.set_xlim(0, canvas_width)
        self.ax.set_ylim(0, canvas_height)

        self.segments.clear()
        self.last_hovered_segment = None

        force_first_level_full_detail = (self.current_root != self.root_node)

        self._draw_level_recursive(
            node=self.current_root,
            start_angle=0,
            end_angle=360,
            relative_depth=1,
            force_full_detail=force_first_level_full_detail,
            center_x=center_x,
            center_y=center_y,
            working_radius=working_radius
        )

        self.draw_center_text(center_x, center_y, working_radius)
        self.canvas.draw()

    def _draw_level_recursive(self, node: TreeNode, start_angle: float, end_angle: float, relative_depth: int, force_full_detail: bool, center_x: float, center_y: float, working_radius: float):
        if relative_depth > MAX_DEPTH:
            return

        children_to_display = aggregate_children_for_view(node, force_full_detail=force_full_detail)
        total_value = node.value
        if total_value <= 0:
            return

        current_angle = start_angle

        for child in children_to_display:
            sweep_angle = (child.value / total_value) * (end_angle - start_angle)

            outer_radius_px = working_radius * (CENTER_HOLE_PROPORTION + relative_depth * RING_WIDTH_PROPORTION)
            ring_width_px = working_radius * RING_WIDTH_PROPORTION

            mid_angle_deg = current_angle + sweep_angle / 2.0
            child_absolute_depth = self.chart_service.get_node_absolute_depth(child)
            color = self.chart_service.get_color_for_segment(mid_angle_deg, child_absolute_depth - 1)
            is_disabled = self.chart_service.is_effectively_disabled(child, self.disabled_nodes)
            effective_color = self.chart_service.darken_color(color) if is_disabled else color

            wedge = Wedge(
                center=(center_x, center_y), r=outer_radius_px, theta1=current_angle,
                theta2=current_angle + sweep_angle, width=ring_width_px,
                facecolor=effective_color, edgecolor=self.bg_color, linewidth=1.2,
            )
            self.ax.add_patch(wedge)

            segment = SunburstSegment(
                inner_radius=outer_radius_px - ring_width_px,
                outer_radius=outer_radius_px,
                start_angle=math.radians(current_angle),
                end_angle=math.radians(current_angle + sweep_angle),
                color=effective_color, node=child, text=child.name, is_disabled=is_disabled
            )
            segment.artist = wedge
            self.segments.append(segment)

            self._update_segment_text(segment, center_x, center_y)

            if getattr(child, 'date_level', None) != 'others' and (child.children or (hasattr(child, 'aggregated_children') and child.aggregated_children)):
                self._draw_level_recursive(
                    child, current_angle, current_angle + sweep_angle,
                    relative_depth + 1, False, center_x, center_y, working_radius
                )

            current_angle += sweep_angle

    def on_click(self, event):
        if event.inaxes != self.ax or event.xdata is None: return

        center_x, center_y = self.canvas.width() / 2, self.canvas.height() / 2
        r = np.sqrt((event.xdata - center_x)**2 + (event.ydata - center_y)**2)
        working_radius = min(self.canvas.width(), self.canvas.height()) * 0.45

        if r < working_radius * CENTER_HOLE_PROPORTION and self.current_root and self.current_root.parent:
            self.current_root = self.current_root.parent
            self.plot()
            return

        clicked_segment = self._find_segment_at_event(event)
        if not clicked_segment: return

        clicked_node = clicked_segment.node

        if event.button == 3:
            day_nodes = self.chart_service.get_descendant_day_nodes(clicked_node)
            if not day_nodes: return

            is_currently_disabled = self.chart_service.is_effectively_disabled(clicked_node, self.disabled_nodes)
            if is_currently_disabled:
                self.disabled_nodes.difference_update(day_nodes)
            else:
                self.disabled_nodes.update(day_nodes)
            self.plot()
            return

        if event.button == 1:
            is_zoomable = bool(clicked_node.children) or (hasattr(clicked_node, "aggregated_children") and clicked_node.aggregated_children)
            if is_zoomable:
                self.current_root = clicked_node
                self.plot()

    def on_motion(self, event):
        if event.xdata is None or event.ydata is None:
            if self.last_hovered_segment is not None:
                self.last_hovered_segment.artist.set_alpha(1.0)
                self.last_hovered_segment = None
                self.tooltip_widget.hide()
                self.canvas.draw_idle()
            return

        hover_segment = self._find_segment_at_event(event)
        if hover_segment != self.last_hovered_segment:
            if self.last_hovered_segment and hasattr(self.last_hovered_segment, 'artist'):
                self.last_hovered_segment.artist.set_alpha(1.0)
            if hover_segment and hasattr(hover_segment, 'artist'):
                hover_segment.artist.set_alpha(0.7)
            self.last_hovered_segment = hover_segment
            self.canvas.draw_idle()

        if hover_segment:
            node = hover_segment.node
            unit_str = tr('tokens') if self.unit == 'tokens' else tr('Characters')
            tooltip_text = f"<b>{self._get_translated_node_name(node)}</b><br>{unit_str}: {node.value:,.0f}"
            self.tooltip_widget.setText(tooltip_text)
            self.tooltip_widget.adjustSize()
            if event.guiEvent:
                self.tooltip_widget.move(self.canvas.mapToGlobal(event.guiEvent.pos()) + QPoint(15, 10))
            self.tooltip_widget.show()
        else:
            self.tooltip_widget.hide()

    def accept(self):
        self.filter_accepted.emit(self.disabled_nodes)
        super().accept()

    def on_external_update(self, new_disabled_set: set):
        if self.disabled_nodes != new_disabled_set:
            self.disabled_nodes = new_disabled_set.copy()
            if self.root_node and self.isVisible():
                self.plot()

    def retranslate_ui(self):
        self.setWindowTitle(tr("Token Analysis by Date"))
        self.progress_label.setText(tr("Rendering chart..."))
        self.ok_button.setText(tr("Save"))
        self.ok_button.setToolTip(tr("Save filter settings for export"))
        self.cancel_button.setText(tr("Close"))
        if self.root_node and self.isVisible(): self.plot()

    def _setup_ui(self):

        layout = QVBoxLayout(self)
        self.loading_widget = QWidget(self)
        loading_layout = QVBoxLayout(self.loading_widget)
        self.spinner = LoadingSpinner(self)
        self.progress_label = QLabel(tr("Analyzing..."), self)
        self.progress_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        loading_layout.addStretch()
        loading_layout.addWidget(self.spinner, 0, Qt.AlignmentFlag.AlignCenter)
        loading_layout.addWidget(self.progress_label)
        loading_layout.addStretch()
        self.bg_color = self.theme_manager.get_color("dialog.background").name()
        self.text_color = self.theme_manager.get_color("dialog.text").name()
        self.figure = plt.figure()
        self.figure.patch.set_facecolor(self.bg_color)
        self.canvas = FigureCanvas(self.figure)
        self.canvas.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.canvas.setMinimumSize(0, 0)
        self.canvas.hide()
        self.ax = self.figure.add_axes([0, 0, 1, 1], frameon=False)
        self.ax.set_aspect('equal', anchor='C')
        self.ax.format_coord = lambda x, y: ""
        self.ax.axis("off")
        layout.addWidget(self.loading_widget)
        layout.addWidget(self.canvas)
        setup_dialog_scaffold(self, layout, ok_text=tr("Save"))
        self.ok_button.setToolTip(tr("Save filter settings for export"))
        self.cancel_button.setText(tr("Close"))
        self.ok_button.setEnabled(False)
        auto_size_dialog(self, min_width=600, min_height=650)
        self.tooltip_widget = QLabel(self, Qt.WindowType.ToolTip)
        self.tooltip_widget.setAttribute(Qt.WidgetAttribute.WA_StyledBackground, True)
        self.spinner.start()

    def _connect_signals(self):
        self.resize_timer = QTimer(self)
        self.resize_timer.setSingleShot(True)
        self.resize_timer.timeout.connect(self.plot)
        self.canvas.mpl_connect("motion_notify_event", self.on_motion)
        self.canvas.mpl_connect("button_press_event", self.on_click)
        self.canvas.mpl_connect("figure_leave_event", self.on_figure_leave)

    def draw_center_text(self, center_x: float, center_y: float, working_radius: float):
        if not self.ax or not self.isVisible() or not self.current_root:
            return

        if self.current_root.name == "Total":
            label = tr(self.unit.capitalize())
        elif self.current_root.parent is not None:
            parent_label = self._get_translated_node_name(self.current_root.parent)
            current_label = self._get_translated_node_name(self.current_root)
            label = f"{parent_label}\n{current_label}"
        else:
            label = self._get_translated_node_name(self.current_root)

        display_value = self.chart_service.calculate_filtered_value(self.current_root, self.disabled_nodes)
        value_str = f"{display_value:,.0f}"

        base_font_size = max(8, min(18, int(working_radius / 16)))
        if "\n" in label:
            base_font_size *= 0.85

        y_pos_main = center_y + base_font_size * 0.7
        main_text = f"{label}\n{value_str}"
        self.ax.text(
            center_x, y_pos_main, main_text,
            ha='center', va='center',
            fontsize=int(base_font_size),
            color=self.theme_manager.get_color("dialog.text").name(),
            wrap=True,
            linespacing=1.3
        )

        if self.current_root.parent:
            hint_font_size = int(base_font_size * 0.65)

            y_pos_hint = center_y - working_radius * CENTER_HOLE_PROPORTION * 0.5
            self.ax.text(
                center_x, y_pos_hint, tr("click to go up"),
                ha='center', va='center',
                fontsize=hint_font_size,
                color=self.theme_manager.get_color("dialog.text").name(),
                alpha=0.6
            )

    def _update_segment_text(self, segment: SunburstSegment, center_x: float, center_y: float):
        text_label = self._get_translated_node_name(segment.node)
        font_size = self._calculate_font_size(segment)

        if font_size == 0: return

        center_radius_px = segment.inner_radius + (segment.outer_radius - segment.inner_radius) / 2.0
        center_angle_rad = segment.start_angle + (segment.end_angle - segment.start_angle) / 2.0
        x = center_x + center_radius_px * np.cos(center_angle_rad)
        y = center_y + center_radius_px * np.sin(center_angle_rad)
        rotation_angle_deg = np.rad2deg(center_angle_rad)
        if 90 < rotation_angle_deg < 270: rotation_angle_deg -= 180

        text_color_name = 'white'
        self.ax.text(x, y, text_label, fontsize=font_size, color=text_color_name,
                     rotation=rotation_angle_deg, ha='center', va='center')

    def _calculate_font_size(self, segment: SunburstSegment) -> int:
        arc_length_px = (segment.end_angle - segment.start_angle) * segment.outer_radius

        if arc_length_px > 50: return 9
        if arc_length_px > 35: return 8
        if arc_length_px > 25: return 7
        return 0

    def _find_segment_at_event(self, event) -> Optional[SunburstSegment]:
        center_x, center_y = self.canvas.width() / 2, self.canvas.height() / 2
        x, y = event.xdata, event.ydata

        radius = math.sqrt((x - center_x)**2 + (y - center_y)**2)
        angle = math.atan2(y - center_y, x - center_x)
        if angle < 0:
            angle += 2 * math.pi

        for segment in reversed(self.segments):
            if segment.inner_radius <= radius <= segment.outer_radius and \
               segment.start_angle <= angle <= segment.end_angle:
                return segment
        return None

    def on_figure_leave(self, event):
        if self.last_hovered_segment:
            self.last_hovered_segment.artist.set_alpha(1.0)
            self.last_hovered_segment = None
            self.tooltip_widget.hide()
            self.canvas.draw_idle()

    def _get_translated_node_name(self, node: TreeNode) -> str:
        if not node: return ""
        name = node.name
        date_level = getattr(node, "date_level", None)

        if date_level == "month" and name.isdigit():
            try:
                month_num = int(name)
                month_key = f"month_{month_num}"
                translated = tr(month_key)
                return translated if translated != month_key else datetime(2000, month_num, 1).strftime("%B")
            except (ValueError, IndexError):
                pass
        elif name == "Total":
            return tr("Total")
        return name


--- Файл: ./src/ui/dialogs/analysis/services/chart_interaction_service.py ---
"""
Service for handling sunburst chart interactions.

Responsible for handling clicks, hovers, tooltips and selection state.
"""

from typing import Callable, Optional, Set
from datetime import datetime

from PyQt6.QtCore import QObject, pyqtSignal

from core.analysis.tree_analyzer import TreeNode
from resources.translations import tr

from ui.dialogs.analysis.services.chart_calculation_service import SunburstSegment

class ChartInteractionService(QObject):
    """Service for handling chart interactions."""

    hover_changed = pyqtSignal(object)
    segment_clicked = pyqtSignal(object)
    tooltip_changed = pyqtSignal(str, int, int)
    cursor_changed = pyqtSignal(str)
    selection_changed = pyqtSignal(set)

    def __init__(self):
        super().__init__()

        self._hovered_segment: Optional[SunburstSegment] = None
        self._disabled_nodes: Set[TreeNode] = set()
        self._segments: list = []

        self._show_tooltips = True
        self._allow_selection = True

    def set_segments(self, segments: list):
        """Sets current segments."""
        self._segments = segments

    def set_disabled_nodes(self, disabled_nodes: Set[TreeNode]):
        """Sets disabled nodes."""
        old_disabled = self._disabled_nodes.copy()
        self._disabled_nodes = disabled_nodes.copy()

        if old_disabled != self._disabled_nodes:
            self.selection_changed.emit(self._disabled_nodes)

    def get_disabled_nodes(self) -> Set[TreeNode]:
        """Returns disabled nodes."""
        return self._disabled_nodes.copy()

    def handle_mouse_move(
        self,
        x: float,
        y: float,
        center_x: float,
        center_y: float,
        find_segment_func: Callable,
    ):
        """Handles mouse movement."""

        segment = find_segment_func(self._segments, x, y, center_x, center_y)

        if segment != self._hovered_segment:
            self._hovered_segment = segment
            self.hover_changed.emit(segment)

            if segment:

                if self._show_tooltips:
                    tooltip_text = self._generate_tooltip_text(segment)
                    self.tooltip_changed.emit(tooltip_text, int(x), int(y))

                self.cursor_changed.emit("pointer")
            else:

                self.tooltip_changed.emit("", 0, 0)
                self.cursor_changed.emit("default")

    def handle_mouse_click(
        self,
        x: float,
        y: float,
        center_x: float,
        center_y: float,
        find_segment_func: Callable,
    ):
        """Handles mouse click."""
        if not self._allow_selection:
            return

        segment = find_segment_func(self._segments, x, y, center_x, center_y)

        if segment:
            self.segment_clicked.emit(segment)
            self._toggle_node_disabled(segment.node)

    def handle_mouse_leave(self):
        """Handles mouse leaving chart area."""
        if self._hovered_segment:
            self._hovered_segment = None
            self.hover_changed.emit(None)
            self.tooltip_changed.emit("", 0, 0)
            self.cursor_changed.emit("default")

    def _toggle_node_disabled(self, node: TreeNode):
        """Toggles node disabled state."""
        if node in self._disabled_nodes:
            self._disabled_nodes.remove(node)
        else:
            self._disabled_nodes.add(node)

        self.selection_changed.emit(self._disabled_nodes)

    def _get_translated_node_name(self, node: TreeNode) -> str:
        """Returns translated node name for display."""
        if not node:
            return ""

        name = node.name

        if tr(" others") in name:
            return name

        if name == "Total":
            return tr("Total")

        if getattr(node, "date_level", None) == "month" and name.isdigit():
            try:
                month_num = int(name)
                month_key = f"month_gen_{month_num}"
                translated = tr(month_key)

                if translated == month_key:
                    return datetime(2000, month_num, 1).strftime("%B")
                return translated
            except ValueError:
                pass

        is_month = False
        if node.parent and node.parent.name.isdigit() and len(node.parent.name) == 4:
            is_month = True
        elif name.isdigit() and len(name) == 2 and 1 <= int(name) <= 12:
            is_month = True
        if is_month and name.isdigit():
            try:
                month_num = int(name)
                month_key = f"month_gen_{month_num}"
                translated = tr(month_key)
                if translated == month_key:
                    return datetime(2000, month_num, 1).strftime("%B")
                return translated
            except ValueError:
                pass

        return name

    def _generate_tooltip_text(self, segment: SunburstSegment) -> str:
        """Generates tooltip text."""
        node = segment.node

        unit = "characters"
        translated_name = self._get_translated_node_name(node)

        tooltip_lines = [f"<b>{translated_name}</b>", f"Value: {node.value:,.0f} {unit}"]

        if segment.level == 0:
            tooltip_lines.append(f"Year: {translated_name}")
        elif segment.level == 1:
            tooltip_lines.append(f"Month: {translated_name}")
        elif segment.level == 2:
            tooltip_lines.append(f"Day: {translated_name}")

        if node in self._disabled_nodes:
            tooltip_lines.append("<font color='red'>❌ Disabled for export</font>")
        else:
            tooltip_lines.append("<font color='green'>✅ Enabled for export</font>")

        return "<br/>".join(tooltip_lines)

    def disable_all_nodes(self):
        """Disables all nodes."""
        all_nodes = set()
        for segment in self._segments:
            all_nodes.add(segment.node)

        self._disabled_nodes = all_nodes
        self.selection_changed.emit(self._disabled_nodes)

    def enable_all_nodes(self):
        """Enables all nodes."""
        self._disabled_nodes.clear()
        self.selection_changed.emit(self._disabled_nodes)

    def disable_nodes_by_level(self, level: int):
        """Disables all nodes of specific level."""
        nodes_to_disable = set()
        for segment in self._segments:
            if segment.level == level:
                nodes_to_disable.add(segment.node)

        self._disabled_nodes.update(nodes_to_disable)
        self.selection_changed.emit(self._disabled_nodes)

    def enable_nodes_by_level(self, level: int):
        """Enables all nodes of specific level."""
        nodes_to_enable = set()
        for segment in self._segments:
            if segment.level == level:
                nodes_to_enable.add(segment.node)

        self._disabled_nodes -= nodes_to_enable
        self.selection_changed.emit(self._disabled_nodes)

    def get_statistics(self) -> dict:
        """Returns chart statistics."""
        total_segments = len(self._segments)
        disabled_segments = len(
            [s for s in self._segments if s.node in self._disabled_nodes]
        )
        enabled_segments = total_segments - disabled_segments

        total_value = sum(s.node.value for s in self._segments)
        disabled_value = sum(
            s.node.value for s in self._segments if s.node in self._disabled_nodes
        )
        enabled_value = total_value - disabled_value

        return {
            "total_segments": total_segments,
            "enabled_segments": enabled_segments,
            "disabled_segments": disabled_segments,
            "total_value": total_value,
            "enabled_value": enabled_value,
            "disabled_value": disabled_value,
            "enabled_percentage": (
                (enabled_value / total_value * 100) if total_value > 0 else 0
            ),
        }


--- Файл: ./src/ui/dialogs/analysis/services/__init__.py ---
"""Services for analysis dialog."""

from ui.dialogs.analysis.services.chart_calculation_service import ChartCalculationService
from ui.dialogs.analysis.services.chart_interaction_service import ChartInteractionService
from ui.dialogs.analysis.services.chart_rendering_service import ChartRenderingService

__all__ = [
    "ChartCalculationService",
    "ChartRenderingService",
    "ChartInteractionService",
]


--- Файл: ./src/ui/dialogs/analysis/services/chart_calculation_service.py ---
"""
Service for sunburst chart calculations.

Responsible for mathematical calculations, geometry and positioning.
"""

import math
from dataclasses import dataclass
from typing import List, Optional, Set, Tuple
from datetime import datetime

from core.analysis.tree_analyzer import TreeNode
from resources.translations import tr

@dataclass
class SunburstSegment:
    """Sunburst chart segment."""

    inner_radius: float
    outer_radius: float
    start_angle: float
    end_angle: float
    color: str
    node: TreeNode
    text: str
    level: int

class ChartCalculationService:
    """Service for sunburst chart calculations."""

    def __init__(self):

        self.CENTER_HOLE_RADIUS = 0.35
        self.RING_WIDTH = 0.25
        self.MAX_DEPTH = 3

        self.YEAR_SATURATION = 0.8
        self.MONTH_SATURATION = 0.7
        self.DAY_SATURATION = 0.55

        self.YEAR_BRIGHTNESS = 0.9
        self.MONTH_BRIGHTNESS = 0.8
        self.DAY_BRIGHTNESS = 0.7

    def calculate_segments(
        self,
        root_node: TreeNode,
        disabled_nodes: Set[TreeNode],
        canvas_size: Tuple[int, int],
    ) -> List[SunburstSegment]:
        """
        Calculates sunburst chart segments.

        Args:
            root_node: Root tree node
            disabled_nodes: Disabled nodes
            canvas_size: Canvas size (width, height)

        Returns:
            List of segments for rendering
        """
        if not root_node or not root_node.children:
            return []

        segments = []
        canvas_width, canvas_height = canvas_size
        center_x = canvas_width / 2
        center_y = canvas_height / 2

        max_radius = min(center_x, center_y) * 0.9

        self._calculate_level_segments(
            root_node.children,
            disabled_nodes,
            segments,
            level=0,
            start_angle=0,
            end_angle=2 * math.pi,
            max_radius=max_radius,
        )

        return segments

    def _get_translated_node_name(self, node: TreeNode) -> str:
        """Returns translated node name for display."""
        if not node:
            return ""

        name = node.name

        if tr(" others") in name:
            return name

        if name == "Total":
            return tr("Total")

        if getattr(node, "date_level", None) == "month" and name.isdigit():
            try:
                month_num = int(name)
                month_key = f"month_gen_{month_num}"
                translated = tr(month_key)

                if translated == month_key:
                    return datetime(2000, month_num, 1).strftime("%B")
                return translated
            except ValueError:
                pass

        is_month = False
        if node.parent and node.parent.name.isdigit() and len(node.parent.name) == 4:
            is_month = True
        elif name.isdigit() and len(name) == 2 and 1 <= int(name) <= 12:
            is_month = True
        if is_month and name.isdigit():
            try:
                month_num = int(name)
                month_key = f"month_gen_{month_num}"
                translated = tr(month_key)
                if translated == month_key:
                    return datetime(2000, month_num, 1).strftime("%B")
                return translated
            except ValueError:
                pass

        return name

    def _calculate_level_segments(
        self,
        nodes: List[TreeNode],
        disabled_nodes: Set[TreeNode],
        segments: List[SunburstSegment],
        level: int,
        start_angle: float,
        end_angle: float,
        max_radius: float,
    ):
        """Recursively calculates segments for level."""
        if level >= self.MAX_DEPTH:
            return

        inner_radius = self.CENTER_HOLE_RADIUS + level * self.RING_WIDTH
        outer_radius = inner_radius + self.RING_WIDTH

        inner_radius *= max_radius
        outer_radius *= max_radius

        total_value = sum(node.value for node in nodes if node not in disabled_nodes)

        if total_value == 0:
            return

        current_angle = start_angle
        angle_range = end_angle - start_angle

        for node in nodes:
            if node in disabled_nodes:
                continue

            node_angle = (node.value / total_value) * angle_range
            segment_end_angle = current_angle + node_angle

            color = self._calculate_color(node, level)
            translated_name = self._get_translated_node_name(node)
            segment = SunburstSegment(
                inner_radius=inner_radius,
                outer_radius=outer_radius,
                start_angle=current_angle,
                end_angle=segment_end_angle,
                color=color,
                node=node,
                text=translated_name,
                level=level,
            )
            segments.append(segment)

            children_to_process = []
            if node.children:
                children_to_process.extend(node.children)
            if hasattr(node, "aggregated_children") and node.aggregated_children:
                children_to_process.extend(node.aggregated_children)

            if children_to_process and level < self.MAX_DEPTH - 1:
                self._calculate_level_segments(
                    children_to_process,
                    disabled_nodes,
                    segments,
                    level + 1,
                    current_angle,
                    segment_end_angle,
                    max_radius,
                )

            current_angle = segment_end_angle

    def _calculate_color(self, node: TreeNode, level: int) -> str:
        """Calculates segment color."""

        if level == 0:
            saturation = self.YEAR_SATURATION
            brightness = self.YEAR_BRIGHTNESS
        elif level == 1:
            saturation = self.MONTH_SATURATION
            brightness = self.MONTH_BRIGHTNESS
        else:
            saturation = self.DAY_SATURATION
            brightness = self.DAY_BRIGHTNESS

        name_hash = hash(node.name) % 360
        hue = name_hash / 360.0

        return self._hsv_to_hex(hue, saturation, brightness)

    def _hsv_to_hex(self, h: float, s: float, v: float) -> str:
        """Converts HSV to HEX."""
        import colorsys

        r, g, b = colorsys.hsv_to_rgb(h, s, v)
        return f"#{int(r*255):02x}{int(g*255):02x}{int(b*255):02x}"

    def calculate_text_position(self, segment: SunburstSegment) -> Tuple[float, float]:
        """Calculates text position for segment."""

        mid_radius = (segment.inner_radius + segment.outer_radius) / 2

        mid_angle = (segment.start_angle + segment.end_angle) / 2

        x = mid_radius * math.cos(mid_angle)
        y = mid_radius * math.sin(mid_angle)

        return x, y

    def find_segment_at_position(
        self,
        segments: List[SunburstSegment],
        x: float,
        y: float,
        center_x: float,
        center_y: float,
    ) -> Optional[SunburstSegment]:
        """Finds segment at specified position."""

        dx = x - center_x
        dy = y - center_y
        radius = math.sqrt(dx * dx + dy * dy)
        angle = math.atan2(dy, dx)

        if angle < 0:
            angle += 2 * math.pi

        for segment in segments:
            if (
                segment.inner_radius <= radius <= segment.outer_radius
                and segment.start_angle <= angle <= segment.end_angle
            ):
                return segment

        return None


--- Файл: ./src/ui/dialogs/analysis/services/chart_rendering_service.py ---
"""
Service for rendering sunburst chart.

Responsible for matplotlib rendering, styles and animations.
"""

import math
from typing import List, Optional

import matplotlib.patches as patches
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas

from ui.dialogs.analysis.services.chart_calculation_service import SunburstSegment

class ChartRenderingService:
    """Service for rendering sunburst chart."""

    def __init__(self):
        self.figure = None
        self.axes = None
        self.canvas = None

        self.HIGHLIGHT_ALPHA = 0.7
        self.DARKEN_FACTOR = 0.4
        self.FONT_SIZE = 14

    def create_canvas(
        self, width: int = 4, height: int = 4, dpi: int = 100
    ) -> FigureCanvas:
        """Creates matplotlib canvas."""
        self.figure, self.axes = plt.subplots(figsize=(width, height), dpi=dpi)
        self.canvas = FigureCanvas(self.figure)

        self.axes.set_aspect("equal")
        self.axes.axis("off")

        from core.theme import ThemeManager
        theme_manager = ThemeManager.get_instance()
        bg_color = theme_manager.get_color("dialog.background")
        self.figure.patch.set_facecolor(bg_color.name())

        return self.canvas

    def render_segments(
        self,
        segments: List[SunburstSegment],
        center_x: float,
        center_y: float,
        hovered_segment: Optional[SunburstSegment] = None,
    ):
        """Renders chart segments."""
        if not self.axes:
            return

        self.axes.clear()
        self.axes.set_aspect("equal")
        self.axes.axis("off")

        max_radius = max((s.outer_radius for s in segments), default=100)
        margin = max_radius * 0.1
        self.axes.set_xlim(-max_radius - margin, max_radius + margin)
        self.axes.set_ylim(-max_radius - margin, max_radius + margin)

        for segment in segments:
            self._render_segment(
                segment, center_x, center_y, hovered_segment == segment
            )

        self._render_center_text(center_x, center_y)

        self.canvas.draw()

    def _render_segment(
        self,
        segment: SunburstSegment,
        center_x: float,
        center_y: float,
        is_hovered: bool = False,
    ):
        """Renders one segment."""

        start_angle_deg = math.degrees(segment.start_angle)
        end_angle_deg = math.degrees(segment.end_angle)
        angle_width = end_angle_deg - start_angle_deg

        color = segment.color
        if is_hovered:
            color = self._darken_color(color)

        wedge = patches.Wedge(
            (center_x, center_y),
            segment.outer_radius,
            start_angle_deg,
            start_angle_deg + angle_width,
            width=segment.outer_radius - segment.inner_radius,
            facecolor=color,
            edgecolor="white",
            linewidth=1,
            alpha=self.HIGHLIGHT_ALPHA if is_hovered else 1.0,
        )

        self.axes.add_patch(wedge)

        if angle_width > 10:
            self._render_segment_text(segment, center_x, center_y)

    def _render_segment_text(
        self, segment: SunburstSegment, center_x: float, center_y: float
    ):
        """Renders segment text."""
        import math

        mid_radius = (segment.inner_radius + segment.outer_radius) / 2
        mid_angle = (segment.start_angle + segment.end_angle) / 2

        text_x = center_x + mid_radius * math.cos(mid_angle)
        text_y = center_y + mid_radius * math.sin(mid_angle)

        font_size = self._calculate_font_size(segment)

        text_angle = math.degrees(mid_angle)
        if text_angle > 90 and text_angle < 270:
            text_angle += 180

        self.axes.text(
            text_x,
            text_y,
            segment.text,
            ha="center",
            va="center",
            fontsize=font_size,
            rotation=text_angle,
            color="white" if self._is_dark_color(segment.color) else "black",
            weight="bold",
        )

    def _render_center_text(self, center_x: float, center_y: float):
        """Renders central text."""
        self.axes.text(
            center_x,
            center_y,
            "Analysis",
            ha="center",
            va="center",
            fontsize=self.FONT_SIZE + 2,
            weight="bold",
            color="black",
        )

    def _calculate_font_size(self, segment: SunburstSegment) -> int:
        """Calculates font size for segment."""
        import math

        angle_size = segment.end_angle - segment.start_angle
        radius_size = segment.outer_radius - segment.inner_radius

        base_size = 8
        size_factor = math.sqrt(angle_size * radius_size) * 2

        return max(6, min(base_size + int(size_factor), 16))

    def _darken_color(self, hex_color: str) -> str:
        """Darkens color for hover effect."""
        if hex_color.startswith("#"):
            hex_color = hex_color[1:]

        r = int(hex_color[0:2], 16)
        g = int(hex_color[2:4], 16)
        b = int(hex_color[4:6], 16)

        r = int(r * (1 - self.DARKEN_FACTOR))
        g = int(g * (1 - self.DARKEN_FACTOR))
        b = int(b * (1 - self.DARKEN_FACTOR))

        return f"#{r:02x}{g:02x}{b:02x}"

    def _is_dark_color(self, hex_color: str) -> bool:
        """Determines if color is dark."""
        if hex_color.startswith("#"):
            hex_color = hex_color[1:]

        r = int(hex_color[0:2], 16)
        g = int(hex_color[2:4], 16)
        b = int(hex_color[4:6], 16)

        brightness = (r * 299 + g * 587 + b * 114) / 1000
        return brightness < 128

    def clear_chart(self):
        """Clears chart."""
        if self.axes:
            self.axes.clear()
            self.axes.set_aspect("equal")
            self.axes.axis("off")

        if self.canvas:
            self.canvas.draw()


--- Файл: ./src/ui/dialogs/settings_dialog.py ---
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QFontDatabase, QMouseEvent
from PyQt6.QtWidgets import (
    QComboBox, QDialog, QHBoxLayout, QLabel, QVBoxLayout, QButtonGroup, QLineEdit, QWidget
)

import logging

from resources.translations import tr
from ui.dialogs.dialog_builder import auto_size_dialog, setup_dialog_scaffold, setup_dialog_icon
from ui.widgets.atomic.fluent_radio import FluentRadioButton
from ui.widgets.atomic.fluent_spinbox import FluentSpinBox
from ui.widgets.atomic.fluent_checkbox import FluentCheckBox
from ui.widgets.atomic.custom_group_widget import CustomGroupBuilder

settings_logger = logging.getLogger("SettingsDialog")

class SettingsDialog(QDialog):

    def __init__(self, current_theme, current_language, parent=None, current_ui_font_mode="builtin", current_ui_font_family="", current_truncate_name_length=20, current_truncate_quote_length=50, current_auto_detect_profile=True, current_auto_recalc=False):
        super().__init__(parent)

        self.setObjectName("SettingsDialog")

        setup_dialog_icon(self)
        self.setWindowFlags(
            Qt.WindowType.Window
            | Qt.WindowType.WindowTitleHint
            | Qt.WindowType.WindowCloseButtonHint
        )
        self.setSizeGripEnabled(True)
        self.setMinimumWidth(350)

        main_layout = QVBoxLayout(self)
        main_layout.setSpacing(15)
        main_layout.setContentsMargins(20, 20, 20, 20)

        lang_layout = QHBoxLayout()
        self.lang_label = QLabel()
        self.combo_lang = QComboBox()

        self.combo_lang.addItem("", "ru")
        self.combo_lang.addItem("", "en")
        lang_index_to_set = self.combo_lang.findData(current_language)
        if lang_index_to_set != -1:
            self.combo_lang.setCurrentIndex(lang_index_to_set)
        lang_layout.addWidget(self.lang_label)
        lang_layout.addWidget(self.combo_lang, 1)
        main_layout.addLayout(lang_layout)

        theme_layout = QHBoxLayout()
        self.theme_label = QLabel()
        self.combo_theme = QComboBox()

        self.combo_theme.addItem("", "auto")
        self.combo_theme.addItem("", "light")
        self.combo_theme.addItem("", "dark")

        theme_index_to_set = self.combo_theme.findData(current_theme)
        if theme_index_to_set != -1:
            self.combo_theme.setCurrentIndex(theme_index_to_set)

        theme_layout.addWidget(self.theme_label)
        theme_layout.addWidget(self.combo_theme, 1)
        main_layout.addLayout(theme_layout)

        font_group, font_layout, self.font_group_title = CustomGroupBuilder.create_styled_group(tr("UI Font"))

        self.radio_font_builtin = FluentRadioButton()
        self.radio_font_system_default = FluentRadioButton()
        self.radio_font_system_custom = FluentRadioButton()

        self._font_mode_group = QButtonGroup(self)
        self._font_mode_group.addButton(self.radio_font_builtin)
        self._font_mode_group.addButton(self.radio_font_system_default)
        self._font_mode_group.addButton(self.radio_font_system_custom)

        font_layout.addWidget(self.radio_font_builtin)
        font_layout.addWidget(self.radio_font_system_default)
        font_layout.addWidget(self.radio_font_system_custom)

        self.combo_font_family = QComboBox()
        families = QFontDatabase.families()

        self.combo_font_family.addItem("", "")
        for family in families:
            self.combo_font_family.addItem(family, family)
        font_layout.addWidget(self.combo_font_family)

        main_layout.addWidget(font_group)

        mode = current_ui_font_mode or "builtin"
        if mode == "system_default" or mode == "system":
            self.radio_font_system_default.setChecked(True)
        elif mode == "system_custom":
            self.radio_font_system_custom.setChecked(True)
        else:
            self.radio_font_builtin.setChecked(True)

        idx_family = self.combo_font_family.findData(current_ui_font_family or "")
        if idx_family != -1:
            self.combo_font_family.setCurrentIndex(idx_family)

        def _sync_font_family_visibility():
            is_custom = self.radio_font_system_custom.isChecked()
            self.combo_font_family.setEnabled(is_custom)
            self.combo_font_family.setVisible(is_custom)

        _sync_font_family_visibility()
        self.radio_font_system_custom.toggled.connect(_sync_font_family_visibility)
        self.radio_font_builtin.toggled.connect(_sync_font_family_visibility)
        self.radio_font_system_default.toggled.connect(_sync_font_family_visibility)

        truncation_group, truncation_layout, self.truncation_group_title = CustomGroupBuilder.create_styled_group(tr("Truncation length"))

        name_length_layout = QHBoxLayout()
        self.label_name_length = QLabel()
        self.spin_name_length = FluentSpinBox()
        self.spin_name_length.setRange(1, 100)
        self.spin_name_length.setValue(current_truncate_name_length)
        name_length_layout.addWidget(self.label_name_length)
        name_length_layout.addStretch()
        name_length_layout.addWidget(self.spin_name_length)
        truncation_layout.addLayout(name_length_layout)

        quote_length_layout = QHBoxLayout()
        self.label_quote_length = QLabel()
        self.spin_quote_length = FluentSpinBox()
        self.spin_quote_length.setRange(1, 200)
        self.spin_quote_length.setValue(current_truncate_quote_length)
        quote_length_layout.addWidget(self.label_quote_length)
        quote_length_layout.addStretch()
        quote_length_layout.addWidget(self.spin_quote_length)
        truncation_layout.addLayout(quote_length_layout)

        main_layout.addWidget(truncation_group)

        self.checkbox_auto_detect_profile = FluentCheckBox()
        self.checkbox_auto_detect_profile.setChecked(current_auto_detect_profile)
        main_layout.addWidget(self.checkbox_auto_detect_profile)

        self.checkbox_auto_recalc = FluentCheckBox()
        self.checkbox_auto_recalc.setChecked(current_auto_recalc)
        main_layout.addWidget(self.checkbox_auto_recalc)

        main_layout.addStretch(1)

        setup_dialog_scaffold(self, main_layout, ok_text="", cancel_text="")

        self.retranslate_ui()

        auto_size_dialog(self, min_width=350, min_height=200)

    def mousePressEvent(self, event: QMouseEvent):
        """Removes focus from input fields when clicking on empty area."""
        self.clear_input_focus()
        super().mousePressEvent(event)

    def get_theme(self):
        theme = self.combo_theme.currentData()
        return theme

    def get_language(self):
        language = self.combo_lang.currentData()
        return language

    def get_font_settings(self):
        """Get font settings."""
        if self.radio_font_system_default.isChecked():
            ui_font_mode = "system_default"
        elif self.radio_font_system_custom.isChecked():
            ui_font_mode = "system_custom"
        else:
            ui_font_mode = "builtin"

        ui_font_family = self.combo_font_family.currentData() or ""

        return ui_font_mode, ui_font_family

    def get_truncation_settings(self):
        """Get truncation settings."""
        return {
            "truncate_name_length": self.spin_name_length.value(),
            "truncate_quote_length": self.spin_quote_length.value(),
        }

    def get_auto_detect_profile(self):
        """Get auto-detect profile setting."""
        return self.checkbox_auto_detect_profile.isChecked()

    def get_auto_recalc(self):
        """Get automatic recalculation setting."""
        return self.checkbox_auto_recalc.isChecked()

    def retranslate_ui(self):
        """Updates all texts in dialog when language changes."""
        self.setWindowTitle(tr("Settings"))
        self.lang_label.setText(tr("Language:"))
        self.combo_lang.setItemText(0, tr("Russian"))
        self.combo_lang.setItemText(1, tr("English"))
        self.theme_label.setText(tr("Theme:"))
        self.combo_theme.setItemText(0, tr("Auto"))
        self.combo_theme.setItemText(1, tr("Light"))
        self.combo_theme.setItemText(2, tr("Dark"))
        self.font_group_title.setText(tr("UI Font"))
        self.radio_font_builtin.setText(tr("Built-in font"))
        self.radio_font_system_default.setText(tr("System default"))
        self.radio_font_system_custom.setText(tr("Custom"))
        self.combo_font_family.setItemText(0, tr("Select font..."))
        self.truncation_group_title.setText(tr("Truncation length"))
        self.label_name_length.setText(tr("Nicknames:"))
        self.label_quote_length.setText(tr("Quotes in replies:"))
        self.checkbox_auto_detect_profile.setText(tr("Auto-detect profile"))
        self.checkbox_auto_recalc.setText(tr("Automatic recalculation"))
        self.ok_button.setText(tr("OK"))
        self.cancel_button.setText(tr("Cancel"))

    def clear_input_focus(self):
        """Removes focus from any input field in dialog."""
        focused_widget = self.focusWidget()
        if focused_widget and isinstance(focused_widget, (QLineEdit, QWidget)) and focused_widget.inherits("QLineEdit"):
            focused_widget.clearFocus()

    def refresh_theme_styles(self):
        """Forces dialog styles to update."""

        self.style().unpolish(self)
        self.style().polish(self)
        self.updateGeometry()
        self.update()



--- Файл: ./src/ui/dialogs/dialog_builder.py ---
import os
from PyQt6.QtCore import QTimer
from PyQt6.QtGui import QIcon
from PyQt6.QtWidgets import QDialog, QHBoxLayout, QLabel, QVBoxLayout, QWidget

from resources.translations import tr
from ui.widgets.atomic.custom_button import CustomButton
from utils.paths import resource_path

def setup_dialog_scaffold(
    dialog: QDialog,
    main_layout: QVBoxLayout,
    ok_text: str,
    cancel_text: str = tr("Cancel"),
    show_cancel_button: bool = True,
):
    buttons_layout = QHBoxLayout()
    buttons_layout.addStretch()

    dialog.ok_button = CustomButton(None, ok_text)
    dialog.ok_button.setProperty("class", "primary")
    dialog.ok_button.setFixedSize(100, 30)
    dialog.cancel_button = CustomButton(None, cancel_text)
    dialog.cancel_button.setFixedSize(100, 30)

    dialog.ok_button.clicked.connect(dialog.accept)
    dialog.cancel_button.clicked.connect(dialog.reject)

    buttons_layout.addWidget(dialog.ok_button)
    if show_cancel_button:
        buttons_layout.addWidget(dialog.cancel_button)

    main_layout.addLayout(buttons_layout)

def setup_dialog_icon(dialog: QDialog):
    """Sets icon for dialog."""
    icon_path = resource_path("resources/icons/icon.png")
    if os.path.exists(icon_path):
        dialog.setWindowIcon(QIcon(icon_path))

def auto_size_dialog(dialog: QDialog, min_width: int = 300, min_height: int = 200):
    """
    Automatically calculates and sets dialog sizes based on content.

    Args:
        dialog: Dialog to update sizes for
        min_width: Minimum width
        min_height: Minimum height
    """

    def _recalculate_sizes():

        dialog.adjustSize()

        content_size = dialog.sizeHint()

        final_width = max(min_width, content_size.width() + 50)
        final_height = max(min_height, content_size.height() + 30)

        dialog.setMinimumSize(final_width, final_height)

        _update_group_sizes(dialog)

    QTimer.singleShot(0, _recalculate_sizes)

def _update_group_sizes(dialog: QDialog):
    """Updates sizes of styled groups in dialog."""
    for child in dialog.findChildren(QWidget):
        if child.objectName() == "StyledGroupFrame":
            parent_group = child.parent()
            if parent_group:

                content_width = child.sizeHint().width()

                min_width = content_width + 30

                for title_child in parent_group.findChildren(QLabel):
                    if title_child.objectName() == "StyledGroupTitle":
                        title_width = title_child.width() + 40
                        min_width = max(min_width, title_width)
                        break

                parent_group.setMinimumWidth(min_width)


--- Файл: ./src/ui/dialogs/export_dialog.py ---
import os

from PyQt6.QtCore import Qt
from PyQt6.QtGui import QIcon, QMouseEvent
from PyQt6.QtWidgets import (
    QCheckBox,
    QDialog,
    QFileDialog,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QVBoxLayout,
    QWidget,
)

from resources.translations import tr
from ui.dialogs.dialog_builder import auto_size_dialog, setup_dialog_scaffold, setup_dialog_icon
from ui.icon_manager import AppIcon
from ui.widgets.atomic.custom_button import CustomButton
from ui.widgets.atomic.custom_line_edit import CustomLineEdit
from utils.paths import resource_path

class ExportDialog(QDialog):

    def __init__(
        self,
        settings_manager,
        parent=None,
        suggested_filename: str = "",
        get_unique_path_func=None,
    ):
        super().__init__(parent)

        self.setObjectName("ExportDialog")
        self.settings_manager = settings_manager
        self.suggested_filename = suggested_filename

        self.get_unique_path_func = get_unique_path_func
        self._is_updating_name = False

        setup_dialog_icon(self)
        self.setWindowTitle(tr("Export Chat"))

        self.setWindowFlags(
            Qt.WindowType.Window
            | Qt.WindowType.WindowTitleHint
            | Qt.WindowType.WindowCloseButtonHint
        )
        self.setSizeGripEnabled(True)
        self.setMinimumWidth(450)

        main_layout = QVBoxLayout(self)
        main_layout.setSpacing(15)
        main_layout.setContentsMargins(20, 20, 20, 20)

        dir_label = QLabel(tr("Folder to save:"))
        dir_label.setObjectName("dir_label")
        self.edit_dir = CustomLineEdit()
        self.btn_browse_dir = CustomButton(AppIcon.FOLDER_OPEN, tr("Browse..."))
        self.btn_browse_dir.clicked.connect(self._choose_directory)

        dir_row = QHBoxLayout()
        dir_row.addWidget(self.edit_dir, 1)
        dir_row.addWidget(self.btn_browse_dir)

        fav_row = QHBoxLayout()
        fav_row.setContentsMargins(0, 0, 0, 0)
        self.checkbox_use_default_dir = QCheckBox(tr("Use as default folder"))

        button_container = QWidget()
        button_layout = QHBoxLayout(button_container)
        button_layout.setContentsMargins(0, 0, 0, 0)
        button_layout.setSpacing(8)

        self.btn_set_favorite = CustomButton(None, tr("To Favorites"))
        self.btn_use_favorite = CustomButton(None, tr("From Favorites"))
        self.btn_set_favorite.clicked.connect(self._set_favorite_from_current)
        self.btn_use_favorite.clicked.connect(self._use_favorite_dir)

        button_layout.addWidget(self.btn_set_favorite)
        button_layout.addWidget(self.btn_use_favorite)

        fav_row.addWidget(self.checkbox_use_default_dir, stretch=2)
        fav_row.addWidget(button_container, stretch=0)

        name_label = QLabel(tr("File name (without extension):"))
        name_label.setObjectName("name_label")
        self.edit_name = CustomLineEdit()

        main_layout.addWidget(dir_label)
        main_layout.addLayout(dir_row)
        main_layout.addLayout(fav_row)
        main_layout.addSpacing(10)
        main_layout.addWidget(name_label)
        main_layout.addWidget(self.edit_name)

        setup_dialog_scaffold(self, main_layout, ok_text=tr("Save"))

        auto_size_dialog(self, min_width=450, min_height=200)

        self._populate_from_state()

        self.edit_dir.textChanged.connect(self._update_final_filename_preview)

        self.edit_name.editingFinished.connect(self._update_final_filename_preview)

        initial_name = self.suggested_filename or tr("chat_history")
        self.edit_name.setText(initial_name)

        self._update_final_filename_preview()

    def _populate_from_state(self):

        use_default = self.settings_manager.settings.value(
            "export_use_default_dir", True, type=bool
        )

        self.checkbox_use_default_dir.setChecked(use_default)

        out_dir = (
            self.settings_manager.settings.value("export_default_dir", "", type=str)
            if use_default
            else ""
        )

        if not out_dir or not os.path.isdir(out_dir):
            out_dir = self._get_os_default_downloads()

        self.edit_dir.setText(out_dir)

        self._update_final_filename_preview()

    def _update_final_filename_preview(self):

        if self._is_updating_name:
            return

        if not self.get_unique_path_func:
            return

        directory = self.edit_dir.text().strip()
        base_name = self.edit_name.text().strip()

        if not directory or not base_name or not os.path.isdir(directory):
            return

        try:
            unique_path = self.get_unique_path_func(directory, base_name, ".txt")

            final_name, _ = os.path.splitext(os.path.basename(unique_path))

            if final_name != base_name:
                self._is_updating_name = True
                self.edit_name.setText(final_name)
                self._is_updating_name = False
        except Exception:
            pass

    def _choose_directory(self):
        start_dir = self.edit_dir.text() or self._get_os_default_downloads()

        chosen = QFileDialog.getExistingDirectory(self, tr("Choose folder"), start_dir)

        if chosen:
            self.edit_dir.setText(chosen)

            self._update_final_filename_preview()

    def _set_favorite_from_current(self):
        path = self.edit_dir.text().strip()
        if path:
            self.settings_manager.settings.setValue("export_favorite_dir", path)

    def _use_favorite_dir(self):
        path = self.settings_manager.settings.value("export_favorite_dir", "", type=str)

        if path:
            self.edit_dir.setText(path)

            self._update_final_filename_preview()

    def _get_os_default_downloads(self) -> str:
        return os.path.join(os.path.expanduser("~"), "Downloads")

    def get_export_options(self) -> dict:
        return {
            "output_dir": self.edit_dir.text().strip(),
            "file_name": self.edit_name.text().strip(),
            "use_default_dir": self.checkbox_use_default_dir.isChecked(),
        }

    def retranslate_ui(self):
        """Updates all texts in dialog when language changes."""
        self.setWindowTitle(tr("Export Chat"))
        self.findChild(QLabel, "dir_label").setText(tr("Folder to save:"))
        self.btn_browse_dir.setText(tr("Browse..."))
        self.checkbox_use_default_dir.setText(tr("Use as default folder"))
        self.btn_set_favorite.setText(tr("To Favorites"))
        self.btn_use_favorite.setText(tr("From Favorites"))
        self.findChild(QLabel, "name_label").setText(tr("File name (without extension):"))

        if hasattr(self, 'ok_button'):
            self.ok_button.setText(tr("Save"))
        if hasattr(self, 'cancel_button'):
            self.cancel_button.setText(tr("Cancel"))

    def refresh_theme_styles(self):
        """Forces dialog styles to update."""
        self.style().unpolish(self)
        self.style().polish(self)
        self.update()
        self.updateGeometry()

    def mousePressEvent(self, event: QMouseEvent):
        """Removes focus from input fields when clicking on empty area."""
        self.clear_input_focus()
        super().mousePressEvent(event)

    def clear_input_focus(self):
        """Removes focus if it's set on QLineEdit."""
        focused_widget = self.focusWidget()
        if focused_widget and isinstance(focused_widget, QLineEdit):
            focused_widget.clearFocus()

    def showEvent(self, event):
        self._update_final_filename_preview()

        super().showEvent(event)


--- Файл: ./src/ui/dialogs/calendar/__init__.py ---
"""Calendar dialog module."""

from ui.dialogs.calendar.calendar_dialog import CalendarDialog

__all__ = ["CalendarDialog"]


--- Файл: ./src/ui/dialogs/calendar/services/__init__.py ---
"""Services for calendar dialog."""

from ui.dialogs.calendar.services.calendar_calculation_service import CalendarCalculationService
from ui.dialogs.calendar.services.calendar_rendering_service import CalendarRenderingService
from ui.dialogs.calendar.services.date_filter_service import DateFilterService

__all__ = [
    "CalendarCalculationService",
    "CalendarRenderingService",
    "DateFilterService",
]


--- Файл: ./src/ui/dialogs/calendar/services/calendar_calculation_service.py ---
"""
Calendar calculation service.

Responsible for date processing, statistics and navigation.
"""

import calendar
from collections import defaultdict
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional, Set, Tuple

from PyQt6.QtCore import QDate

from core.analysis.tree_analyzer import TreeNode

@dataclass
class CalendarDay:
    """Information about a day in calendar."""

    date: QDate
    has_messages: bool
    message_count: int
    is_disabled: bool
    is_in_current_month: bool

@dataclass
class CalendarMonth:
    """Information about a month in calendar."""

    year: int
    month: int
    name: str
    message_count: int
    days: List[CalendarDay]

class CalendarCalculationService:
    """Calendar calculation service."""

    def __init__(self):
        self._date_to_node_map: Dict[str, TreeNode] = {}
        self._available_dates: Set[QDate] = set()
        self._messages_by_date: Dict[str, int] = defaultdict(int)

    def load_data(self, messages: List[dict], root_node: Optional[TreeNode] = None):
        """Loads message data and builds date map."""
        self._date_to_node_map.clear()
        self._available_dates.clear()
        self._messages_by_date.clear()

        for message in messages:
            date_str = message.get("date", "")
            if date_str:
                try:

                    if isinstance(date_str, str):
                        dt = datetime.fromisoformat(date_str.replace("Z", "+00:00"))
                    else:
                        dt = date_str

                    qdate = QDate(dt.year, dt.month, dt.day)
                    self._available_dates.add(qdate)

                    date_key = qdate.toString("yyyy-MM-dd")
                    self._messages_by_date[date_key] += 1

                except (ValueError, TypeError):
                    continue

        if root_node:
            self._build_date_to_node_map(root_node)

    def _build_date_to_node_map(self, node: TreeNode, path: str = ""):
        """Recursively builds date to tree node map."""
        current_path = f"{path}/{node.name}" if path else node.name

        if self._is_date_node(node):
            date = self._parse_date_from_path(current_path)
            if date:
                date_key = date.toString("yyyy-MM-dd")
                self._date_to_node_map[date_key] = node

        for child in node.children:
            self._build_date_to_node_map(child, current_path)

    def _is_date_node(self, node: TreeNode) -> bool:
        """Checks if node is a date node."""

        try:
            day = int(node.name)
            return 1 <= day <= 31 and not node.children
        except ValueError:
            return False

    def _parse_date_from_path(self, path: str) -> Optional[QDate]:
        """Parses date from tree node path."""
        parts = path.split("/")

        if len(parts) >= 3:
            try:
                year = int(parts[-3])
                month = int(parts[-2])
                day = int(parts[-1])

                if QDate.isValid(year, month, day):
                    return QDate(year, month, day)
            except (ValueError, IndexError):
                pass

        return None

    def get_month_data(
        self, year: int, month: int, disabled_nodes: Set[TreeNode]
    ) -> CalendarMonth:
        """Returns month data for display."""

        month_names = [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
        ]
        month_name = month_names[month - 1]

        cal = calendar.monthcalendar(year, month)

        days = []
        total_messages = 0

        first_week = cal[0]
        for day_num in first_week:
            if day_num == 0:

                prev_month_date = QDate(year, month, 1).addDays(-1)
                while prev_month_date.day() != len(first_week) - first_week.index(0):
                    prev_month_date = prev_month_date.addDays(-1)

                prev_month_date = prev_month_date.addDays(first_week.index(0))

                day_info = self._create_day_info(
                    prev_month_date, disabled_nodes, is_in_current_month=False
                )
                days.append(day_info)
            else:
                current_date = QDate(year, month, day_num)
                day_info = self._create_day_info(
                    current_date, disabled_nodes, is_in_current_month=True
                )
                days.append(day_info)
                total_messages += day_info.message_count

        for week in cal[1:]:
            for day_num in week:
                if day_num == 0:

                    next_month_date = (
                        QDate(year, month, 1).addMonths(1).addDays(day_num - 1)
                    )
                    day_info = self._create_day_info(
                        next_month_date, disabled_nodes, is_in_current_month=False
                    )
                    days.append(day_info)
                else:
                    current_date = QDate(year, month, day_num)
                    day_info = self._create_day_info(
                        current_date, disabled_nodes, is_in_current_month=True
                    )
                    days.append(day_info)
                    total_messages += day_info.message_count

        return CalendarMonth(
            year=year,
            month=month,
            name=month_name,
            message_count=total_messages,
            days=days,
        )

    def _create_day_info(
        self,
        date: QDate,
        disabled_nodes: Set[TreeNode],
        is_in_current_month: bool = True,
    ) -> CalendarDay:
        """Creates day information."""
        date_key = date.toString("yyyy-MM-dd")

        has_messages = date in self._available_dates
        message_count = self._messages_by_date.get(date_key, 0)

        node = self._date_to_node_map.get(date_key)
        is_disabled = node is not None and node in disabled_nodes

        return CalendarDay(
            date=date,
            has_messages=has_messages,
            message_count=message_count,
            is_disabled=is_disabled,
            is_in_current_month=is_in_current_month,
        )

    def get_available_years(self) -> List[int]:
        """Returns list of available years."""
        if not self._available_dates:
            return []

        years = set(date.year() for date in self._available_dates)
        return sorted(years)

    def get_available_months(self, year: int) -> List[int]:
        """Returns list of available months for year."""
        months = set()
        for date in self._available_dates:
            if date.year() == year:
                months.add(date.month())

        return sorted(months)

    def get_date_range(self) -> Tuple[Optional[QDate], Optional[QDate]]:
        """Returns range of available dates."""
        if not self._available_dates:
            return None, None

        min_date = min(self._available_dates)
        max_date = max(self._available_dates)

        return min_date, max_date

    def get_node_for_date(self, date: QDate) -> Optional[TreeNode]:
        """Returns tree node for date."""
        date_key = date.toString("yyyy-MM-dd")
        return self._date_to_node_map.get(date_key)

    def get_statistics(self, disabled_nodes: Set[TreeNode]) -> Dict[str, int]:
        """Returns calendar statistics."""
        total_days = len(self._available_dates)
        disabled_days = 0
        disabled_messages = 0
        total_messages = sum(self._messages_by_date.values())

        for date in self._available_dates:
            node = self.get_node_for_date(date)
            if node and node in disabled_nodes:
                disabled_days += 1
                date_key = date.toString("yyyy-MM-dd")
                disabled_messages += self._messages_by_date.get(date_key, 0)

        enabled_days = total_days - disabled_days
        enabled_messages = total_messages - disabled_messages

        return {
            "total_days": total_days,
            "enabled_days": enabled_days,
            "disabled_days": disabled_days,
            "total_messages": total_messages,
            "enabled_messages": enabled_messages,
            "disabled_messages": disabled_messages,
            "enabled_percentage": (
                (enabled_messages / total_messages * 100) if total_messages > 0 else 0
            ),
        }


--- Файл: ./src/ui/dialogs/calendar/services/calendar_rendering_service.py ---
"""
Calendar rendering service.

Responsible for creating and styling calendar UI elements.
"""

from typing import List, Optional

from PyQt6.QtCore import QDate, QObject, Qt, pyqtSignal, QSize
from PyQt6.QtGui import QColor
from PyQt6.QtWidgets import (
    QGridLayout,
    QLabel,
    QPushButton,
    QSizePolicy,
    QVBoxLayout,
    QWidget,
)

from resources.translations import tr
from core.view_models import CalendarViewModel
from ui.theme import ThemeManager
from ui.widgets.atomic.custom_button import CustomButton

class CalendarDayButton(QPushButton):
    """Custom button for a day in calendar."""
    date_clicked = pyqtSignal(QDate)
    date_context_menu = pyqtSignal(QDate)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setProperty("day-button", True)
        self.setCheckable(True)
        self.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        self.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.clicked.connect(self._on_click)
        self.customContextMenuRequested.connect(self._on_context_menu)
        self.date: Optional[QDate] = None

    def set_date(self, date: QDate):
        self.date = date

    def _on_click(self):
        if self.date:
            self.date_clicked.emit(self.date)

    def _on_context_menu(self, pos):
        if self.date:
            self.date_context_menu.emit(self.date)

    def sizeHint(self):
        """Returns preferred size for day button."""
        return QSize(50, 70)

class CalendarRenderingService(QObject):
    date_clicked = pyqtSignal(QDate)
    date_context_menu = pyqtSignal(QDate)
    month_selected = pyqtSignal(int, int)
    year_selected = pyqtSignal(int)
    month_context_menu = pyqtSignal(int, int)
    year_context_menu = pyqtSignal(int)

    def __init__(self, theme_manager: ThemeManager):
        super().__init__()
        self.theme_manager = theme_manager
        self._day_buttons: List[CalendarDayButton] = []
        self._day_labels: List[QLabel] = []
        self._month_buttons: List[CustomButton] = []
        self._month_labels: List[QLabel] = []
        self._year_buttons: List[CustomButton] = []
        self._year_labels: List[QLabel] = []
        self.current_year = QDate.currentDate().year()
        self._weekday_labels = []

    def create_day_view(self) -> QWidget:
        widget = QWidget()
        main_layout = QVBoxLayout(widget)
        main_layout.setSpacing(5)

        accent_color = self.theme_manager.get_color("accent").name()
        hover_color = self.theme_manager.get_color("dialog.button.hover").name()
        text_color = self.theme_manager.get_color("dialog.text").name()
        weekend_bg = self.theme_manager.get_color("calendar.weekend.background").name()
        disabled_bg = self.theme_manager.get_color("calendar.disabled.background").name()

        bg_color_obj = self.theme_manager.get_color("dialog.background")
        text_color_obj = self.theme_manager.get_color("dialog.text")
        r, g, b = (int(text_color_obj.red() * 0.6 + bg_color_obj.red() * 0.4),
                   int(text_color_obj.green() * 0.6 + bg_color_obj.green() * 0.4),
                   int(text_color_obj.blue() * 0.6 + bg_color_obj.blue() * 0.4))
        faded_text_color = QColor(r, g, b)

        widget.setStyleSheet(f"""
            QPushButton[day-button="true"] {{
                border: 1px solid transparent; border-radius: 4px; padding: 5px; background-color: transparent;
            }}
            QPushButton[day-button="true"][weekend="true"][checked="false"][disabled_for_export="false"] {{
                background-color: {weekend_bg};
            }}
            QPushButton[day-button="true"][active="true"][checked="false"][disabled_for_export="false"]:hover {{
                background-color: {hover_color};
            }}
            QPushButton[day-button="true"][disabled_for_export="false"]:checked {{
                background-color: {accent_color};
            }}
            QPushButton[day-button="true"][disabled_for_export="true"] {{
                background-color: {disabled_bg};
            }}
            QLabel[day-label="true"] {{
                background-color: transparent; font-size: 11pt; font-weight: 400; color: {faded_text_color.name()};
            }}
            QLabel[day-label="true"][active="true"] {{
                font-weight: 500; color: {text_color};
            }}
            QLabel[day-label="true"][checked="true"][disabled_for_export="false"] {{
                color: white; font-weight: 500;
            }}
            QLabel[day-label="true"][checked="true"][disabled_for_export="true"] {{
                color: {text_color};
            }}
            QLabel[weekday="true"] {{
                font-weight: bold; color: {text_color}; alignment: alignCenter;
            }}
        """)

        weekday_layout = QGridLayout()
        weekday_keys = ["weekday_mon", "weekday_tue", "weekday_wed", "weekday_thu", "weekday_fri", "weekday_sat", "weekday_sun"]
        self._weekday_labels.clear()
        for i, key in enumerate(weekday_keys):
            label = QLabel(tr(key))
            self._weekday_labels.append(label)
            label.setProperty("weekday", True)
            label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            label.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Fixed)
            weekday_layout.addWidget(label, 0, i)
        main_layout.addLayout(weekday_layout)

        days_layout = QGridLayout()
        days_layout.setSpacing(2)

        for i in range(42):
            btn = CalendarDayButton()
            btn.date_clicked.connect(self.date_clicked)
            btn.date_context_menu.connect(self.date_context_menu)
            self._day_buttons.append(btn)

            label = QLabel()
            label.setProperty("day-label", True)
            label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            label.setTextFormat(Qt.TextFormat.RichText)
            label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            self._day_labels.append(label)

            days_layout.addWidget(btn, i // 7, i % 7)
            days_layout.addWidget(label, i // 7, i % 7)

        main_layout.addLayout(days_layout)
        return widget

    def update_day_view(self, vm: CalendarViewModel):
        bg_color_obj = self.theme_manager.get_color("dialog.background")
        text_color_obj = self.theme_manager.get_color("dialog.text")
        r, g, b = (int(text_color_obj.red() * 0.5 + bg_color_obj.red() * 0.5),
                   int(text_color_obj.green() * 0.5 + bg_color_obj.green() * 0.5),
                   int(text_color_obj.blue() * 0.5 + bg_color_obj.blue() * 0.5))
        default_small_num_color = QColor(r, g, b).name()

        for i, day_info in enumerate(vm.days_in_current_month):
            if i >= len(self._day_buttons): break

            btn = self._day_buttons[i]
            lbl = self._day_labels[i]

            if day_info.is_in_current_month:
                btn.show()
                lbl.show()
            else:
                btn.hide()
                lbl.hide()
                continue

            is_weekend = day_info.date.dayOfWeek() >= 6
            is_active_for_display = day_info.is_available

            btn.set_date(day_info.date)
            btn.setProperty("weekend", is_weekend)
            btn.setProperty("disabled_for_export", day_info.is_disabled)
            btn.setProperty("active", day_info.is_available)
            btn.setProperty("checked", day_info.is_selected)
            lbl.setProperty("active", is_active_for_display)
            lbl.setProperty("checked", day_info.is_selected)
            lbl.setProperty("disabled_for_export", day_info.is_disabled)

            btn.setEnabled(day_info.is_available)
            btn.setCursor(Qt.CursorShape.PointingHandCursor if day_info.is_available else Qt.CursorShape.ArrowCursor)

            day_num = str(day_info.date.day())
            sub_text_color = "white" if day_info.is_selected and not day_info.is_disabled else default_small_num_color

            if day_info.is_available:
                html_text = f"""<p style="line-height: 1.0; margin: 0; padding: 0;">{day_num}<br>
                               <span style="font-size: 7pt; color: {sub_text_color};">{day_info.message_count}</span></p>"""
            else:
                html_text = f'<p style="line-height: 1.0; margin: 0; padding: 0;">{day_num}</p>'

            if day_info.is_disabled:
                html_text = f"<span style='text-decoration: line-through; font-style: italic;'>{html_text}</span>"

            lbl.setText(html_text)
            btn.blockSignals(True)
            btn.setChecked(day_info.is_selected)
            btn.blockSignals(False)

            btn.style().unpolish(btn); btn.style().polish(btn)
            lbl.style().unpolish(lbl); lbl.style().polish(lbl)
            btn.update(); lbl.update()

    def create_month_view(self) -> QWidget:
        widget = QWidget()
        layout = QGridLayout(widget)
        layout.setSpacing(5)

        for i in range(12):
            btn = CustomButton(None, "")
            btn.setProperty("month", i + 1)
            btn.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
            btn.clicked.connect(lambda checked=False, month=i + 1: self.month_selected.emit(self.current_year, month))
            btn.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            btn.customContextMenuRequested.connect(lambda pos, month=i + 1: self.month_context_menu.emit(self.current_year, month))
            self._month_buttons.append(btn)

            label = QLabel()
            label.setProperty("month-label", True)
            label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            label.setTextFormat(Qt.TextFormat.RichText)
            label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            self._month_labels.append(label)

            layout.addWidget(btn, i // 3, i % 3)
            layout.addWidget(label, i // 3, i % 3)

        for row in range(4):
            layout.setRowStretch(row, 1)
        return widget

    def update_month_view(self, vm: CalendarViewModel):
        self.current_year = vm.current_year
        bg_color_obj = self.theme_manager.get_color("dialog.background")
        text_color_obj = self.theme_manager.get_color("dialog.text")
        r, g, b = (int(text_color_obj.red() * 0.5 + bg_color_obj.red() * 0.5),
                   int(text_color_obj.green() * 0.5 + bg_color_obj.green() * 0.5),
                   int(text_color_obj.blue() * 0.5 + bg_color_obj.blue() * 0.5))
        sub_text_color = QColor(r, g, b).name()
        disabled_bg_color = self.theme_manager.get_color("calendar.disabled.background")

        for month_info in vm.months_in_current_year:
            i = month_info.month - 1
            if i >= len(self._month_buttons): continue

            btn = self._month_buttons[i]
            lbl = self._month_labels[i]

            btn.setProperty("month", month_info.month)
            btn.setEnabled(month_info.is_available)
            btn.setCursor(Qt.CursorShape.PointingHandCursor if month_info.is_available else Qt.CursorShape.ArrowCursor)

            html_text = f"""<p style="line-height: 1.0; margin: 0; padding: 0; text-align: center;">{month_info.name}<br>
                           <span style="font-size: 9pt; color: {sub_text_color};">{month_info.message_count}</span></p>"""

            if month_info.is_disabled:
                btn.set_override_bg_color(disabled_bg_color)
                html_text = f"<span style='text-decoration: line-through; font-style: italic;'>{html_text}</span>"
            else:
                btn.set_override_bg_color(None)

            lbl.setText(html_text)
            btn.style().unpolish(btn); btn.style().polish(btn)
            lbl.style().unpolish(lbl); lbl.style().polish(lbl)
            btn.update(); lbl.update()

    def create_year_view(self) -> QWidget:
        widget = QWidget()
        widget.setLayout(QGridLayout())
        widget.layout().setSpacing(5)
        return widget

    def update_year_view(self, vm: CalendarViewModel, container_widget: QWidget):
        layout = container_widget.layout()

        while item := layout.takeAt(0):
            if widget := item.widget():
                widget.deleteLater()

        bg_color_obj = self.theme_manager.get_color("dialog.background")
        text_color_obj = self.theme_manager.get_color("dialog.text")
        r, g, b = (int(text_color_obj.red() * 0.5 + bg_color_obj.red() * 0.5),
                   int(text_color_obj.green() * 0.5 + bg_color_obj.green() * 0.5),
                   int(text_color_obj.blue() * 0.5 + bg_color_obj.blue() * 0.5))
        sub_text_color = QColor(r, g, b).name()
        disabled_bg_color = self.theme_manager.get_color("calendar.disabled.background")

        self._year_buttons.clear()
        self._year_labels.clear()

        row, col = 0, 0
        for year_info in vm.available_years:
            btn = CustomButton(None, "")
            btn.setProperty("year", year_info.year)
            btn.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
            btn.clicked.connect(lambda checked=False, year=year_info.year: self.year_selected.emit(year))
            btn.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            btn.customContextMenuRequested.connect(lambda pos, year=year_info.year: self.year_context_menu.emit(year))
            self._year_buttons.append(btn)

            label = QLabel()
            label.setProperty("year-label", True)
            label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            label.setTextFormat(Qt.TextFormat.RichText)
            label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            self._year_labels.append(label)

            layout.addWidget(btn, row, col)
            layout.addWidget(label, row, col)

            html_text = f"""<p style="line-height: 1.0; margin: 0; padding: 0; text-align: center;">{year_info.name}<br>
                           <span style="font-size: 9pt; color: {sub_text_color};">{year_info.message_count}</span></p>"""

            if year_info.is_disabled:
                btn.set_override_bg_color(disabled_bg_color)
                html_text = f"<span style='text-decoration: line-through; font-style: italic;'>{html_text}</span>"
            else:
                btn.set_override_bg_color(None)

            label.setText(html_text)
            btn.style().unpolish(btn); btn.style().polish(btn)
            label.style().unpolish(label); label.style().polish(label)
            btn.update(); label.update()

            col += 1
            if col > 2:
                col = 0
                row += 1
        layout.setRowStretch(row + 1, 1)

    def retranslate_ui(self):
        """Updates translations for statically created elements."""
        weekday_keys = ["weekday_mon", "weekday_tue", "weekday_wed", "weekday_thu", "weekday_fri", "weekday_sat", "weekday_sun"]
        for i, label in enumerate(self._weekday_labels):
            if i < len(weekday_keys):
                label.setText(tr(weekday_keys[i]))


--- Файл: ./src/ui/dialogs/calendar/services/date_filter_service.py ---
"""
Service for filtering dates in calendar.

Responsible for managing disabled nodes and group operations.
"""

from typing import Optional, Set

from PyQt6.QtCore import QDate, QObject, pyqtSignal

from core.analysis.tree_analyzer import TreeNode

from ui.dialogs.calendar.services.calendar_calculation_service import CalendarCalculationService

class DateFilterService(QObject):
    """Service for managing date filtering."""

    filter_changed = pyqtSignal(set)
    statistics_updated = pyqtSignal(dict)

    def __init__(self, calculation_service: CalendarCalculationService):
        super().__init__()
        self._calculation_service = calculation_service
        self._disabled_nodes: Set[TreeNode] = set()
        self._root_node: Optional[TreeNode] = None

    def set_root_node(self, root_node: Optional[TreeNode]):
        """Sets root node of the tree."""
        self._root_node = root_node

    def set_disabled_nodes(self, disabled_nodes: Set[TreeNode]):
        """Sets disabled nodes."""
        old_disabled = self._disabled_nodes.copy()
        self._disabled_nodes = disabled_nodes.copy()

        if old_disabled != self._disabled_nodes:
            self.filter_changed.emit(self._disabled_nodes)
            self._update_statistics()

    def get_disabled_nodes(self) -> Set[TreeNode]:
        """Returns disabled nodes."""
        return self._disabled_nodes.copy()

    def toggle_date(self, date: QDate):
        """Toggles date disable state."""
        node = self._calculation_service.get_node_for_date(date)
        if node:
            if node in self._disabled_nodes:
                self._disabled_nodes.remove(node)
            else:
                self._disabled_nodes.add(node)

            self.filter_changed.emit(self._disabled_nodes)
            self._update_statistics()

    def disable_date(self, date: QDate):
        """Disables date."""
        node = self._calculation_service.get_node_for_date(date)
        if node and node not in self._disabled_nodes:
            self._disabled_nodes.add(node)
            self.filter_changed.emit(self._disabled_nodes)
            self._update_statistics()

    def enable_date(self, date: QDate):
        """Enables date."""
        node = self._calculation_service.get_node_for_date(date)
        if node and node in self._disabled_nodes:
            self._disabled_nodes.remove(node)
            self.filter_changed.emit(self._disabled_nodes)
            self._update_statistics()

    def is_date_disabled(self, date: QDate) -> bool:
        """Checks if date is disabled."""
        node = self._calculation_service.get_node_for_date(date)
        return node is not None and node in self._disabled_nodes

    def disable_all_dates(self):
        """Disables all available dates."""
        if not self._root_node:
            return

        all_date_nodes = set()
        self._collect_date_nodes(self._root_node, all_date_nodes)

        self._disabled_nodes = all_date_nodes
        self.filter_changed.emit(self._disabled_nodes)
        self._update_statistics()

    def enable_all_dates(self):
        """Enables all dates."""
        self._disabled_nodes.clear()
        self.filter_changed.emit(self._disabled_nodes)
        self._update_statistics()

    def disable_month(self, year: int, month: int):
        """Disables all days of the month."""
        if not self._root_node:
            return

        month_nodes = self._find_month_nodes(self._root_node, year, month)
        self._disabled_nodes.update(month_nodes)
        self.filter_changed.emit(self._disabled_nodes)
        self._update_statistics()

    def enable_month(self, year: int, month: int):
        """Enables all days of the month."""
        if not self._root_node:
            return

        month_nodes = self._find_month_nodes(self._root_node, year, month)
        self._disabled_nodes -= month_nodes
        self.filter_changed.emit(self._disabled_nodes)
        self._update_statistics()

    def disable_year(self, year: int):
        """Disables all days of the year."""
        if not self._root_node:
            return

        year_nodes = self._find_year_nodes(self._root_node, year)
        self._disabled_nodes.update(year_nodes)
        self.filter_changed.emit(self._disabled_nodes)
        self._update_statistics()

    def enable_year(self, year: int):
        """Enables all days of the year."""
        if not self._root_node:
            return

        year_nodes = self._find_year_nodes(self._root_node, year)
        self._disabled_nodes -= year_nodes
        self.filter_changed.emit(self._disabled_nodes)
        self._update_statistics()

    def disable_weekends(self):
        """Disables all weekend days."""
        if not self._root_node:
            return

        weekend_nodes = set()
        for date in self._calculation_service._available_dates:

            if date.dayOfWeek() in [6, 7]:
                node = self._calculation_service.get_node_for_date(date)
                if node:
                    weekend_nodes.add(node)

        self._disabled_nodes.update(weekend_nodes)
        self.filter_changed.emit(self._disabled_nodes)
        self._update_statistics()

    def enable_weekends(self):
        """Enables all weekend days."""
        if not self._root_node:
            return

        weekend_nodes = set()
        for date in self._calculation_service._available_dates:
            if date.dayOfWeek() in [6, 7]:
                node = self._calculation_service.get_node_for_date(date)
                if node:
                    weekend_nodes.add(node)

        self._disabled_nodes -= weekend_nodes
        self.filter_changed.emit(self._disabled_nodes)
        self._update_statistics()

    def disable_date_range(self, start_date: QDate, end_date: QDate):
        """Disables date range."""
        current_date = start_date
        while current_date <= end_date:
            node = self._calculation_service.get_node_for_date(current_date)
            if node:
                self._disabled_nodes.add(node)
            current_date = current_date.addDays(1)

        self.filter_changed.emit(self._disabled_nodes)
        self._update_statistics()

    def enable_date_range(self, start_date: QDate, end_date: QDate):
        """Enables date range."""
        current_date = start_date
        while current_date <= end_date:
            node = self._calculation_service.get_node_for_date(current_date)
            if node:
                self._disabled_nodes.discard(node)
            current_date = current_date.addDays(1)

        self.filter_changed.emit(self._disabled_nodes)
        self._update_statistics()

    def _collect_date_nodes(self, node: TreeNode, date_nodes: Set[TreeNode]):
        """Recursively collects all date nodes."""

        if not node.children and self._is_date_node_name(node.name):
            date_nodes.add(node)

        for child in node.children:
            self._collect_date_nodes(child, date_nodes)

    def _find_month_nodes(self, node: TreeNode, year: int, month: int) -> Set[TreeNode]:
        """Finds all day nodes for a given month."""
        month_nodes = set()

        year_node = self._find_child_by_name(node, str(year))
        if year_node:

            month_node = self._find_child_by_name(year_node, f"{month:02d}")
            if month_node:

                self._collect_date_nodes(month_node, month_nodes)

        return month_nodes

    def _find_year_nodes(self, node: TreeNode, year: int) -> Set[TreeNode]:
        """Finds all day nodes for a given year."""
        year_nodes = set()

        year_node = self._find_child_by_name(node, str(year))
        if year_node:

            self._collect_date_nodes(year_node, year_nodes)

        return year_nodes

    def _find_child_by_name(self, node: TreeNode, name: str) -> Optional[TreeNode]:
        """Finds child node by name."""
        for child in node.children:
            if child.name == name:
                return child
        return None

    def _is_date_node_name(self, name: str) -> bool:
        """Checks if node name is a day name."""
        try:
            day = int(name)
            return 1 <= day <= 31
        except ValueError:
            return False

    def _update_statistics(self):
        """Updates statistics."""
        stats = self._calculation_service.get_statistics(self._disabled_nodes)
        self.statistics_updated.emit(stats)


--- Файл: ./src/ui/dialogs/calendar/calendar_dialog.py ---
from collections import defaultdict
from datetime import datetime
from html import escape
from typing import Set

from PyQt6.QtCore import QDate, Qt, pyqtSignal
from PyQt6.QtGui import QColor, QWheelEvent
from PyQt6.QtWidgets import (
    QDialog,
    QHBoxLayout,
    QLabel,
    QPushButton,
    QStackedWidget,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

from core.analysis.tree_analyzer import TreeNode
from core.application.calendar_service import CalendarService
from core.conversion.context import ConversionContext
from core.conversion.message_formatter import format_message
from core.conversion.utils import markdown_to_html_for_preview
from resources.translations import tr
from ui.dialogs.dialog_builder import auto_size_dialog, setup_dialog_scaffold, setup_dialog_icon
from ui.dialogs.calendar.services.calendar_rendering_service import CalendarRenderingService
from presenters.calendar_presenter import CalendarPresenter
from core.view_models import CalendarViewModel
from ui.theme import ThemeManager
from ui.widgets.atomic.custom_button import CustomButton
from ui.widgets.atomic.minimalist_scrollbar import MinimalistScrollBar

class NonPropagatingTextEdit(QTextEdit):
    """A QTextEdit that stops wheel events from propagating when at scroll limits."""
    def wheelEvent(self, event: QWheelEvent):
        scrollbar = self.verticalScrollBar()
        is_at_top = scrollbar.value() == scrollbar.minimum()
        is_at_bottom = scrollbar.value() == scrollbar.maximum()

        scrolling_down = event.angleDelta().y() < 0
        scrolling_up = event.angleDelta().y() > 0

        if (scrolling_up and is_at_top) or (scrolling_down and is_at_bottom):

            event.accept()
        else:

            super().wheelEvent(event)

class CalendarDialog(QDialog):
    filter_accepted = pyqtSignal(set)

    def __init__(
        self,
        presenter,
        messages: list,
        config: dict,
        theme_manager: ThemeManager,
        root_node: TreeNode | None = None,
        initial_disabled_nodes: Set[TreeNode] | None = None,
        token_hierarchy: dict | None = None,
        parent=None,
    ):
        super().__init__(parent)
        self.theme_manager = theme_manager

        self.messages = messages

        calendar_service = CalendarService()
        self.presenter = CalendarPresenter(calendar_service)
        self.rendering_service = CalendarRenderingService(self.theme_manager)

        self.setWindowTitle(tr("Calendar"))
        setup_dialog_icon(self)
        self.setMinimumSize(800, 600)
        self.setWindowFlags(self.windowFlags() | Qt.WindowType.WindowMinMaxButtonsHint)

        self._setup_ui()
        self._connect_signals()
        self._update_preview_styles()

        self.presenter.load_calendar_data(
            raw_messages=messages,
            analysis_tree=root_node,
            initial_disabled_nodes=initial_disabled_nodes or set(),
            token_hierarchy=token_hierarchy,
            config=config
        )

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        main_widget = QWidget()
        main_layout = QHBoxLayout(main_widget)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)

        left_panel_widget = QWidget()
        left_panel_layout = QVBoxLayout(left_panel_widget)
        left_panel_layout.setContentsMargins(0, 0, 0, 0)

        header_layout = QHBoxLayout()
        self.prev_button = CustomButton(None, "<")
        self.title_button = QPushButton()
        self.next_button = CustomButton(None, ">")

        bg_color_obj = self.theme_manager.get_color("dialog.background")
        text_color_obj = self.theme_manager.get_color("dialog.text")
        r, g, b = (int(text_color_obj.red() * 0.8 + bg_color_obj.red() * 0.2),
                   int(text_color_obj.green() * 0.8 + bg_color_obj.green() * 0.2),
                   int(text_color_obj.blue() * 0.8 + bg_color_obj.blue() * 0.2))
        faded_title_color = QColor(r, g, b)
        self.title_button.setStyleSheet(f"""
            QPushButton {{
                border: none; background-color: transparent;
                color: {faded_title_color.name()}; font-weight: bold; font-size: 11pt;
            }}
            QPushButton:hover {{
                background-color: {self.theme_manager.get_color("dialog.button.hover").name()};
            }}
        """)

        header_layout.addWidget(self.prev_button)
        header_layout.addWidget(self.title_button, 1)
        header_layout.addWidget(self.next_button)

        self.view_stack = QStackedWidget()
        self.day_view_widget = self.rendering_service.create_day_view()
        self.month_view_widget = self.rendering_service.create_month_view()
        self.year_view_widget = self.rendering_service.create_year_view()

        self.view_stack.addWidget(self.day_view_widget)
        self.view_stack.addWidget(self.month_view_widget)
        self.view_stack.addWidget(self.year_view_widget)

        left_panel_layout.addLayout(header_layout)
        left_panel_layout.addWidget(self.view_stack, 1)

        right_panel_widget = QWidget()
        right_panel_layout = QVBoxLayout(right_panel_widget)
        self.date_label = QLabel(tr("Date"))
        self.date_label.setStyleSheet("font-weight: bold; padding-bottom: 5px;")

        self.text_view = NonPropagatingTextEdit()
        self.text_view.setReadOnly(True)

        self.text_view.setTextInteractionFlags(Qt.TextInteractionFlag.NoTextInteraction)
        self.text_view.viewport().setCursor(Qt.CursorShape.ArrowCursor)

        self.text_view.setVerticalScrollBar(MinimalistScrollBar(self.text_view))

        right_panel_layout.addWidget(self.date_label)
        right_panel_layout.addWidget(self.text_view, 1)

        main_layout.addWidget(left_panel_widget, 2)
        main_layout.addWidget(right_panel_widget, 3)
        layout.addWidget(main_widget, 1)

        setup_dialog_scaffold(self, layout, ok_text=tr("Save"), cancel_text=tr("Close"))
        auto_size_dialog(self, min_width=800, min_height=600)

    def _update_preview_styles(self):
        """Updates CSS styles for the preview QTextEdit."""
        theme = self.theme_manager
        text_color = theme.get_color("dialog.text").name()
        link_color = theme.get_color("accent").name()
        spoiler_bg = theme.get_color("dialog.button.hover").name()
        code_bg = theme.get_color("dialog.button.hover").name()

        stylesheet = f"""
        body {{ color: {text_color}; }}
        a {{ color: {link_color}; text-decoration: none; }}
        .spoiler {{
            background-color: {spoiler_bg};
            color: {spoiler_bg};
            border-radius: 3px;
            padding: 1px 3px;
        }}
        .spoiler:hover {{
            color: {text_color};
        }}
        code {{
            background-color: {code_bg};
            border-radius: 3px;
            font-family: monospace;
            padding: 1px 3px;
        }}
        """
        self.text_view.document().setDefaultStyleSheet(stylesheet)

        if self.text_view.toPlainText():
            self.text_view.setHtml(self.text_view.toHtml())

    def _connect_signals(self):
        self.presenter.view_model_updated.connect(self.update_ui)
        self.presenter.messages_for_date_updated.connect(self._update_message_view)

        self.rendering_service.date_clicked.connect(self.presenter.select_date)
        self.rendering_service.month_selected.connect(self.presenter.select_month)
        self.rendering_service.year_selected.connect(self.presenter.select_year)

        self.rendering_service.date_context_menu.connect(self.presenter.toggle_filter_for_date)
        self.rendering_service.month_context_menu.connect(self.presenter.toggle_filter_for_month)
        self.rendering_service.year_context_menu.connect(self.presenter.toggle_filter_for_year)

        self.prev_button.clicked.connect(self.presenter.navigate_previous)
        self.next_button.clicked.connect(self.presenter.navigate_next)
        self.title_button.clicked.connect(self._on_title_clicked)

    def get_disabled_nodes(self) -> set:
        """Returns current set of disabled nodes from presenter."""
        return self.presenter.get_disabled_nodes()

    def _on_title_clicked(self):
        vm = self.presenter.get_current_view_model()
        if vm.view_mode == "days": self.presenter.set_view_mode("months")
        elif vm.view_mode == "months": self.presenter.set_view_mode("years")

    def update_ui(self, vm: CalendarViewModel):
        self.title_button.setText(vm.navigation_title)
        self.prev_button.setEnabled(vm.can_go_previous)
        self.next_button.setEnabled(vm.can_go_next)

        if vm.view_mode == "days":
            self.view_stack.setCurrentWidget(self.day_view_widget)
            self.rendering_service.update_day_view(vm)
        elif vm.view_mode == "months":
            self.view_stack.setCurrentWidget(self.month_view_widget)
            self.rendering_service.update_month_view(vm)
        elif vm.view_mode == "years":
            self.view_stack.setCurrentWidget(self.year_view_widget)
            self.rendering_service.update_year_view(vm, self.year_view_widget)

    def _update_message_view(self, formatted_text: str):
        """Updates message display for selected date."""

        if self.presenter and self.presenter.last_valid_selection:
            self.date_label.setText(self.presenter.last_valid_selection.toString(Qt.DateFormat.ISODate))
        else:
            self.date_label.setText(tr("Date"))

        html_text = markdown_to_html_for_preview(formatted_text)
        self.text_view.setHtml(html_text)

    def accept(self):

        final_disabled_nodes = self.presenter.get_disabled_nodes()
        self.presenter.filter_changed.emit(final_disabled_nodes)
        super().accept()

    def retranslate_ui(self):
        """Updates all texts in dialog when language changes."""
        self.setWindowTitle(tr("Calendar"))
        self.date_label.setText(tr("Date"))
        self.ok_button.setText(tr("Save"))
        self.cancel_button.setText(tr("Close"))

        self.rendering_service.retranslate_ui()

        if self.presenter:
            self.presenter._update_view_model()

        if self.presenter and self.presenter.last_valid_selection:

            formatted_text = self.presenter._format_messages_for_date(self.presenter.last_valid_selection)
            self._update_message_view(formatted_text)
        elif self.text_view.toPlainText() == "No messages on this date.":
             self.text_view.setPlainText(tr("No messages on this date."))

    def refresh_theme_styles(self):
        """Forces dialog styles to update."""
        self.style().unpolish(self)
        self.style().polish(self)
        self._update_preview_styles()
        self.update()
        self.updateGeometry()

    def wheelEvent(self, event: QWheelEvent):
        vm = self.presenter.get_current_view_model()
        if vm.view_mode != "days":
            event.ignore()
            return

        delta = event.angleDelta().y()
        if delta > 0:
            self.presenter.navigate_previous()
        elif delta < 0:
            self.presenter.navigate_next()

        event.accept()


--- Файл: ./src/ui/dialogs/help_dialog.py ---
import os
from PyQt6.QtWidgets import (
    QDialog,
    QHBoxLayout,
    QListWidget,
    QStackedWidget,
    QLabel,
    QFrame,
    QListWidgetItem,
    QScrollArea,
)
from PyQt6.QtCore import Qt, QSize
from PyQt6.QtGui import QFontMetrics, QIcon
import os

from utils.paths import resource_path
from ui.theme import ThemeManager
from resources.translations import tr
from ui.widgets.atomic.minimalist_scrollbar import MinimalistScrollBar

class HelpDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setObjectName("HelpDialog")
        self.theme_manager = ThemeManager.get_instance()

        self.setWindowTitle(tr("Tkonverter Help"))
        icon_path = resource_path("resources/icons/icon.png")
        if os.path.exists(icon_path):
            self.setWindowIcon(QIcon(icon_path))

        self.setWindowFlags(
            Qt.WindowType.Window | Qt.WindowType.WindowTitleHint | Qt.WindowType.WindowCloseButtonHint
        )
        self.setSizeGripEnabled(True)
        self.resize(800, 600)
        self.setMinimumSize(640, 480)

        self._setup_ui()
        self._populate_content()
        self._apply_styles()

        self.theme_manager.theme_changed.connect(self._apply_styles)

    def _setup_ui(self):
        main_layout = QHBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        self.nav_widget = QListWidget()
        self.nav_widget.setFrameShape(QFrame.Shape.NoFrame)
        self.nav_widget.setVerticalScrollBarPolicy(
            Qt.ScrollBarPolicy.ScrollBarAlwaysOff
        )
        self.nav_widget.setHorizontalScrollBarPolicy(
            Qt.ScrollBarPolicy.ScrollBarAlwaysOff
        )

        self.nav_widget.setMouseTracking(True)

        self.nav_widget.setAttribute(Qt.WidgetAttribute.WA_Hover, True)
        self.nav_widget.setSelectionBehavior(QListWidget.SelectionBehavior.SelectRows)

        self.nav_widget.setStyleSheet("")
        self.nav_widget.currentRowChanged.connect(self.change_page)

        self.content_stack = QStackedWidget()
        self.content_stack.setFrameShape(QFrame.Shape.NoFrame)

        self.scroll_area = QScrollArea()
        self.scroll_area.setFrameShape(QFrame.Shape.NoFrame)
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)

        self.custom_scrollbar = MinimalistScrollBar(self.scroll_area)
        self.scroll_area.setVerticalScrollBar(self.custom_scrollbar)
        self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)

        self.scroll_area.setWidget(self.content_stack)

        main_layout.addWidget(self.nav_widget)
        main_layout.addWidget(self.scroll_area, 1)

    def _update_nav_width(self):
        max_text_width = 0
        for i in range(self.nav_widget.count()):
            item = self.nav_widget.item(i)
            text = item.text()
            text_width = QFontMetrics(self.nav_widget.font()).horizontalAdvance(text)
            max_text_width = max(max_text_width, text_width)
        self.nav_widget.setFixedWidth(max(180, max_text_width + 32))

    def _populate_content(self):
        sections = [
            ("Help Section: Introduction", "help_intro_html"),
            ("Help Section: File Management", "help_files_html"),
            ("Help Section: Conversion Options", "help_conversion_html"),
            ("Help Section: Analysis Tools", "help_analysis_html"),
            ("Help Section: AI Features", "help_ai_html"),
            ("Help Section: Exporting", "help_export_html"),
        ]

        self._content_keys = []
        for title_key, content_key in sections:
            self._add_section(title_key, content_key)
            self._content_keys.append(content_key)

        if self.nav_widget.count() > 0:
            self.nav_widget.setCurrentRow(0)

        self._update_nav_width()

    def _add_section(self, title_key: str, content_key: str):
        title = tr(title_key)
        nav_item = QListWidgetItem(title, self.nav_widget)
        nav_item.setSizeHint(QSize(200, 35))

        content_page = QLabel()
        content_page.setMargin(25)
        content_page.setWordWrap(True)
        content_page.setAlignment(
            Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft
        )
        content_page.setTextFormat(Qt.TextFormat.RichText)
        content_page.setOpenExternalLinks(True)
        content_page.setText(tr(content_key))
        self.content_stack.addWidget(content_page)

    def change_page(self, index: int):
        self.content_stack.setCurrentIndex(index)

    def _apply_styles(self):

        self.style().unpolish(self)
        self.style().polish(self)

        self.nav_widget.style().unpolish(self.nav_widget)
        self.nav_widget.style().polish(self.nav_widget)

        self.nav_widget.update()
        self.nav_widget.repaint()

        tm = self.theme_manager
        text_color = tm.get_color("dialog.text").name()
        separator_color = tm.get_color("dialog.border").name()
        code_bg_color = tm.get_color("dialog.button.hover").name()
        bold_color = text_color

        content_wrapper_style = f"""
        <style>
            body {{ font-size: 14px; color: {text_color}; }}
            h2 {{ margin-bottom: 8px; border-bottom: 1px solid {separator_color}; padding-bottom: 4px; }}
            h3 {{ margin: 12px 0 6px 0; }}
            ul {{ margin: 0; padding-left: 20px; }}
            li {{ margin-bottom: 5px; }}
            b, strong {{ color: {bold_color}; }}
            code {{ background-color: {code_bg_color}; border-radius: 3px; padding: 1px 3px; font-family: monospace; }}
        </style>
        """
        for i in range(self.content_stack.count()):
            page = self.content_stack.widget(i)
            if isinstance(page, QLabel):
                key = self._content_keys[i]
                page.setText(content_wrapper_style + tr(key))

    def retranslate_ui(self):
        self.setWindowTitle(tr("Tkonverter Help"))
        self.nav_widget.clear()

        while self.content_stack.count() > 0:
            w = self.content_stack.widget(0)
            self.content_stack.removeWidget(w)
            w.deleteLater()

        self._populate_content()
        self._apply_styles()


--- Файл: ./src/ui/dialogs/installation_manager_dialog.py ---
import importlib.util

from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QMouseEvent
from PyQt6.QtWidgets import (
    QCheckBox,
    QDialog,
    QFrame,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

from core.settings import SettingsManager
from resources.translations import tr
from ui.dialogs.dialog_builder import auto_size_dialog, setup_dialog_scaffold, setup_dialog_icon
from ui.theme import ThemeManager
from ui.widgets.atomic.custom_button import CustomButton
from ui.widgets.atomic.custom_line_edit import CustomLineEdit
from ui.widgets.atomic.minimalist_scrollbar import MinimalistScrollBar

class InstallationManagerDialog(QDialog):
    install_triggered = pyqtSignal()
    remove_model_triggered = pyqtSignal()
    load_model_triggered = pyqtSignal(str)

    def __init__(
        self,
        is_installed: bool,
        is_loaded: bool,
        loaded_model_name: str | None,
        settings_manager: SettingsManager,
        settings: dict,
        model_in_cache: bool = False,
        theme_manager=None,
        parent=None,
    ):
        super().__init__(parent)
        self.setWindowTitle(tr("AI Component Management"))
        setup_dialog_icon(self)
        self.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose, True)
        self.setMinimumSize(500, 450)

        main_layout = QVBoxLayout(self)

        self.loaded_model_name = loaded_model_name
        self.is_installed = is_installed
        self.is_loaded = is_loaded
        self.model_in_cache = model_in_cache
        self._settings_manager = settings_manager
        self._theme_manager = theme_manager or ThemeManager.get_instance()
        self._restart_needed = False
        status_group, status_layout, _ = self._create_styled_group(tr("Status:"))
        status_inner_layout = QVBoxLayout()
        status_inner_layout.setSpacing(2)

        library_status_layout = QHBoxLayout()
        library_status_label = QLabel(tr("Library Status:"))
        self.status_label = QLabel()
        library_status_layout.addWidget(library_status_label)
        library_status_layout.addWidget(self.status_label)
        library_status_layout.addStretch()
        status_inner_layout.addLayout(library_status_layout)

        model_status_layout = QHBoxLayout()
        model_status_label = QLabel(tr("Loaded Model:"))
        self.loaded_model_label = QLabel()
        self.loaded_model_label.setStyleSheet("font-style: italic;")
        model_status_layout.addWidget(model_status_label)
        model_status_layout.addWidget(self.loaded_model_label)
        model_status_layout.addStretch()
        status_inner_layout.addLayout(model_status_layout)

        status_layout.addLayout(status_inner_layout)

        actions_group, actions_layout, _ = self._create_styled_group(tr("Actions"))
        self.install_button = CustomButton(
            None, tr("Install/Update transformers library")
        )
        self.install_button.setToolTip(tr("This action requires restart"))
        self.install_button.clicked.connect(self.install_triggered.emit)
        self.remove_button = CustomButton(None, tr("Remove Model from Cache"))
        self.remove_button.setToolTip(
            tr(
                "Removes the model specified in the configuration from the local cache to free up disk space."
            )
        )
        self.remove_button.clicked.connect(self.remove_model_triggered.emit)

        buttons_layout = QHBoxLayout()
        buttons_layout.addWidget(self.install_button)
        buttons_layout.addWidget(self.remove_button)
        actions_layout.addLayout(buttons_layout)

        self.load_on_startup_checkbox = QCheckBox(tr("Load AI components on startup"))
        actions_layout.addWidget(self.load_on_startup_checkbox)

        config_group, config_layout, _ = self._create_styled_group(tr("Configuration"))
        model_layout = QHBoxLayout()
        model_label = QLabel(tr("Hugging Face Model:"))
        self.model_name_edit = CustomLineEdit()
        model_layout.addWidget(model_label)
        model_layout.addWidget(self.model_name_edit)
        config_layout.addLayout(model_layout)

        buttons_layout = QHBoxLayout()
        self.load_model_button = CustomButton(None, tr("Load Model"))
        self.load_model_button.clicked.connect(self._on_load_model_clicked)
        self.reset_button = CustomButton(None, tr("Reset to Default"))
        self.reset_button.clicked.connect(self._reset_model_name)
        buttons_layout.addWidget(self.load_model_button)
        buttons_layout.addWidget(self.reset_button)
        config_layout.addLayout(buttons_layout)

        log_group, log_layout, _ = self._create_styled_group(tr("Terminal Output"))

        log_container = QFrame()
        log_container.setObjectName("logOutputContainer")

        log_container.setStyleSheet("""
            QFrame#logOutputContainer {
                border: 1px solid @dialog.border;
                border-radius: 6px;
                background-color: @dialog.input.background;
            }
        """.replace("@dialog.border", self._theme_manager.get_color("dialog.border").name())
           .replace("@dialog.input.background", self._theme_manager.get_color("dialog.input.background").name()))

        container_layout = QVBoxLayout(log_container)
        container_layout.setContentsMargins(5, 5, 5, 5)

        self.log_output = QTextEdit()
        self.log_output.setReadOnly(True)

        self.log_output.setStyleSheet("border: none; background: transparent;")

        self.log_output.setTextInteractionFlags(Qt.TextInteractionFlag.NoTextInteraction)
        self.log_output.viewport().setCursor(Qt.CursorShape.ArrowCursor)

        log_scrollbar = MinimalistScrollBar(self.log_output)
        self.log_output.setVerticalScrollBar(log_scrollbar)
        self.log_output.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)

        self._setup_terminal_styling()

        container_layout.addWidget(self.log_output)

        log_layout.addWidget(log_container)

        main_layout.addWidget(status_group)
        main_layout.addWidget(actions_group)
        main_layout.addWidget(config_group)
        main_layout.addWidget(log_group, 1)

        setup_dialog_scaffold(
            self,
            main_layout,
            ok_text=tr("OK"),
            cancel_text=tr("Close"),
            show_cancel_button=True,
        )
        self.cancel_button.setText(tr("Close"))

        self.load_on_startup_checkbox.setChecked(settings.get("load_on_startup", True))
        self.model_name_edit.setText(
            settings.get(
                "tokenizer_model", self._settings_manager.get_default_tokenizer_model()
            )
        )

        self.model_name_edit.textChanged.connect(self._on_model_name_changed)

        self.set_status(is_installed, is_loaded, model_in_cache=model_in_cache)

        self._update_ui_elements()

        self.repaint()

        auto_size_dialog(self, min_width=500, min_height=450)

    def _reset_model_name(self):
        self.model_name_edit.setText(
            self._settings_manager.get_default_tokenizer_model()
        )

    def set_status(
        self,
        is_installed: bool,
        is_loaded: bool,
        message: str | None = None,
        model_in_cache: bool | None = None,
        loaded_model_name: str | None = None,
    ):
        if model_in_cache is not None:
            self.model_in_cache = model_in_cache

        if loaded_model_name is not None:
            self.loaded_model_name = loaded_model_name

        if message:
            status_text = message
            color = "#FFA500"
        elif is_installed and is_loaded:
            status_text = tr("Installed (active)")
            color = "#00B300"
        elif is_installed and not is_loaded:

            status_text = tr("Installed (model not loaded)")
            color = "#00B300"
        else:
            status_text = tr("Not installed")
            color = "#D70000"

        self.status_label.clear()
        self.status_label.setText(f'<b style="color:{color};">{status_text}</b>')

        self.is_installed = importlib.util.find_spec("transformers") is not None
        self.remove_button.setEnabled(self.is_installed and self.model_in_cache)

        self.loaded_model_label.clear()

        if is_loaded and self.loaded_model_name:
            self.loaded_model_label.setText(
                f'<b style="color:#00B300;">{self.loaded_model_name}</b>'
            )
            self.loaded_model_label.show()
        else:
            model_name = (
                self.model_name_edit.text().strip()
                if hasattr(self, "model_name_edit")
                else ""
            )

            if is_installed and not is_loaded and self.model_in_cache and model_name:
                self.loaded_model_label.setText(
                    f'<b style="color:#00B300;">{model_name} ({tr("in cache")})</b>'
                )
            else:
                self.loaded_model_label.setText(
                    f'<b style="color:#D70000;">{tr("None")}</b>'
                )
            self.loaded_model_label.show()

        self.status_label.repaint()
        self.loaded_model_label.repaint()

    def get_settings(self) -> dict:
        return {
            "load_on_startup": self.load_on_startup_checkbox.isChecked(),
            "tokenizer_model": self.model_name_edit.text().strip(),
        }

    def set_actions_enabled(self, enabled: bool):
        self.install_button.setEnabled(enabled)
        self.remove_button.setEnabled(enabled)
        self.load_model_button.setEnabled(enabled)
        self.ok_button.setEnabled(enabled)

    def _setup_terminal_styling(self):
        """Sets up terminal styling as in main window."""
        try:
            theme_manager = ThemeManager.get_instance()
            info_color = theme_manager.get_color("dialog.text").name()
            error_color = "#D70000" if theme_manager.is_dark() else "#FF0000"
            status_color = "#9E9E9E"

            stylesheet = f"""
            body {{ color: {info_color}; }}
            .info {{ color: {info_color}; }}
            .error {{ color: {error_color}; font-weight: bold; }}
            .status {{ color: {status_color}; }}
            """
            self.log_output.document().setDefaultStyleSheet(stylesheet)

        except Exception:

            stylesheet = """
            body { color: #333; }
            .info { color: #333; }
            .error { color: #FF0000; font-weight: bold; }
            .status { color: #9E9E9E; }
            """
            self.log_output.document().setDefaultStyleSheet(stylesheet)

    def append_log(self, text: str):

        self.log_output.append(text)
        self.log_output.verticalScrollBar().setValue(
            self.log_output.verticalScrollBar().maximum()
        )

    def is_restart_needed(self) -> bool:
        return self._restart_needed

    def on_action_finished(
        self,
        success: bool,
        message: str,
        new_is_installed: bool,
        new_is_loaded: bool,
        model_in_cache: bool = None,
        loaded_model_name: str = None,
    ):

        self.set_status(
            new_is_installed,
            new_is_loaded,
            model_in_cache=model_in_cache,
            loaded_model_name=loaded_model_name,
        )

        self.set_actions_enabled(True)

    def _create_styled_group(self, title_text: str):
        group_widget = QWidget()
        group_widget._title_padding = 15
        group_frame = QFrame(group_widget)
        group_frame.setObjectName("StyledGroupFrame")
        title_label = None
        title_height = 0
        if title_text:
            title_label = QLabel(title_text, group_widget)
            title_label.setObjectName("StyledGroupTitle")
            title_label.adjustSize()
            title_height = title_label.sizeHint().height()
            title_label.move(group_widget._title_padding * 2, 0)

            title_min_width = title_label.width() + group_widget._title_padding * 2 + group_widget._title_padding
            group_widget.setMinimumWidth(title_min_width)
        content_layout = QVBoxLayout(group_frame)
        content_margin_top = int(title_height * 0.8) if title_text else 10
        content_layout.setContentsMargins(10, content_margin_top, 10, 10)
        main_layout = QVBoxLayout(group_widget)
        main_layout.setContentsMargins(group_widget._title_padding, title_height // 2 if title_text else 0, 0, 0)
        main_layout.addWidget(group_frame)
        return group_widget, content_layout, title_label

    def _on_load_model_clicked(self):
        """Handles load model button click."""
        model_name = self.model_name_edit.text().strip()
        if model_name:
            self.load_model_triggered.emit(model_name)
        else:
            self.append_log(tr("Error: Model name cannot be empty"))

    def _on_model_name_changed(self):
        """Handles model name change."""

        self._update_cache_status()

    def _update_cache_status(self):
        """Updates cache status for current model."""
        if not self.is_installed:
            return

        try:
            from core.application.tokenizer_service import TokenizerService

            tokenizer_service = TokenizerService()

            model_name = self.model_name_edit.text().strip()
            if model_name:
                cache_info = tokenizer_service.check_model_cache(model_name)
                model_in_cache = cache_info.get("available", False)
                self.model_in_cache = model_in_cache

                self._update_ui_elements()

                if not self.is_loaded:
                    self.set_status(
                        self.is_installed, self.is_loaded, model_in_cache=model_in_cache
                    )
        except Exception as e:
            pass

    def _update_ui_elements(self):
        """Updates UI elements based on current status."""

        self.remove_button.setEnabled(self.is_installed and self.model_in_cache)

    def mousePressEvent(self, event: QMouseEvent):
        """Removes focus from input fields when clicking on empty area."""
        self.clear_input_focus()
        super().mousePressEvent(event)

    def clear_input_focus(self):
        """Removes focus if it's set on QLineEdit."""
        focused_widget = self.focusWidget()
        if focused_widget and isinstance(focused_widget, QLineEdit):
            focused_widget.clearFocus()

    def refresh_theme_styles(self):
        """Forces dialog styles to update."""
        self.style().unpolish(self)
        self.style().polish(self)
        self.update()
        self.updateGeometry()


--- Файл: ./src/ui/widgets/helpers/underline_painter.py ---
from dataclasses import dataclass
from typing import Optional

from PyQt6.QtCore import QPointF, QRectF, Qt
from PyQt6.QtGui import QColor, QPen
from PyQt6.QtWidgets import QLineEdit

from ui.theme import ThemeManager

@dataclass
class UnderlineConfig:
    thickness: float = 0.15
    vertical_offset: float = 0.75
    arc_radius: float = 1.33
    alpha: Optional[int] = None
    color: Optional[QColor] = None

def draw_bottom_underline(
    painter, rect, theme_manager: ThemeManager, config: UnderlineConfig | None = None
):
    cfg = config or UnderlineConfig()

    widget = painter.device()

    if theme_manager.is_dark():
        if not (widget and isinstance(widget, QLineEdit)):
            return

    prefix = ""
    if widget and hasattr(widget, "property"):
        btn_class = str(widget.property("class") or "")
        prefix = "button.primary" if btn_class == "primary" else "button.default"
    else:

        prefix = "button.default"

    if config is not None and cfg.color is not None:
        edge = QColor(cfg.color)
    else:
        edge = QColor(theme_manager.get_color(f"{prefix}.bottom.edge"))

    if config is not None and cfg.alpha is not None:
        edge.setAlpha(int(cfg.alpha))

    pen_edge = QPen(edge)
    pen_edge.setWidthF(cfg.thickness)
    pen_edge.setCapStyle(Qt.PenCapStyle.FlatCap)

    painter.setPen(pen_edge)

    base_y = float(rect.bottom()) - cfg.vertical_offset
    r = float(cfg.arc_radius)
    left_x = float(rect.left())
    right_x = float(rect.right())

    painter.drawLine(QPointF(left_x + r, base_y), QPointF(right_x - r, base_y))

    left_rect = QRectF(left_x, base_y - 2 * r, 2 * r, 2 * r)
    painter.drawArc(left_rect, 180 * 16, 90 * 16)

    right_rect = QRectF(right_x - 2 * r, base_y - 2 * r, 2 * r, 2 * r)
    painter.drawArc(right_rect, 270 * 16, 90 * 16)


--- Файл: ./src/ui/widgets/atomic/fluent_spinbox.py ---
from enum import Enum
from PyQt6.QtCore import (
    Qt, QSize, pyqtSignal, QRectF, QPointF
)
from PyQt6.QtGui import (
    QPainter, QPen, QBrush, QColor, QFont, QFontMetrics, QPolygonF
)
from PyQt6.QtWidgets import (
    QWidget, QHBoxLayout, QLineEdit, QSizePolicy
)
from ui.theme import ThemeManager
from ui.widgets.helpers.underline_painter import draw_bottom_underline, UnderlineConfig

class FocusLineEdit(QLineEdit):
    focusChanged = pyqtSignal(bool)
    def focusInEvent(self, event):
        super().focusInEvent(event)
        self.focusChanged.emit(True)
    def focusOutEvent(self, event):
        super().focusOutEvent(event)
        self.focusChanged.emit(False)

class _ArrowDirection(Enum):
    UP = 0
    DOWN = 1

class _SpinButton(QWidget):
    clicked = pyqtSignal()
    def __init__(self, direction: _ArrowDirection, parent: QWidget = None):
        super().__init__(parent)
        self.setFixedSize(32, 26)
        self.direction = direction
        self._hovered = False
        self._pressed = False
        self.theme_manager = ThemeManager.get_instance()
        self.theme_manager.theme_changed.connect(self.update)
        self.setSizePolicy(QSizePolicy.Policy.Maximum, QSizePolicy.Policy.Fixed)
        self.setFocusPolicy(Qt.FocusPolicy.NoFocus)

    def enterEvent(self, event): self._hovered = True; self.update()
    def leaveEvent(self, event): self._hovered = False; self.update()
    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton: self._pressed = True; self.update()
    def mouseReleaseEvent(self, event):
        if self._pressed and event.button() == Qt.MouseButton.LeftButton:
            self._pressed = False; self.update()
            if self.rect().contains(event.pos()): self.clicked.emit()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        bg_color = QColor("transparent")
        if self._pressed: bg_color = self.theme_manager.get_color("button.default.background.pressed")
        elif self._hovered: bg_color = self.theme_manager.get_color("button.default.background.hover")
        painter.setPen(Qt.PenStyle.NoPen); painter.setBrush(bg_color); painter.drawRoundedRect(self.rect(), 4, 4)
        arrow_color = self.theme_manager.get_color("dialog.text")
        arrow_color.setAlpha(160)
        painter.setPen(QPen(arrow_color, 1.4))
        center = self.rect().center()
        y_offset = 1.0
        draw_center = QPointF(center.x(), center.y() + y_offset)
        w = self.width() * 0.20
        h = w * 0.5
        if self.direction == _ArrowDirection.UP:
            p1 = QPointF(draw_center.x() - w, draw_center.y() + h / 2)
            p2 = QPointF(draw_center.x(), draw_center.y() - h)
            p3 = QPointF(draw_center.x() + w, draw_center.y() + h / 2)
        else:
            p1 = QPointF(draw_center.x() - w, draw_center.y() - h / 2)
            p2 = QPointF(draw_center.x(), draw_center.y() + h)
            p3 = QPointF(draw_center.x() + w, draw_center.y() - h / 2)
        painter.drawPolyline(QPolygonF([p1, p2, p3]))

class FluentSpinBox(QWidget):
    valueChanged = pyqtSignal(int)
    RADIUS = 6

    def __init__(self, parent: QWidget = None, default_value: int = 30):
        super().__init__(parent)
        self.setFixedHeight(33)
        self.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.theme_manager = ThemeManager.get_instance()
        self._minimum, self._maximum = 0, 99
        self._value = 0
        self._last_accepted_text = "0"

        self._default_value = default_value

        main_layout = QHBoxLayout(self)
        main_layout.setContentsMargins(10, 0, 4, 0); main_layout.setSpacing(4)

        self.line_edit = FocusLineEdit()
        self.line_edit.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.line_edit.setStyleSheet("border: none; background: transparent; padding: 0; margin: 0;")
        self.line_edit.textChanged.connect(self._on_text_changed)
        self.line_edit.editingFinished.connect(self._on_text_edited)
        self.setFocusProxy(self.line_edit)
        self.line_edit.focusChanged.connect(self.update)

        main_layout.addStretch(1)
        main_layout.addWidget(self.line_edit)

        buttons_container = QWidget()
        buttons_layout = QHBoxLayout(buttons_container)
        buttons_layout.setContentsMargins(0, 0, 0, 0); buttons_layout.setSpacing(2)
        self.down_button = _SpinButton(_ArrowDirection.DOWN, self)
        self.up_button = _SpinButton(_ArrowDirection.UP, self)
        buttons_layout.addWidget(self.down_button); buttons_layout.addWidget(self.up_button)
        main_layout.addWidget(buttons_container)

        self.up_button.clicked.connect(self._step_up)
        self.down_button.clicked.connect(self._step_down)

        self.theme_manager.theme_changed.connect(self._on_theme_changed)

        self.setValue(0)
        self._on_theme_changed()

    def setDefaultValue(self, value: int):
        """Allows changing default value after widget creation."""
        self._default_value = value

    def _on_text_edited(self):
        """Finalizes value when focus is lost."""
        current_text = self.line_edit.text().strip()

        if not current_text:
            self.setValue(self._default_value)
            return

        try:
            final_value = int(current_text)
            self.setValue(final_value)
        except (ValueError, TypeError):
            self.setValue(self._value)

    def setValue(self, value: int):
        clamped_value = max(self._minimum, min(value, self._maximum))

        if self._value != clamped_value:
             self._value = clamped_value
             self.valueChanged.emit(self._value)

        new_text = str(clamped_value)
        self._last_accepted_text = new_text

        if self.line_edit.text() != new_text:
            self.line_edit.blockSignals(True)
            self.line_edit.setText(new_text)
            self.line_edit.blockSignals(False)

        self.update()

    def value(self) -> int:
        return self._value

    def _on_text_changed(self, text: str):
        if not text or (text == '-' and self._minimum < 0):
            return
        try:
            value = int(text)
            if self._minimum <= value <= self._maximum:
                self._last_accepted_text = text
            else:
                self._revert_text()
        except ValueError:
            self._revert_text()

    def _revert_text(self):
        self.line_edit.blockSignals(True)
        self.line_edit.setText(self._last_accepted_text)
        self.line_edit.blockSignals(False)

    def _step_up(self):
        self.setValue(self.value() + 1)

    def _step_down(self):
        self.setValue(self.value() - 1)

    def setRange(self, min_val, max_val):
        self._minimum, self._maximum = min_val, max_val
        self.setValue(self.value())
        self._update_line_edit_width()

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton and not self.line_edit.hasFocus():
            self.line_edit.setFocus()
            self.line_edit.selectAll()
        super().mousePressEvent(event)

    def _on_theme_changed(self):
        text_color = self.theme_manager.get_color("dialog.text")
        self.line_edit.setStyleSheet(f"border: none; background: transparent; padding: 0; margin: 0; color: {text_color.name()};")
        self._update_line_edit_width()
        self.update()

    def _update_line_edit_width(self):
        fm = QFontMetrics(self.line_edit.font())
        max_width = fm.horizontalAdvance(str(self._maximum)) + 12
        self.line_edit.setFixedWidth(max_width)

    def focusOutEvent(self, event):
        self._on_text_edited()
        super().focusOutEvent(event)

    def wheelEvent(self, event):
        if not self.isEnabled():
            event.ignore()
            return
        delta = event.angleDelta().y()
        if delta > 0: self._step_up()
        elif delta < 0: self._step_down()
        event.accept()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        bg_color = self.theme_manager.get_color("dialog.input.background")
        painter.setBrush(bg_color); painter.setPen(Qt.PenStyle.NoPen)
        painter.drawRoundedRect(self.rect(), self.RADIUS, self.RADIUS)
        r = self.rect(); rr = QRectF(r).adjusted(0.5, 0.5, -0.5, -0.5)
        thin_border_color = QColor(self.theme_manager.get_color("input.border.thin"))
        alpha = max(8, int(thin_border_color.alpha() * 0.66))
        thin_border_color.setAlpha(alpha); pen = QPen(thin_border_color); pen.setWidthF(0.66)
        painter.setPen(pen); painter.setBrush(Qt.BrushStyle.NoBrush)
        painter.drawRoundedRect(rr, self.RADIUS, self.RADIUS)
        if self.line_edit.hasFocus():
            underline_config = UnderlineConfig(color=self.theme_manager.get_color("accent"), alpha=255, thickness=1.0)
        else:
            underline_config = UnderlineConfig(alpha=40, thickness=1.0)
        draw_bottom_underline(painter, r, self.theme_manager, underline_config)


--- Файл: ./src/ui/widgets/atomic/custom_button.py ---
from typing import Optional

from PyQt6.QtCore import QRectF, QSize, Qt, pyqtSignal
from PyQt6.QtGui import QBrush, QColor, QPainter, QPen
from PyQt6.QtWidgets import QHBoxLayout, QLabel, QWidget

from ui.icon_manager import AppIcon, get_icon
from ui.theme import ThemeManager
from ui.widgets.helpers.underline_painter import UnderlineConfig, draw_bottom_underline

class CustomButton(QWidget):
    clicked = pyqtSignal()

    RADIUS = 6

    def __init__(self, icon: Optional[AppIcon], text: str = "", parent: QWidget = None):
        super().__init__(parent)

        self.setObjectName("CustomButton")
        self.setAttribute(Qt.WidgetAttribute.WA_StyledBackground, True)

        self._override_bg_color: Optional[QColor] = None

        self._icon = icon
        self._icon_size = QSize(16, 16)

        layout = QHBoxLayout(self)
        layout.setSpacing(6)

        self.icon_label = QLabel()
        self.icon_label.setAlignment(Qt.AlignmentFlag.AlignVCenter)

        self.text_label = QLabel(text)
        self.text_label.setAlignment(Qt.AlignmentFlag.AlignVCenter)

        has_icon = self._icon is not None
        has_text = bool(text)

        if has_icon and has_text:
            layout.setContentsMargins(10, 5, 10, 5)
            layout.addStretch(1)
            layout.addWidget(self.icon_label)
            layout.addWidget(self.text_label)
            layout.addStretch(1)
        elif has_icon:
            layout.setContentsMargins(0, 0, 0, 0)
            self.setFixedSize(33, 33)
            self._icon_size = QSize(20, 20)
            self.text_label.hide()
            layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
            layout.addWidget(self.icon_label)

        else:
            layout.setContentsMargins(15, 5, 15, 5)
            self.icon_label.hide()
            layout.addStretch(1)
            layout.addWidget(self.text_label)
            layout.addStretch(1)
        self.setProperty("class", "custom-button")
        self.setProperty("state", "normal")
        self.theme_manager = ThemeManager.get_instance()

        self.theme_manager.theme_changed.connect(self._on_theme_changed)

        self._on_theme_changed()

    def _on_theme_changed(self):
        if self._icon:
            self.icon_label.setPixmap(get_icon(self._icon).pixmap(self._icon_size))

        prefix = self._style_prefix()
        text_color_key = f"{prefix}.text" if "primary" in prefix else "dialog.text"
        text_color = self.theme_manager.get_color(text_color_key)

        self.text_label.setStyleSheet(
            f"color: {text_color.name()}; background: transparent;"
        )

        self.update()

    def set_override_bg_color(self, color: Optional[QColor]):
        if self._override_bg_color != color:
            self._override_bg_color = color
            self.update()

    def setText(self, text):
        self.text_label.setText(text)

        self.text_label.update()
        self.text_label.repaint()
        self.update()
        self.repaint()
        self.layout().invalidate()
        self.updateGeometry()

    def text(self):
        return self.text_label.text()

    def _style_prefix(self) -> str:
        btn_class = str(self.property("class") or "")
        return "button.primary" if "primary" in btn_class else "button.default"

    def enterEvent(self, event):
        if not self.isEnabled():
            return
        self.setProperty("state", "hover")
        self.update()
        super().enterEvent(event)

    def leaveEvent(self, event):
        if not self.isEnabled():
            return
        self.setProperty("state", "normal")
        self.update()
        super().leaveEvent(event)

    def mousePressEvent(self, event):
        if not self.isEnabled():
            return
        self.setProperty("state", "pressed")
        self.update()
        super().mousePressEvent(event)

    def mouseReleaseEvent(self, event):
        self.setProperty(
            "state", "hover" if self.rect().contains(event.pos()) else "normal"
        )
        self.update()
        if not self.isEnabled():
            return
        if (
            self.rect().contains(event.pos())
            and event.button() == Qt.MouseButton.LeftButton
        ):
            self.clicked.emit()
        super().mouseReleaseEvent(event)

    def paintEvent(self, _):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)

        if not self.isEnabled():

            rectf = QRectF(self.rect()).adjusted(0.5, 0.5, -0.5, -0.5)

            border_color = self.theme_manager.get_color("dialog.border")
            fill_color = QColor(border_color)
            fill_color.setAlpha(40)

            painter.setPen(Qt.PenStyle.NoPen)
            painter.setBrush(QBrush(fill_color))
            painter.drawRoundedRect(rectf, self.RADIUS, self.RADIUS)

            text_color = self.theme_manager.get_color("dialog.text")
            disabled_text_color = QColor(text_color)
            disabled_text_color.setAlpha(120)

            painter.setPen(disabled_text_color)
            painter.drawText(
                self.rect(), Qt.AlignmentFlag.AlignCenter, self.text_label.text()
            )
            return

        state = str(self.property("state") or "normal")

        if self._override_bg_color is not None:
            bg = self._override_bg_color
        else:
            prefix = self._style_prefix()
            if state == "hover":
                bg_key = f"{prefix}.background.hover"
            elif state == "pressed":
                bg_key = f"{prefix}.background.pressed"
            else:
                bg_key = f"{prefix}.background"
            bg = QColor(self.theme_manager.get_color(bg_key))

        rectf = QRectF(self.rect()).adjusted(0.5, 0.5, -0.5, -0.5)

        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(QBrush(bg))
        painter.drawRoundedRect(rectf, self.RADIUS, self.RADIUS)

        prefix = self._style_prefix()
        border_color = QColor(self.theme_manager.get_color(f"{prefix}.border"))

        pen_border = QPen(border_color)
        pen_border.setWidthF(1.0)
        painter.setPen(pen_border)
        painter.setBrush(Qt.BrushStyle.NoBrush)
        painter.drawRoundedRect(rectf, self.RADIUS, self.RADIUS)

        draw_bottom_underline(
            painter, self.rect(), self.theme_manager, UnderlineConfig(alpha=255)
        )


--- Файл: ./src/ui/widgets/atomic/drop_zone_label.py ---
from PyQt6.QtCore import pyqtSignal, QTimer
from PyQt6.QtWidgets import QWidget

from ui.widgets.atomic.adaptive_label import AdaptiveLabel

class DropZoneLabel(AdaptiveLabel):
    """A specialized label widget that handles Drag-and-Drop operations correctly."""

    file_dropped = pyqtSignal(str)
    drop_zone_drag_active = pyqtSignal(bool)

    drop_zone_hover_state_changed = pyqtSignal(bool)

    def __init__(self, text: str = "", parent: QWidget | None = None):
        super().__init__(text, parent)

        self.setAcceptDrops(True)
        self.setMouseTracking(True)

    def dragEnterEvent(self, event):
        """Triggers when dragged object enters the widget."""

        if event.source():
            event.ignore()
            return

        if event.mimeData().hasUrls():
            event.acceptProposedAction()
            self.drop_zone_drag_active.emit(True)
        else:
            event.ignore()

    def dragLeaveEvent(self, event):
        """Triggers when dragged object leaves the widget."""
        self.drop_zone_drag_active.emit(False)
        event.accept()

    def dropEvent(self, event):
        """Triggers when file is dropped on the widget."""
        self.drop_zone_drag_active.emit(False)

        if event.source():
            event.ignore()
            return

        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            if urls:
                local_path = urls[0].toLocalFile()

                QTimer.singleShot(0, lambda: self.file_dropped.emit(local_path))
            event.acceptProposedAction()
        else:
            event.ignore()

    def enterEvent(self, event):
        """Triggers when cursor enters the widget (without DnD)."""
        self.drop_zone_hover_state_changed.emit(True)
        super().enterEvent(event)

    def leaveEvent(self, event):
        """Triggers when cursor leaves the widget (without DnD)."""
        self.drop_zone_hover_state_changed.emit(False)
        super().leaveEvent(event)


--- Файл: ./src/ui/widgets/atomic/fluent_checkbox.py ---
from __future__ import annotations

from PyQt6.QtCore import QEvent, QPointF, QPropertyAnimation, QRectF, QSize, Qt, pyqtProperty, QEasingCurve
from PyQt6.QtGui import QBrush, QColor, QFontMetrics, QPainter, QPainterPath, QPen
from PyQt6.QtWidgets import QCheckBox, QSizePolicy, QWidget

from ui.theme import ThemeManager

class FluentCheckBox(QCheckBox):
    INDICATOR_SIZE = 20
    INDICATOR_RADIUS = 4
    OUTLINE_WIDTH = 1
    SPACING = 8
    PADDING_H = 2
    PADDING_V = 5

    CHECK_ROTATION_DEG = -21.0
    CHECK_STROKE_WIDTH = 1.1
    CHECK_X1 = 0.26
    CHECK_Y1_NORM = 0.42
    CHECK_X2 = 0.36
    CHECK_Y2_PRE = 0.63
    CHECK_X3 = 0.82
    CHECK_Y3_PRE = 0.34
    CHECK_BOTTOM_FACTOR = 0.75
    CHECK_TOP_FACTOR = 0.55

    ACTIVE_EDGE_STROKE_ALPHA = 110

    def __init__(self, text: str | None = None, parent=None):
        super().__init__(parent)
        if text:
            self.setText(text)
        self.setMouseTracking(True)

        self.setAttribute(Qt.WidgetAttribute.WA_Hover, True)
        self.setSizePolicy(QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed)

        self._hover_progress = 0.0
        self._checked_progress = 1.0 if self.isChecked() else 0.0

        self._hover_anim = QPropertyAnimation(self, b"hoverProgress", self)
        self._hover_anim.setDuration(120)
        self._hover_anim.setEasingCurve(QEasingCurve.Type.OutCubic)

        self._checked_anim = QPropertyAnimation(self, b"checkedProgress", self)
        self._checked_anim.setDuration(150)
        self._checked_anim.setEasingCurve(QEasingCurve.Type.OutCubic)

        self.stateChanged.connect(self._on_state_changed)
        self._group_parent = None

    def get_hover_progress(self) -> float:
        return self._hover_progress

    def set_hover_progress(self, value: float):
        self._hover_progress = max(0.0, min(1.0, float(value)))
        self.update()

    hoverProgress = pyqtProperty(float, fget=get_hover_progress, fset=set_hover_progress)

    def get_checked_progress(self) -> float:
        return self._checked_progress

    def set_checked_progress(self, value: float):
        self._checked_progress = max(0.0, min(1.0, float(value)))
        self.update()

    checkedProgress = pyqtProperty(float, fget=get_checked_progress, fset=set_checked_progress)

    def _indicator_rect(self, full_rect: QRectF) -> QRectF:
        return QRectF(
            full_rect.x() + self.PADDING_H,
            full_rect.y() + (full_rect.height() - self.INDICATOR_SIZE) / 2,
            self.INDICATOR_SIZE,
            self.INDICATOR_SIZE,
        )

    def _text_rect_available(self, full_rect: QRectF, indicator_rect: QRectF) -> QRectF:
        text_left = indicator_rect.right() + self.SPACING
        available_w = max(0.0, full_rect.width() - (text_left - full_rect.left()) - self.PADDING_H)
        return QRectF(text_left, full_rect.y(), available_w, full_rect.height())

    def _text_rect_content(self, full_rect: QRectF, indicator_rect: QRectF, fm: QFontMetrics) -> QRectF:
        avail = self._text_rect_available(full_rect, indicator_rect)
        text = self.text() or ""
        content_w = min(avail.width(), float(fm.horizontalAdvance(text)))
        return QRectF(avail.left(), avail.top(), content_w, avail.height())

    def event(self, e):

        if e.type() in (QEvent.Type.HoverEnter, QEvent.Type.HoverMove):

            r = QRectF(self.rect())
            ind = self._indicator_rect(r)
            fm = self.fontMetrics()
            tx = self._text_rect_content(r, ind, fm)
            p = e.position()
            hovered = ind.contains(p) or tx.contains(p)

            if hovered and self._hover_progress < 1.0:
                self._animate_hover(True)
            elif (not hovered) and self._hover_progress > 0.0:
                self._animate_hover(False)
            return True

        elif e.type() == QEvent.Type.Leave and self._hover_progress > 0:
            self._animate_hover(False)
            return True

        return super().event(e)

    def showEvent(self, e):
        super().showEvent(e)

        if not self._group_parent:
            self._group_parent = self._find_group_parent()
            if self._group_parent:
                self._group_parent.installEventFilter(self)

    def eventFilter(self, watched_object, event):

        if watched_object == self._group_parent and event.type() == QEvent.Type.Leave:
            if self._hover_progress > 0:
                self._animate_hover(False)

        return super().eventFilter(watched_object, event)

    def _find_group_parent(self) -> QWidget | None:
        """Traverses up the widget hierarchy to find a CustomGroupWidget."""
        parent = self.parent()
        while parent:

            if parent.__class__.__name__ == 'CustomGroupWidget':
                return parent
            parent = parent.parent()
        return None

    def mouseReleaseEvent(self, e):
        if e.button() == Qt.MouseButton.LeftButton:
            r = QRectF(self.rect())
            ind = self._indicator_rect(r)
            fm = self.fontMetrics()
            tx = self._text_rect_content(r, ind, fm)

            if ind.contains(e.position()) or tx.contains(e.position()):
                self.setChecked(not self.isChecked())
                e.accept()
                return

        super().mouseReleaseEvent(e)

    def focusInEvent(self, e):
        self.update()
        super().focusInEvent(e)

    def focusOutEvent(self, e):
        self.update()
        super().focusOutEvent(e)

    def changeEvent(self, e):
        self.update()
        super().changeEvent(e)

    def _on_state_changed(self, _):

        target = 1.0 if self.checkState() != Qt.CheckState.Unchecked else 0.0
        self._checked_anim.stop()
        self._checked_anim.setStartValue(self._checked_progress)
        self._checked_anim.setEndValue(target)
        self._checked_anim.start()

    def _animate_hover(self, hovered: bool):
        self._hover_anim.stop()
        self._hover_anim.setStartValue(self._hover_progress)
        self._hover_anim.setEndValue(1.0 if hovered else 0.0)
        self._hover_anim.start()

    def sizeHint(self) -> QSize:
        fm = QFontMetrics(self.font())
        text_width = fm.horizontalAdvance(self.text()) if self.text() else 0
        h = max(self.INDICATOR_SIZE + 2 * self.PADDING_V, fm.height() + 2 * self.PADDING_V)
        w = self.PADDING_H + self.INDICATOR_SIZE + (self.SPACING if text_width else 0) + text_width + self.PADDING_H
        return QSize(w, h)

    def minimumSizeHint(self) -> QSize:
        return self.sizeHint()

    def paintEvent(self, _):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing, True)

        rect = QRectF(self.rect())
        fm = QFontMetrics(self.font())
        indicator_rect = self._indicator_rect(rect)
        text_rect_avail = self._text_rect_available(rect, indicator_rect)

        theme = ThemeManager.get_instance()
        accent = theme.get_color("accent")
        border = theme.get_color("dialog.border")
        text_color = theme.get_color("dialog.text")
        neutral_hover = theme.get_color("dialog.button.hover")
        disabled_alpha = 110

        is_disabled = not self.isEnabled()
        is_checked = self.checkState() == Qt.CheckState.Checked
        is_indeterminate = self.checkState() == Qt.CheckState.PartiallyChecked

        if is_checked or is_indeterminate:

            border_color = border if not is_disabled else QColor(border.red(), border.green(), border.blue(), disabled_alpha)
            painter.setPen(QPen(border_color, self.OUTLINE_WIDTH))
            accent_fill = QColor(accent)

            base_alpha = int(120 + 135 * self._checked_progress)
            if is_disabled:
                base_alpha = int(base_alpha * 0.6)
            accent_fill.setAlpha(max(0, min(255, base_alpha)))
            painter.setBrush(QBrush(accent_fill))
            painter.drawRoundedRect(indicator_rect, self.INDICATOR_RADIUS, self.INDICATOR_RADIUS)
        else:

            painter.setPen(QPen(border if not is_disabled else QColor(border.red(), border.green(), border.blue(), disabled_alpha), self.OUTLINE_WIDTH))
            if self._hover_progress > 0.001 and not is_disabled:
                hover_fill = QColor(neutral_hover)
                alpha = int(40 + 100 * self._hover_progress)
                hover_fill.setAlpha(max(0, min(255, alpha)))
                painter.setBrush(QBrush(hover_fill))
            else:
                painter.setBrush(Qt.BrushStyle.NoBrush)
            painter.drawRoundedRect(indicator_rect, self.INDICATOR_RADIUS, self.INDICATOR_RADIUS)

        if is_checked or is_indeterminate:
            glyph_color = QColor(Qt.GlobalColor.white)
            if is_disabled:
                glyph_color.setAlpha(disabled_alpha)

            if is_checked:
                painter.save()
                center = indicator_rect.center()
                painter.translate(center)
                painter.rotate(self.CHECK_ROTATION_DEG)
                painter.translate(-center)

                painter.setPen(QPen(glyph_color, self.CHECK_STROKE_WIDTH, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap, Qt.PenJoinStyle.MiterJoin))

                x1 = indicator_rect.left() + indicator_rect.width() * self.CHECK_X1
                y1 = indicator_rect.top() + indicator_rect.height() * self.CHECK_Y1_NORM
                x2 = indicator_rect.left() + indicator_rect.width() * self.CHECK_X2
                y2_pre = indicator_rect.top() + indicator_rect.height() * self.CHECK_Y2_PRE
                x3 = indicator_rect.left() + indicator_rect.width() * self.CHECK_X3
                y3_pre = indicator_rect.top() + indicator_rect.height() * self.CHECK_Y3_PRE

                cx = indicator_rect.center().y()
                y2 = cx + self.CHECK_BOTTOM_FACTOR * (y2_pre - cx)
                y3 = cx + self.CHECK_TOP_FACTOR * (y3_pre - cx)

                p1 = QPointF(x1, y1)
                p2 = QPointF(x2, y2)
                p3 = QPointF(x3, y3)
                path = QPainterPath()
                path.moveTo(p1)
                path.lineTo(p2)
                path.lineTo(p3)
                painter.drawPath(path)
                painter.restore()
            else:
                painter.setPen(QPen(glyph_color, self.CHECK_STROKE_WIDTH, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap, Qt.PenJoinStyle.MiterJoin))
                line_margin = indicator_rect.height() * 0.32
                y = indicator_rect.center().y()
                x1 = indicator_rect.left() + line_margin
                x2 = indicator_rect.right() - line_margin
                painter.drawLine(QPointF(x1, y), QPointF(x2, y))

        if self.text():
            painter.setPen(QPen(QColor(text_color) if not is_disabled else QColor(text_color.red(), text_color.green(), text_color.blue(), disabled_alpha)))

            elided = fm.elidedText(self.text(), Qt.TextElideMode.ElideRight, int(text_rect_avail.width()))
            painter.drawText(text_rect_avail, int(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft), elided)

        painter.end()


--- Файл: ./src/ui/widgets/atomic/fluent_radio.py ---
from __future__ import annotations

from PyQt6.QtCore import (
    QEvent,
    QPropertyAnimation,
    QEasingCurve,
    QRectF,
    QSize,
    Qt,
    pyqtProperty,
)
from PyQt6.QtGui import QBrush, QColor, QFontMetrics, QPainter, QPainterPath, QPen
from PyQt6.QtWidgets import QRadioButton, QSizePolicy, QWidget

from ui.theme import ThemeManager

class FluentRadioButton(QRadioButton):
    INDICATOR_SIZE = 20
    OUTLINE_WIDTH = 1
    SPACING = 8
    PADDING_H = 2
    PADDING_V = 5

    INNER_HOLE_FACTOR_BASE = 0.50
    INNER_HOLE_FACTOR_HOVER = 0.60

    def __init__(self, text: str | None = None, parent=None):
        super().__init__(parent)
        if text:
            self.setText(text)
        self.setMouseTracking(True)
        self.setAttribute(Qt.WidgetAttribute.WA_Hover, True)

        self.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Fixed)

        self._hover_progress = 0.0

        self._hover_anim = QPropertyAnimation(self, b"hoverProgress", self)
        self._hover_anim.setDuration(120)
        self._hover_anim.setEasingCurve(QEasingCurve.Type.OutCubic)

        self.theme_manager = ThemeManager.get_instance()
        try:
            self.theme_manager.theme_changed.connect(self.update)
        except Exception:
            pass

        self.toggled.connect(self._on_toggled)
        self._group_parent = None

    def get_hover_progress(self) -> float:
        return self._hover_progress

    def set_hover_progress(self, value: float):
        self._hover_progress = max(0.0, min(1.0, float(value)))
        self.update()

    hoverProgress = pyqtProperty(
        float, fget=get_hover_progress, fset=set_hover_progress
    )

    def _indicator_rect(self, full_rect: QRectF) -> QRectF:
        return QRectF(
            full_rect.x() + self.PADDING_H,
            full_rect.y() + (full_rect.height() - self.INDICATOR_SIZE) / 2,
            self.INDICATOR_SIZE,
            self.INDICATOR_SIZE,
        )

    def _text_rect_available(self, full_rect: QRectF, indicator_rect: QRectF) -> QRectF:
        text_left = indicator_rect.right() + self.SPACING
        available_w = max(
            0.0, full_rect.width() - (text_left - full_rect.left()) - self.PADDING_H
        )
        return QRectF(text_left, full_rect.y(), available_w, full_rect.height())

    def _text_rect_content(
        self, full_rect: QRectF, indicator_rect: QRectF, fm: QFontMetrics
    ) -> QRectF:
        avail = self._text_rect_available(full_rect, indicator_rect)
        text = self.text() or ""
        content_w = min(avail.width(), float(fm.horizontalAdvance(text)))
        return QRectF(avail.left(), avail.top(), content_w, avail.height())

    def event(self, e):

        if e.type() in (QEvent.Type.HoverEnter, QEvent.Type.HoverMove):

            r = QRectF(self.rect())
            ind = self._indicator_rect(r)
            fm = self.fontMetrics()
            tx = self._text_rect_content(r, ind, fm)
            p = e.position()
            hovered = ind.contains(p) or tx.contains(p)

            if hovered and self._hover_progress < 1.0:
                self._animate_hover(True)
            elif (not hovered) and self._hover_progress > 0.0:
                self._animate_hover(False)
            return True

        elif e.type() == QEvent.Type.Leave and self._hover_progress > 0:
            self._animate_hover(False)
            return True

        return super().event(e)

    def showEvent(self, e):
        super().showEvent(e)

        if not self._group_parent:
            self._group_parent = self._find_group_parent()
            if self._group_parent:
                self._group_parent.installEventFilter(self)

    def eventFilter(self, watched_object, event):

        if watched_object == self._group_parent and event.type() == QEvent.Type.Leave:
            if self._hover_progress > 0:
                self._animate_hover(False)

        return super().eventFilter(watched_object, event)

    def _find_group_parent(self) -> QWidget | None:
        """Traverses up the widget hierarchy to find a CustomGroupWidget."""
        parent = self.parent()
        while parent:
            if parent.__class__.__name__ == 'CustomGroupWidget':
                return parent
            parent = parent.parent()
        return None

    def mouseReleaseEvent(self, e):
        if e.button() == Qt.MouseButton.LeftButton:

            r = QRectF(self.rect())
            ind = self._indicator_rect(r)
            fm = self.fontMetrics()
            tx = self._text_rect_content(r, ind, fm)

            if ind.contains(e.position()) or tx.contains(e.position()):

                self.setChecked(True)
                e.accept()
                return

        super().mouseReleaseEvent(e)

    def _on_toggled(self, checked: bool):
        if not checked:
            self._hover_anim.stop()
            self.set_hover_progress(0.0)

    def enterEvent(self, e):

        super().enterEvent(e)

    def leaveEvent(self, e):
        super().leaveEvent(e)

    def focusInEvent(self, e):
        self.update()
        super().focusInEvent(e)

    def focusOutEvent(self, e):
        self.update()
        super().focusOutEvent(e)

    def changeEvent(self, e):
        self.update()
        super().changeEvent(e)

    def _animate_hover(self, hovered: bool):
        self._hover_anim.stop()
        self._hover_anim.setStartValue(self._hover_progress)
        self._hover_anim.setEndValue(1.0 if hovered else 0.0)
        self._hover_anim.start()

    def sizeHint(self) -> QSize:
        fm = QFontMetrics(self.font())
        text_width = fm.horizontalAdvance(self.text()) if self.text() else 0

        extra = 4
        h = max(
            self.INDICATOR_SIZE + 2 * self.PADDING_V, fm.height() + 2 * self.PADDING_V
        )
        w = (
            self.PADDING_H
            + self.INDICATOR_SIZE
            + (self.SPACING if text_width else 0)
            + text_width
            + self.PADDING_H
            + extra
        )
        return QSize(w, h)

    def minimumSizeHint(self) -> QSize:
        return self.sizeHint()

    def paintEvent(self, _):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing, True)

        rect = QRectF(self.rect())
        fm = QFontMetrics(self.font())

        indicator_rect = self._indicator_rect(rect)
        text_rect_avail = self._text_rect_available(rect, indicator_rect)
        text_rect = self._text_rect_content(rect, indicator_rect, fm)

        theme = self.theme_manager
        accent = theme.get_color("accent")
        border = theme.get_color("dialog.border")
        text_color = theme.get_color("dialog.text")
        neutral_hover = theme.get_color("dialog.button.hover")
        disabled_alpha = 110

        is_disabled = not self.isEnabled()
        is_checked = self.isChecked()

        center = indicator_rect.center()
        radius = indicator_rect.width() / 2.0

        if is_checked:
            inner_factor = (
                self.INNER_HOLE_FACTOR_BASE
                + (self.INNER_HOLE_FACTOR_HOVER - self.INNER_HOLE_FACTOR_BASE)
                * self._hover_progress
            )
            inner_r = radius * inner_factor

            path = QPainterPath()
            path.addEllipse(center, radius, radius)
            path.addEllipse(center, inner_r, inner_r)
            path.setFillRule(Qt.FillRule.OddEvenFill)

            fill_color = QColor(accent)
            if is_disabled:
                fill_color.setAlpha(disabled_alpha)
            painter.setPen(Qt.PenStyle.NoPen)
            painter.setBrush(QBrush(fill_color))
            painter.drawPath(path)

            border_color = (
                border
                if not is_disabled
                else QColor(border.red(), border.green(), border.blue(), disabled_alpha)
            )
            painter.setPen(QPen(border_color, self.OUTLINE_WIDTH))
            painter.setBrush(Qt.BrushStyle.NoBrush)
            painter.drawEllipse(center, radius, radius)
        else:
            border_color = (
                border
                if not is_disabled
                else QColor(border.red(), border.green(), border.blue(), disabled_alpha)
            )
            painter.setPen(QPen(border_color, self.OUTLINE_WIDTH))
            if self._hover_progress > 0.001 and not is_disabled:
                hover_fill = QColor(neutral_hover)
                alpha = int(40 + 100 * self._hover_progress)
                hover_fill.setAlpha(max(0, min(255, alpha)))
                painter.setBrush(QBrush(hover_fill))
            else:
                painter.setBrush(Qt.BrushStyle.NoBrush)
            painter.drawEllipse(center, radius, radius)

        if self.text():
            painter.setPen(
                QPen(
                    QColor(text_color)
                    if not is_disabled
                    else QColor(
                        text_color.red(),
                        text_color.green(),
                        text_color.blue(),
                        disabled_alpha,
                    )
                )
            )
            full_text = self.text()

            if fm.horizontalAdvance(full_text) > text_rect_avail.width():
                full_text = fm.elidedText(
                    full_text, Qt.TextElideMode.ElideRight, int(text_rect_avail.width())
                )

                draw_rect = text_rect_avail
            else:
                draw_rect = text_rect
            painter.drawText(
                draw_rect,
                int(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft),
                full_text,
            )

        painter.end()


--- Файл: ./src/ui/widgets/atomic/fluent_switch.py ---
from __future__ import annotations

from PyQt6.QtCore import (
    QEasingCurve,
    QPropertyAnimation,
    QEvent,
    QRectF,
    QSize,
    Qt,
    pyqtProperty,
    pyqtSignal,
)
from PyQt6.QtGui import QBrush, QColor, QFontMetrics, QPainter, QPen
from PyQt6.QtWidgets import QSizePolicy, QWidget

from ui.theme import ThemeManager
from resources.translations import tr

class FluentSwitch(QWidget):
    checkedChanged = pyqtSignal(bool)
    toggled = checkedChanged

    TRACK_WIDTH = 44
    TRACK_HEIGHT = 22
    KNOB_DIAMETER = 12
    PADDING = 2
    KNOB_MARGIN = 2

    TEXT_SPACING = 6

    TRACK_RADIUS = TRACK_HEIGHT // 2

    def __init__(self, parent: QWidget | None = None):
        super().__init__(parent)
        self.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.setMouseTracking(True)

        self._theme = ThemeManager.get_instance()
        self._checked: bool = False
        self._hover: float = 0.0
        self._progress: float = 0.0

        self._show_text: bool = True
        self._on_text_key: str = "On"
        self._off_text_key: str = "Off"
        self._translated_on_text: str = ""
        self._translated_off_text: str = ""

        self._anim = QPropertyAnimation(self, b"progress", self)
        self._anim.setDuration(160)
        self._anim.setEasingCurve(QEasingCurve.Type.OutCubic)

        self._hover_anim = QPropertyAnimation(self, b"hover", self)
        self._hover_anim.setDuration(120)
        self._hover_anim.setEasingCurve(QEasingCurve.Type.OutCubic)

        self._theme.theme_changed.connect(self.update)

        self.retranslate_ui()
        self._group_parent = None

    def get_progress(self) -> float:
        return self._progress

    def set_progress(self, v: float):
        self._progress = max(0.0, min(1.0, float(v)))
        self.update()

    progress = pyqtProperty(float, fget=get_progress, fset=set_progress)

    def get_hover(self) -> float:
        return self._hover

    def set_hover(self, v: float):
        self._hover = max(0.0, min(1.0, float(v)))
        self.update()

    hover = pyqtProperty(float, fget=get_hover, fset=set_hover)

    def isChecked(self) -> bool:
        return self._checked

    def setChecked(self, checked: bool):
        checked = bool(checked)
        if self._checked == checked:
            return
        self._checked = checked
        self._animate_to_state(checked)

        if checked and self._hover > 0.01:
            self._animate_hover(False)

        self.checkedChanged.emit(checked)

    def retranslate_ui(self):
        """Updates widget texts according to current language."""
        self._translated_on_text = tr(self._on_text_key)
        self._translated_off_text = tr(self._off_text_key)
        self.updateGeometry()
        self.update()

    def set_state_texts(self, on_text: str, off_text: str):
        if on_text != self._on_text_key or off_text != self._off_text_key:
            self._on_text_key = str(on_text)
            self._off_text_key = str(off_text)
            self.retranslate_ui()

    def set_show_state_text(self, show: bool):
        if bool(show) != self._show_text:
            self._show_text = bool(show)
            self.updateGeometry()
            self.update()

    def sizeHint(self) -> QSize:
        base_w = self.TRACK_WIDTH
        base_h = self.TRACK_HEIGHT
        if self._show_text:
            fm = QFontMetrics(self.font())

            text_w = max(fm.horizontalAdvance(self._translated_on_text), fm.horizontalAdvance(self._translated_off_text))
            base_w += self.TEXT_SPACING + text_w

            base_h = max(base_h, fm.height())
        return QSize(base_w, base_h)

    def mousePressEvent(self, e):
        if e.button() == Qt.MouseButton.LeftButton:
            e.accept()
        else:
            super().mousePressEvent(e)

    def mouseReleaseEvent(self, e):
        if e.button() == Qt.MouseButton.LeftButton and self.rect().contains(e.pos()):
            self.setChecked(not self._checked)
            e.accept()
        else:
            super().mouseReleaseEvent(e)

    def enterEvent(self, e):
        if not self._checked:
            self._animate_hover(True)
        super().enterEvent(e)

    def leaveEvent(self, e):
        if not self._checked:
            self._animate_hover(False)
        super().leaveEvent(e)

    def showEvent(self, e):
        super().showEvent(e)

        if not self._group_parent:
            self._group_parent = self._find_group_parent()
            if self._group_parent:
                self._group_parent.installEventFilter(self)

    def eventFilter(self, watched_object, event):

        if watched_object == self._group_parent and event.type() == QEvent.Type.Leave:
            if self._hover > 0 and not self._checked:
                self._animate_hover(False)

        return super().eventFilter(watched_object, event)

    def _find_group_parent(self) -> QWidget | None:
        """Traverses up the widget hierarchy to find a CustomGroupWidget."""
        parent = self.parent()
        while parent:

            if parent.__class__.__name__ == 'CustomGroupWidget':
                return parent
            parent = parent.parent()
        return None

    def paintEvent(self, _):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)

        accent = self._theme.get_color("accent")

        track_on = accent
        track_off = QColor(0, 0, 0, 0)
        track_hover_overlay = self._theme.get_color("dialog.button.hover")
        track_hover_overlay.setAlpha(int(100 * self._hover))

        knob_on = self._theme.get_color("switch.knob.on")
        knob_off = self._theme.get_color("switch.knob.off")
        knob_border = self._theme.get_color("switch.knob.border")

        w = self.width()
        h = self.height()

        fm = QFontMetrics(self.font())
        text = self._translated_on_text if self._checked else self._translated_off_text
        text_w = fm.horizontalAdvance(text) if self._show_text else 0
        track_w = self.TRACK_WIDTH
        track_h = self.TRACK_HEIGHT
        track_rect = QRectF(0, (h - track_h) / 2.0, float(track_w), float(track_h))
        radius = track_rect.height() / 2.0

        track_color = self._lerp_color(track_off, track_on, self._progress)
        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(QBrush(track_color))
        fill_rect = track_rect.adjusted(0.5, 0.5, -0.5, -0.5)
        painter.drawRoundedRect(fill_rect, radius - 0.5, radius - 0.5)

        if self._hover > 0.01 and not self._checked:
            painter.setBrush(QBrush(track_hover_overlay))
            painter.drawRoundedRect(fill_rect, radius - 0.5, radius - 0.5)

        if not self._checked:
            border_color = self._theme.get_color("switch.track.off.border")
            pen = QPen(border_color)
            pen.setWidthF(1.0)
            painter.setPen(pen)
            painter.setBrush(Qt.BrushStyle.NoBrush)
            painter.drawRoundedRect(
                track_rect.adjusted(0.5, 0.5, -0.5, -0.5), radius, radius
            )

        knob_d = self.KNOB_DIAMETER
        x_min = self.PADDING + self.KNOB_MARGIN
        x_max = track_rect.width() - self.PADDING - self.KNOB_MARGIN - knob_d
        x = x_min + (x_max - x_min) * self._progress
        y = track_rect.top() + (track_rect.height() - knob_d) / 2.0

        knob_rect = QRectF(x, y, float(knob_d), float(knob_d))
        knob_color = self._lerp_color(knob_off, knob_on, self._progress)
        painter.setBrush(QBrush(knob_color))
        painter.setPen(QPen(knob_border, 1))
        painter.drawEllipse(knob_rect)

        if self._show_text and text_w > 0:
            text_color = self._theme.get_color("switch.text")
            painter.setPen(QPen(text_color))
            text_x = int(track_rect.right()) + self.TEXT_SPACING
            text_y = int((h + fm.ascent() - fm.descent()) / 2)
            painter.drawText(text_x, text_y, text)

    @staticmethod
    def _lerp(a: float, b: float, t: float) -> float:
        return a + (b - a) * t

    @classmethod
    def _lerp_color(cls, c1: QColor, c2: QColor, t: float) -> QColor:
        return QColor(
            int(cls._lerp(c1.red(), c2.red(), t)),
            int(cls._lerp(c1.green(), c2.green(), t)),
            int(cls._lerp(c1.blue(), c2.blue(), t)),
            int(cls._lerp(c1.alpha(), c2.alpha(), t)),
        )

    def _animate_to_state(self, checked: bool):
        target = 1.0 if checked else 0.0
        self._anim.stop()
        self._anim.setStartValue(self._progress)
        self._anim.setEndValue(target)
        self._anim.start()

        if not checked and self.underMouse():
            self._animate_hover(True)

    def _animate_hover(self, on: bool):
        self._hover_anim.stop()
        self._hover_anim.setStartValue(self._hover)
        self._hover_anim.setEndValue(1.0 if on else 0.0)
        self._hover_anim.start()


--- Файл: ./src/ui/widgets/atomic/adaptive_label.py ---
"""
Adaptive label with automatic text truncation.

Solves the problem of text going beyond boundaries when resizing the window.
"""

from PyQt6.QtCore import Qt
from PyQt6.QtGui import QFontMetrics
from PyQt6.QtWidgets import QLabel, QSizePolicy

class AdaptiveLabel(QLabel):
    """Label with automatic text truncation when space is insufficient."""

    def __init__(self, text="", parent=None):
        super().__init__(text, parent)
        self._original_text = text
        self._min_width = 50
        self._preferred_width_cache = None

        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)

        self.setMinimumWidth(self._min_width)

    def setText(self, text):
        """Sets text and saves original."""
        self._original_text = text
        self._preferred_width_cache = None
        super().setText(text)
        self._update_text()

        self.updateGeometry()

    def setMinimumWidth(self, width):
        """Sets minimum width."""
        self._min_width = width
        super().setMinimumWidth(width)

    def resizeEvent(self, event):
        """Handles size change."""
        super().resizeEvent(event)
        self._update_text()

    def _update_text(self):
        """Updates displayed text considering available width."""
        if not self._original_text:
            return

        available_width = self.width() - 10
        if available_width <= 0:
            return

        font_metrics = QFontMetrics(self.font())

        if font_metrics.horizontalAdvance(self._original_text) <= available_width:
            super().setText(self._original_text)
            return

        elided_text = font_metrics.elidedText(
            self._original_text, Qt.TextElideMode.ElideRight, available_width
        )
        super().setText(elided_text)

    def sizeHint(self):
        """Returns preferred size."""
        hint = super().sizeHint()

        if self._preferred_width_cache is None:
            font_metrics = QFontMetrics(self.font())
            self._preferred_width_cache = (
                font_metrics.horizontalAdvance(self._original_text) + 10
            )

        hint.setWidth(max(self._preferred_width_cache, self._min_width))
        return hint

    def minimumSizeHint(self):
        """Returns minimum size."""
        hint = super().minimumSizeHint()
        hint.setWidth(self._min_width)
        return hint

    def get_original_text(self):
        """Returns original (untruncated) text."""
        return self._original_text

    def invalidate_size_cache(self):
        """Resets size cache (useful when changing font/theme)."""
        self._preferred_width_cache = None
        self.updateGeometry()

class GroupTitleLabel(AdaptiveLabel):
    """Special label for group titles with border update support."""

    def __init__(self, text="", parent=None):
        super().__init__(text, parent)
        self._group_widget = None
        self.setObjectName("StyledGroupTitle")

    def set_group_widget(self, group_widget):
        """Links label to group widget for size updates."""
        self._group_widget = group_widget

    def setText(self, text):
        """Sets text and updates group sizes."""
        super().setText(text)
        self._update_group_size()

    def resizeEvent(self, event):
        """Handles size change and updates group."""
        super().resizeEvent(event)
        self._update_group_size()

    def _update_group_size(self):
        """Updates group minimum width to fit new title size."""
        if self._group_widget and self._original_text:
            font_metrics = QFontMetrics(self.font())
            text_width = font_metrics.horizontalAdvance(self._original_text)
            min_width = text_width + 40

            self._group_widget.setMinimumWidth(min_width)

            self.adjustSize()
            self.move(25, 0)

            self._group_widget.updateGeometry()
            self._group_widget.update()

            if self._group_widget.parent():
                parent_layout = self._group_widget.parent().layout()
                if parent_layout:
                    parent_layout.invalidate()
                    parent_layout.activate()

class CompactLabel(AdaptiveLabel):
    """Compact label for options with minimal margins."""

    def __init__(self, text="", parent=None):
        super().__init__(text, parent)
        self._min_width = 80
        self.setMinimumWidth(self._min_width)

        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)


--- Файл: ./src/ui/widgets/atomic/time_line_edit.py ---
from PyQt6.QtCore import QRectF, Qt, QTime, pyqtSignal, QEvent
from PyQt6.QtGui import QColor, QPainter, QPen
from PyQt6.QtWidgets import QHBoxLayout, QTimeEdit, QWidget

from ui.theme import ThemeManager
from ui.widgets.helpers.underline_painter import UnderlineConfig, draw_bottom_underline

class TimeLineEdit(QWidget):
    RADIUS = 6
    textChanged = pyqtSignal(str)
    editingFinished = pyqtSignal()

    def __init__(self, initial_time: str = "00:05", parent=None):
        super().__init__(parent)

        self.theme_manager = ThemeManager.get_instance()
        self.theme_manager.theme_changed.connect(self.update)

        self._time_edit = QTimeEdit(self)

        self._time_edit.setStyleSheet(
            """
            QTimeEdit {
                border: none;
                background: transparent;
                padding: 6px 2px;
                font-size: 10pt;
            }
            QTimeEdit::up-button, QTimeEdit::down-button {
                width: 0px;
                border: none;
            }
        """
        )

        self._time_edit.setAlignment(Qt.AlignmentFlag.AlignCenter)

        self._time_edit.setDisplayFormat("HH:mm")

        self._time_edit.setTime(QTime.fromString(initial_time, "HH:mm"))

        self._time_edit.timeChanged.connect(self._on_internal_time_changed)
        self._time_edit.editingFinished.connect(self.editingFinished)

        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(self._time_edit)

        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.setFocusProxy(self._time_edit)

        self._time_edit.installEventFilter(self)

    def eventFilter(self, obj, event):
        """Tracks focus events for internal QTimeEdit."""
        if obj is self._time_edit:
            if event.type() == QEvent.Type.FocusIn or event.type() == QEvent.Type.FocusOut:
                self.update()
        return super().eventFilter(obj, event)

    def _on_internal_time_changed(self, time_obj: QTime):
        """Slot adapter for converting QTime to string."""
        self.textChanged.emit(time_obj.toString("HH:mm"))

    def text(self) -> str:
        """Returns current time as 'HH:mm' string."""
        return self._time_edit.time().toString("HH:mm")

    def setText(self, text: str):
        """Sets time from 'HH:mm' string."""
        time_obj = QTime.fromString(text, "HH:mm")
        if time_obj.isValid():
            self._time_edit.setTime(time_obj)

    def selectAll(self):
        """Selects all text. QTimeEdit does this by sections, we select the first one."""
        self._time_edit.setCurrentSection(QTimeEdit.Section.HourSection)

    def paintEvent(self, e):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)

        bg_color = self.theme_manager.get_color("dialog.input.background")
        painter.setBrush(bg_color)
        painter.setPen(QColor("transparent"))
        painter.drawRoundedRect(self.rect(), self.RADIUS, self.RADIUS)

        rr = QRectF(self.rect()).adjusted(0.5, 0.5, -0.5, -0.5)
        thin_border_color = QColor(self.theme_manager.get_color("input.border.thin"))
        alpha = max(8, int(thin_border_color.alpha() * 0.66))
        thin_border_color.setAlpha(alpha)
        pen = QPen(thin_border_color)
        pen.setWidthF(0.66)
        painter.setPen(pen)
        painter.setBrush(QColor("transparent"))
        painter.drawRoundedRect(rr, self.RADIUS, self.RADIUS)

        if self._time_edit.hasFocus():
            underline_config = UnderlineConfig(color=self.theme_manager.get_color("accent"), alpha=255, thickness=1.0)
        else:
            underline_config = UnderlineConfig(alpha=120, thickness=1.0)

        draw_bottom_underline(
            painter, self.rect(), self.theme_manager, underline_config
        )


--- Файл: ./src/ui/widgets/atomic/loading_spinner.py ---
from PyQt6.QtCore import QPointF, Qt, QTimer
from PyQt6.QtGui import QColor, QConicalGradient, QPainter, QPainterPath
from PyQt6.QtWidgets import QWidget

from ui.theme import ThemeManager

class LoadingSpinner(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.theme_manager = ThemeManager.get_instance()
        self._angle = 0
        self._timer = QTimer(self)
        self._timer.timeout.connect(self._tick)
        self.setFixedSize(40, 40)

    def start(self):
        if not self._timer.isActive():
            self._timer.start(15)

    def stop(self):
        if self._timer.isActive():
            self._timer.stop()

    def _tick(self):
        self._angle = (self._angle + 6) % 360
        self.update()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)

        center = QPointF(self.rect().center())
        radius = min(self.width(), self.height()) / 2.0

        gradient = QConicalGradient(center, float(-self._angle))

        accent_color = self.theme_manager.get_color("accent")
        transparent_color = QColor(accent_color)
        transparent_color.setAlpha(0)

        gradient.setColorAt(0.0, accent_color)
        gradient.setColorAt(0.1, accent_color)
        gradient.setColorAt(0.8, transparent_color)
        gradient.setColorAt(1.0, transparent_color)

        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(gradient)

        path = QPainterPath()
        outer_radius = radius - 2
        inner_radius = radius - 8
        path.addEllipse(center, outer_radius, outer_radius)
        path.addEllipse(center, inner_radius, inner_radius)
        path.setFillRule(Qt.FillRule.OddEvenFill)

        painter.drawPath(path)


--- Файл: ./src/ui/widgets/atomic/custom_line_edit.py ---
from PyQt6.QtCore import QRectF, Qt
from PyQt6.QtGui import QColor, QPainter, QPainterPath, QPen, QRegion
from PyQt6.QtWidgets import QLineEdit

from ui.theme import ThemeManager
from ui.widgets.helpers.underline_painter import UnderlineConfig, draw_bottom_underline

class CustomLineEdit(QLineEdit):
    RADIUS = 6

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAttribute(Qt.WidgetAttribute.WA_StyledBackground, True)

        self.setProperty("custom-line-edit", True)

        self.setProperty("class", "primary")
        self.theme_manager = ThemeManager.get_instance()
        try:
            self.theme_manager.theme_changed.connect(self.update)
        except Exception:
            pass

    def _style_prefix(self) -> str:
        btn_class = str(self.property("class") or "")
        return "button.primary" if "primary" in btn_class else "button.default"

    def focusInEvent(self, e):
        super().focusInEvent(e)
        self.update()

    def focusOutEvent(self, e):
        super().focusOutEvent(e)
        self.update()

    def resizeEvent(self, e):
        try:
            w, h = self.width(), self.height()
            if w <= 0 or h <= 0:
                self.clearMask()
            else:
                radius = float(self.RADIUS)
                path = QPainterPath()

                rectf = QRectF(-1.0, 0.0, float(w + 1), float(h))
                path.addRoundedRect(rectf, radius, radius)
                region = QRegion(path.toFillPolygon().toPolygon())
                self.setMask(region)
        except Exception:
            pass
        super().resizeEvent(e)

    def paintEvent(self, e):
        super().paintEvent(e)
        try:
            painter = QPainter(self)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            r = self.rect()
            rr = QRectF(r).adjusted(0.5, 0.5, -0.5, -0.5)

            thin_border_color = QColor(
                self.theme_manager.get_color("input.border.thin")
            )
            alpha = max(8, int(thin_border_color.alpha() * 0.66))
            thin_border_color.setAlpha(alpha)
            pen = QPen(thin_border_color)
            pen.setWidthF(0.66)
            pen.setCapStyle(Qt.PenCapStyle.FlatCap)
            painter.setPen(pen)
            painter.drawRoundedRect(rr, self.RADIUS, self.RADIUS)

            if self.hasFocus():
                underline_config = UnderlineConfig(color=self.theme_manager.get_color("accent"), alpha=255, thickness=1.0)
            else:
                underline_config = UnderlineConfig(alpha=120, thickness=1.0)

            draw_bottom_underline(painter, r, self.theme_manager, underline_config)
            painter.end()
        except Exception:
            pass


--- Файл: ./src/ui/widgets/atomic/icon_button.py ---
from PyQt6.QtCore import QSize, Qt, pyqtSignal
from PyQt6.QtWidgets import QHBoxLayout, QLabel, QWidget

from ui.icon_manager import AppIcon, get_icon
from ui.theme import ThemeManager

class IconButton(QWidget):
    clicked = pyqtSignal()

    def __init__(self, icon: AppIcon, parent: QWidget = None):
        super().__init__(parent)

        self.setAttribute(Qt.WidgetAttribute.WA_StyledBackground, True)

        self.setProperty("class", "icon-button")
        self.setProperty("variant", "default")

        self.setFixedSize(36, 36)

        self._icon_size = QSize(22, 22)
        self._icon = icon
        self._flyout_is_open = False

        self.theme_manager = ThemeManager.get_instance()
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        self.icon_label = QLabel(self)
        self.icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.icon_label)

        self.setProperty("state", "normal")

        self._update_icon()

        self.theme_manager.theme_changed.connect(self._update_icon)

        self.style().polish(self)

    def setFlyoutOpen(self, is_open: bool):
        if self._flyout_is_open != is_open:
            self._flyout_is_open = is_open
            if not is_open:
                should_be_hovered = self.rect().contains(
                    self.mapFromGlobal(self.cursor().pos())
                )
                new_state = "hover" if should_be_hovered else "normal"
                self.setProperty("state", new_state)
            else:
                self.setProperty("state", "normal")
            self.style().unpolish(self)
            self.style().polish(self)
            self.update()

    def setIconSize(self, size: QSize):
        self._icon_size = size
        self._update_icon()

    def _update_icon(self):
        pixmap = get_icon(self._icon).pixmap(self._icon_size)
        self.icon_label.setPixmap(pixmap)

    def enterEvent(self, event):
        if not self._flyout_is_open:
            self.setProperty("state", "hover")
            self.style().unpolish(self)
            self.style().polish(self)
            self.update()
        super().enterEvent(event)

    def leaveEvent(self, event):
        if not self._flyout_is_open:
            self.setProperty("state", "normal")
            self.style().unpolish(self)
            self.style().polish(self)
            self.update()
        super().leaveEvent(event)

    def mousePressEvent(self, event):
        if not self._flyout_is_open:
            self.setProperty("state", "pressed")
            self.style().unpolish(self)
            self.style().polish(self)
            self.update()
        super().mousePressEvent(event)

    def mouseReleaseEvent(self, event):
        if not self._flyout_is_open:
            is_hovered = self.rect().contains(event.pos())
            self.setProperty("state", "hover" if is_hovered else "normal")
            self.style().unpolish(self)
            self.style().polish(self)
            self.update()
            if is_hovered and event.button() == Qt.MouseButton.LeftButton:
                self.clicked.emit()
        super().mouseReleaseEvent(event)


--- Файл: ./src/ui/widgets/atomic/minimalist_scrollbar.py ---
from PyQt6.QtCore import QRect, Qt
from PyQt6.QtGui import QColor, QPainter
from PyQt6.QtWidgets import QScrollBar

from ui.theme import ThemeManager

class MinimalistScrollBar(QScrollBar):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.theme_manager = ThemeManager.get_instance()

        self._is_dragging = False
        self._drag_start_offset = 0

        self._idle_thickness = 4
        self._hover_thickness = 6
        self._drag_thickness = 10

        self._idle_color = QColor()
        self._hover_color = QColor()

        self._update_colors()
        self.theme_manager.theme_changed.connect(self._update_colors)

        self.setMouseTracking(True)

    def _update_colors(self):
        if self.theme_manager.is_dark():
            self._idle_color = QColor(255, 255, 255, 60)
            self._hover_color = QColor(255, 255, 255, 90)
        else:
            self._idle_color = QColor(0, 0, 0, 70)
            self._hover_color = QColor(0, 0, 0, 100)
        self.update()

    def paintEvent(self, event):
        if self.minimum() == self.maximum():
            return

        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)

        handle_rect = self._get_handle_rect()
        if handle_rect.isEmpty():
            return

        if self._is_dragging:
            current_color = self.theme_manager.get_color("accent")
        elif self.underMouse():
            current_color = self._hover_color
        else:
            current_color = self._idle_color

        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(current_color)
        radius = handle_rect.width() / 2.0
        painter.drawRoundedRect(handle_rect, radius, radius)

    def _get_handle_rect(self):
        if self.minimum() == self.maximum():
            return QRect()

        if self._is_dragging:
            current_thickness = self._drag_thickness
        elif self.underMouse():
            current_thickness = self._hover_thickness
        else:
            current_thickness = self._idle_thickness

        v_padding = 8
        groove_height = self.height() - v_padding * 2

        total_range = self.maximum() - self.minimum() + self.pageStep()
        if total_range <= 0 or groove_height <= 0:
            return QRect()

        handle_height = max((self.pageStep() / total_range) * groove_height, 20)
        scroll_range = self.maximum() - self.minimum()

        track_height = groove_height - handle_height

        handle_y_relative = (
            (self.value() - self.minimum()) / scroll_range * track_height
            if scroll_range > 0
            else 0
        )
        handle_y = handle_y_relative + v_padding
        handle_x = (self.width() - current_thickness) // 2

        return QRect(
            int(handle_x), int(handle_y), int(current_thickness), int(handle_height)
        )

    def mousePressEvent(self, event):
        if event.button() != Qt.MouseButton.LeftButton:
            return

        handle_rect = self._get_handle_rect()

        if handle_rect.contains(event.pos()):
            self._is_dragging = True
            self._drag_start_offset = event.pos().y() - handle_rect.y()
            self.update()
            event.accept()
            return

        v_padding = 8
        handle_height = handle_rect.height()
        track_height = (self.height() - v_padding * 2) - handle_height

        new_y = event.pos().y() - v_padding - (handle_height / 2)

        scroll_range = self.maximum() - self.minimum()
        if track_height > 0:
            new_value = self.minimum() + (new_y / track_height) * scroll_range
            self.setValue(int(new_value))

            self._is_dragging = True
            self._drag_start_offset = handle_height / 2
            self.update()

        event.accept()

    def mouseMoveEvent(self, event):
        if self._is_dragging:
            v_padding = 8
            handle_height = self._get_handle_rect().height()
            track_height = (self.height() - v_padding * 2) - handle_height

            mouse_pos_in_track = event.pos().y() - v_padding - self._drag_start_offset

            scroll_range = self.maximum() - self.minimum()
            if track_height > 0:
                new_value = (
                    self.minimum() + (mouse_pos_in_track / track_height) * scroll_range
                )
                self.setValue(int(new_value))

        event.accept()

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self._is_dragging = False
            self.update()
            event.accept()

    def enterEvent(self, event):
        self.update()
        super().enterEvent(event)

    def leaveEvent(self, event):
        self.update()
        super().leaveEvent(event)


--- Файл: ./src/ui/widgets/atomic/custom_group_widget.py ---
"""
Custom group widget with custom border drawing.

Provides dynamic border updates and title rendering
with theme-aware styling capabilities.
"""

from PyQt6.QtCore import QRect, Qt
from PyQt6.QtGui import QColor, QFontMetrics, QPainter, QPen
from PyQt6.QtWidgets import QSizePolicy, QVBoxLayout, QWidget

from ui.theme import ThemeManager

class CustomGroupWidget(QWidget):
    """Custom group widget with custom border drawing."""

    def __init__(self, title_text: str = "", parent=None):
        super().__init__(parent)
        self._title_text = title_text
        self._border_radius = 8
        self._border_width = 1
        self._title_padding = 10

        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)

        self._content_layout = QVBoxLayout(self)
        self._setup_layout()

        self.setMinimumHeight(60)

        self.theme_manager = ThemeManager.get_instance()
        self.theme_manager.theme_changed.connect(self.update)

    def _setup_layout(self):
        """Sets up layout considering space for title."""
        title_height = self._get_title_height()
        self._content_layout.setContentsMargins(10, title_height // 2 + 10, 10, 10)
        self._content_layout.setSpacing(6)

    def _get_title_height(self):
        """Returns title height considering boldness."""
        if not self._title_text: return 0
        font = self.font()
        font.setBold(True)
        font_metrics = QFontMetrics(font)
        return font_metrics.height()

    def _get_title_width(self):
        """Returns title width considering boldness."""
        if not self._title_text: return 0
        font = self.font()
        font.setBold(True)
        font_metrics = QFontMetrics(font)
        return font_metrics.horizontalAdvance(self._title_text)

    def set_title(self, title: str):
        if self._title_text != title:
            self._title_text = title
            self._update_layout_margins()
            self.update()
            self.updateGeometry()
            if self.parent() and self.parent().layout():
                self.parent().layout().invalidate()

    def get_title(self): return self._title_text
    def _update_layout_margins(self):
        title_height = self._get_title_height()
        self._content_layout.setContentsMargins(10, title_height // 2 + 10, 10, 10)

    def add_widget(self, widget): self._content_layout.addWidget(widget)
    def add_layout(self, layout): self._content_layout.addLayout(layout)

    def paintEvent(self, event):
        super().paintEvent(event)
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)

        border_color = self.theme_manager.get_color("dialog.border")
        pen = QPen(border_color, self._border_width)
        painter.setPen(pen)

        rect = self.rect()
        title_height = self._get_title_height()
        title_width = self._get_title_width()

        border_rect = QRect(0, title_height // 2, rect.width() - 1, rect.height() - title_height // 2 - 1)
        painter.drawRoundedRect(border_rect, self._border_radius, self._border_radius)

        if self._title_text:

            title_horz_padding = 3

            title_bg_rect = QRect(
                self._title_padding,
                0,
                title_width + 2 * title_horz_padding,
                title_height
            )

            bg_color = self.theme_manager.get_color("dialog.background")
            painter.fillRect(title_bg_rect, bg_color)

            text_rect = QRect(self._title_padding + title_horz_padding, 0, title_width, title_height)

            font = self.font()
            font.setBold(True)
            painter.setFont(font)

            text_color = self.theme_manager.get_color("dialog.text")
            painter.setPen(text_color)
            painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, self._title_text)

class CustomGroupBuilder:
    @staticmethod
    def create_styled_group(title_text: str):
        group_widget = CustomGroupWidget(title_text)
        content_layout = group_widget._content_layout
        class TitleWidget:
            def __init__(self, group_widget): self._group = group_widget
            def setText(self, text): self._group.set_title(text)
            def text(self): return self._group.get_title()
            def _update_group_size(self): self._group.updateGeometry()
        title_widget = TitleWidget(group_widget)
        return group_widget, content_layout, title_widget


--- Файл: ./src/ui/font_manager.py ---
import os
import logging
from PyQt6.QtCore import QObject, pyqtSignal
from PyQt6.QtGui import QFont, QFontDatabase
from PyQt6.QtWidgets import QApplication

from utils.paths import resource_path

logger = logging.getLogger("FontManager")

class FontManager(QObject):
    """Manager for managing application fonts."""

    _instance = None
    font_changed = pyqtSignal()

    @classmethod
    def get_instance(cls):
        """Get the single instance of FontManager."""
        if cls._instance is None:
            cls._instance = FontManager()
        return cls._instance

    def __init__(self):
        if FontManager._instance is not None:
            raise RuntimeError("FontManager is a singleton, use get_instance()")
        super().__init__()

        self._current_mode: str = "builtin"
        self._current_family: str = ""
        self._built_in_font_path = "resources/fonts/SourceSans3-Regular.ttf"
        self._built_in_family_cache: str | None = None

    def apply_from_settings(self, settings_manager):
        """Apply font settings from SettingsManager."""

        try:
            mode = settings_manager.load_ui_font_mode()
            family = settings_manager.load_ui_font_family()

            self.set_font(mode=mode, family=family)
        except Exception as e:
            logger.warning(f"Error applying font settings: {e}")

            self.set_font(mode="builtin", family="")

    def _ensure_builtin_loaded(self) -> str | None:
        """Loads built-in font and returns family name."""
        if self._built_in_family_cache:
            return self._built_in_family_cache

        try:
            path = resource_path(self._built_in_font_path)
            if os.path.exists(path):
                font_id = QFontDatabase.addApplicationFont(path)
                families = QFontDatabase.applicationFontFamilies(font_id) if font_id != -1 else []
                if families:
                    self._built_in_family_cache = families[0]
                    return self._built_in_family_cache
        except Exception as e:
            logger.error(f"Error loading built-in font: {e}")
        return None

    def set_font(self, mode: str, family: str = ""):
        """
        Sets application font.

        Args:
            mode: Font mode ('builtin', 'system_default', 'system_custom')
            family: Font family (for system_custom)
        """

        if mode == "system":
            mode = "system_default"
        if mode not in ("builtin", "system_default", "system_custom"):
            logger.warning(f"Unknown mode '{mode}', using 'builtin'")
            mode = "builtin"

        self._current_mode = mode
        self._current_family = family or ""

        app = QApplication.instance()
        if not app:
            logger.warning("QApplication not found")
            return

        try:
            new_font = None
            if mode == "builtin":
                final_family = self._ensure_builtin_loaded()
                if final_family:
                    new_font = QFont(final_family)
                    app.setFont(new_font)
                else:
                    new_font = QFont()
                    app.setFont(new_font)

            elif mode == "system_default":
                try:
                    new_font = QFontDatabase.systemFont(QFontDatabase.SystemFont.GeneralFont)
                    app.setFont(new_font)
                except Exception as e:
                    logger.warning(f"Error getting system font: {e}")
                    new_font = QFont()
                    app.setFont(new_font)

            else:
                final_family = self._current_family or ""
                if final_family:
                    new_font = QFont(final_family)
                    app.setFont(new_font)
                else:
                    new_font = QFont()
                    app.setFont(new_font)

            self._force_widget_update(app)
            self.font_changed.emit()

        except Exception as e:
            logger.error(f"Error setting font: {e}")
            fallback_font = QFont()
            app.setFont(fallback_font)

    def _force_widget_update(self, app):
        """Force update all widgets to apply new font."""
        try:
            widgets = app.allWidgets()
            new_app_font = app.font()

            for widget in widgets:
                if widget:
                    try:
                        widget.setFont(new_app_font)
                        widget.style().unpolish(widget)
                        widget.style().polish(widget)
                        widget.update()
                        widget.updateGeometry()
                    except Exception as widget_error:
                        pass
        except Exception as e:
            logger.warning(f"Error during forced widget update: {e}")

    def get_current_mode(self) -> str:
        """Get current font mode."""
        return self._current_mode

    def get_current_family(self) -> str:
        """Get current font family."""
        return self._current_family

    def get_builtin_family(self) -> str | None:
        """Get built-in font name."""
        return self._ensure_builtin_loaded()

    def is_builtin_available(self) -> bool:
        """Check if built-in font is available."""
        return self._ensure_builtin_loaded() is not None


--- Файл: ./src/__main__.py ---
import os
import sys

base_path = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, base_path)

import argparse
import logging

from PyQt6.QtCore import QThreadPool
from PyQt6.QtGui import QIcon
from PyQt6.QtWidgets import QApplication

from core.settings import SettingsManager, setup_logging
from ui.theme import ThemeManager
from ui.tkonverter_main_window import TkonverterMainWindow
from utils.paths import resource_path

main_logger = logging.getLogger("Main")
main_window = None

def on_initialization_finished(initial_theme: str):
    global main_window
    main_window = TkonverterMainWindow(initial_theme=initial_theme)
    main_window.show()

def main():
    parser = argparse.ArgumentParser(description="Tkonverter - Logging Settings")
    parser.add_argument(
        "--enable-logging", action="store_true", help="Permanently enable logging."
    )
    parser.add_argument(
        "--disable-logging", action="store_true", help="Permanently disable logging."
    )
    args, unknown = parser.parse_known_args()

    settings_manager = SettingsManager("tkonverter", "tkonverter")

    if args.enable_logging or args.disable_logging:
        app_instance = QApplication.instance()
        if not app_instance:
            app_instance = QApplication(sys.argv)
        enabled = args.enable_logging
        settings_manager.save_debug_mode(enabled)
        status = "enabled" if enabled else "disabled"
        print(f"Permanent logging was {status}.")
        sys.exit(0)

    app = QApplication(sys.argv)

    icon_path = resource_path("resources/icons/icon.png")
    if os.path.exists(icon_path):
        app.setWindowIcon(QIcon(icon_path))

    app.setApplicationName("Tkonverter")
    app.setApplicationDisplayName("Tkonverter")
    app.setApplicationVersion("1.0.0")
    app.setOrganizationName("tkonverter")
    app.setOrganizationDomain("tkonverter.local")

    session_debug = os.environ.get("DEBUG", "false").lower() in ("true", "1", "yes")
    permanent_debug = settings_manager.load_debug_mode()
    debug_mode = session_debug or permanent_debug
    log_level = logging.DEBUG if debug_mode else logging.WARNING

    if debug_mode:

        logging.basicConfig(
            level=log_level,
            format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
            handlers=[logging.StreamHandler()]
        )
    else:

        logging.basicConfig(
            level=log_level,
            format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
            handlers=[logging.StreamHandler()]
        )

    logging.getLogger("matplotlib").setLevel(logging.WARNING)
    logging.getLogger("PyQt6").setLevel(logging.WARNING)
    main_logger.setLevel(log_level)

    try:
        import ctypes
        if sys.platform == "win32":
            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID("tkonverter.app.1.0.0")
    except (ImportError, AttributeError):
        pass

    theme_manager = ThemeManager.get_instance()

    theme_from_env = os.environ.get("APP_THEME", "").lower()

    if theme_from_env in ("light", "dark", "auto"):
        final_theme_to_apply = theme_from_env
    else:
        final_theme_to_apply = settings_manager.load_theme()

    theme_manager.set_theme(final_theme_to_apply, app)

    on_initialization_finished(initial_theme=final_theme_to_apply)

    def on_quit():
        if not QThreadPool.globalInstance().waitForDone(3000):
            QThreadPool.globalInstance().clear()

    app.aboutToQuit.connect(on_quit)
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
